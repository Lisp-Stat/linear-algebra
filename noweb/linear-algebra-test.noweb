
\documentclass{report}%

\pdfinfo{
  /Title (Numerical Linear Algebra in ANSI Common Lisp Unit Tests)
  /Author (Thomas M. Hermann)
  /CreationDate (D:20080524095529-05'00)
  /ModDate (D:20100402125500-05'00)
  /Subject (Linear Algebra Testing)
  /Keywords (Linear Algebra Test) }

\usepackage{noweb}%
\usepackage{amssymb,amsmath}%
\usepackage[pdftex]{xcolor,graphicx}%
\usepackage{cite}%
\usepackage{nomencl}%

\noweboptions{smallcode}%

\newcommand{\result}{\mbox{result}}%
\newcommand{\typespec}[1]{\textbf{#1}\hfill Type Specifier\\}%
\newcommand{\function}[1]{\textbf{#1} \hfill Function\\}%
\newcommand{\macro}[1]{\textbf{#1} \hfill Macro\\}%
\newcommand{\note}[1]{
  \setlength{\fboxsep}{5pt}
  \medskip\noindent\ignorespaces
  \begin{center}
  \fbox{\parbox{0.9\textwidth}{\textbf{Note: }#1}}
  \end{center}
  \par\medskip
  \setlength{\fboxsep}{3pt}
}%

\title{Numerical Linear Algebra in ANSI Common Lisp\\Unit Tests}%

\author{Thomas M. Hermann}%

\makeglossary%

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\printglossary%

\chapter{Introduction}
\label{chap:introduction}

The numerical linear algebra package in ANSI Common Lisp is a native
implementation of linear algebra routines based on the Basic Linear
Algebra Subroutines Technical(BLAST) Forum
Standard\cite{blast-report}. It is comprised of a vector and matrix
interface implemented in the CLOS and routines to solve common
numerical linear algebra problems. Numerical linear algebra routines
are generally rated in terms of floating point operations per
second(FLOPS) with the assumption that the routines are correct. The
objective of the unit tests presented in this document is to establish
that the numerical linear algebra routines are correct.  The unit
testing presented in this document utilizes the lisp-unit framework
developed by Chris Riesbeck. All tests are defined in the ``Linear
Algebra Test'' package.

\nomenclature{BLAS}{Basic Linear Algebra Subprograms.}
\nomenclature{FLOPS}{Floating Point Operations Per Second.}

<<In linear algebra unit tests>>=
<<BSD Copyright>>
(common-lisp:in-package #:linear-algebra-test)

@

\note{The unit testing presented in this document is at a preliminary
  state. It is more an outline of the testing and not a comprehensive
  set of tests. This unit testing is critical to establishing the
  correctness of the linear algebra library. Before the first release
  of the library, an extensive literature review should be performed
  to identify edge cases and algorithmic issues with the linear
  algebra routines that are implemented. Those cases and issues should
  be incorporated into the testing.}

\chapter{Vector Tests}
\label{chap:vector-tests}

Uniting testing of vector construction, data operations and
fundamental operations is defined in this chapter.

\section{Vector Interface}
\label{sec:vector-interface}

The vector interface is primarily composed of generic functions that
do not require testing. The vector object predicate, Givens rotation
and Jacobi rotation do require unit tests. The Householder reflection
must be tested for specific vector objects.
<<vector.lisp>>=
<<In linear algebra unit tests>>
<<Unit test: Vector predicate>>
<<Unit test: Givens rotation>>
<<Unit test: Jacobi rotation>>
@ The vector tests depend on definition of the linear algebra test
package.
<<Vector test dependencies>>=
(:file "vector"
       :depends-on ("defpackage"))
@

\subsection{Vector Object Predicate}
\label{sec:vector-object-predicate}

The vector object predicate returns true if the object is a vector
object.
<<Unit test: Vector predicate>>=
(define-test vector-object-p
  (assert-true (linear-algebra:vector-object-p
		(make-instance 'linear-algebra:vector-object)))
  (assert-false (linear-algebra:vector-object-p t)))

@ 

\subsection{Vector Transformations}
\label{sec:vector-transformations}

Three vector transformations are implemented and tested, Givens
rotation, Householder transformation and the Jacobi rotation.

\subsection{Givens Rotation}
\label{sec:givens-rotation}

The Givens rotation is tested for several conditions of $f$ and $g$.
\emph{Discussion of these tests needs to be expanded.}
<<Unit test: Givens rotation>>=
;;; Givens Rotation
(define-test givens-rotation
  ;; g = 0
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation 0 0)
    (assert-rational-equal 1 c)
    (assert-rational-equal 0 s)
    (assert-rational-equal 0 r))
  ;; Real f
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation 1 0)
    (assert-rational-equal 1 c)
    (assert-rational-equal 0 s)
    (assert-rational-equal 1 r))
  ;; Imaginary f
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation #C(1 1) 0)
    (assert-rational-equal 1 c)
    (assert-rational-equal 0 s)
    (assert-rational-equal #C(1 1) r))
  ;; f = 0 , negative g
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation 0 -1)
    (assert-rational-equal  0 c)
    (assert-rational-equal -1 s)
    (assert-rational-equal  1 r))
  ;; f = 0 , Real g
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation 0 1)
    (assert-rational-equal 0 c)
    (assert-rational-equal 1 s)
    (assert-rational-equal 1 r))
  ;; f = 0 , Imaginary g
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation 0 #C(1 1))
    (assert-rational-equal 0 c)
    (assert-float-equal #C(0.70710677 -0.70710677) s)
    (assert-float-equal  1.4142135 r))
  ;; Rational f and g
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation 1 2)
    (assert-float-equal 0.4472136 c)
    (assert-float-equal 0.8944272 s)
    (assert-float-equal 2.236068  r))
  ;; Float f and g
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation 1.1 2.3)
    (assert-float-equal 0.4314555 c)
    (assert-float-equal 0.9021342 s)
    (assert-float-equal 2.5495098 r))
  ;; Complex rational f and g
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation #C(1 2) #C(3 4))
    (assert-float-equal 0.40824828 c)
    (assert-float-equal #C(0.8981462 0.16329929) s)
    (assert-float-equal #C(2.4494898 4.8989797) r))
  ;; Complex float f and g
  (multiple-value-bind (c s r)
      (linear-algebra:givens-rotation #C(1.2 2.3) #C(3.4 4.5))
    (assert-float-equal 0.4178801 c)
    (assert-float-equal #C(0.8959895 0.15026298) s)
    (assert-float-equal #C(2.8716373 5.503971) r)))

@ 

\subsection{Jacobi Rotation}
\label{sec:jacobi-rotation}
The Jacobi rotation is tested for a symmetric and Hermitian input.
\emph{Discussion of these tests needs to be expanded.}
<<Unit test: Jacobi rotation>>=
;;; Jacobi Rotation
(define-test jacobi-rotation
  ;; Symmetric test
  (multiple-value-bind (a b c s)
      (linear-algebra:jacobi-rotation 1.1 3.3 5.5)
    (assert-float-equal -0.66610646 a)
    (assert-float-equal  7.266106   b)
    (assert-float-equal  0.8816746  c)
    (assert-float-equal -0.4718579  s))
  ;; Hermitian test
  (multiple-value-bind (a b c s)
      (linear-algebra:jacobi-rotation 1.1 #C(3.3 7.7) 5.5)
    (assert-float-equal -5.3614073  a)
    (assert-float-equal 11.961407   b)
    (assert-float-equal  0.79183334 c)
    (assert-float-equal #C(-0.24058115 0.561356) s)))

@ 

\chapter{Data Vector Tests}
\label{chap:data-vector-tests}

Unit tests of the data vector operations are presented in this section.
<<data-vector.lisp>>=
<<In linear algebra unit tests>>
<<Test: Make a data vector>>
<<Test: Create a column vector>>
<<Test: Create a row vector>>
<<Test: Column vector predicate>>
<<Test: Row vector predicate>>
<<Test: Data vector bounds predicate>>
<<Test: Data vector element type>>
<<Test: Data vector length>>
<<Test: Data vector element reference>>
<<Test: Copy the data vector>>
<<Test: Subset of the data vector>>
<<Test: Destructively replace the data vector subset>>
<<Test: Map over the data vector>>
<<Test: Map into the data vector>>
<<Test: Householder reflection of the data vector>>
<<Test: Apply coordinate rotation to the data vectors>>
<<Test: Destructively apply coordinate rotation to the data vectors>>
<<Test: Scaled sum of squares for data vectors>>
<<Test: Scaled sum of the powers of p for data vectors>>
<<Test: Data vector Taxicab norm>>
<<Test: Data vector Euclidean norm>>
<<Test: Data vector P-norm>>
<<Test: Data vector Infinity norm>>
<<Test: Data vector norm>>
<<Test: Data vector transpose>>
<<Test: Destructive data vector transpose>>
<<Test: Data vector permutation>>
<<Test: Destructive data vector permutation>>
<<Test: Data vector scale>>
<<Test: Destructive data vector scale>>
<<Test: Data vector addition>>
<<Test: Destructive data vector addition>>
<<Test: Data vector subtraction>>
<<Test: Destructive data vector subtraction>>
<<Test: Data vector dot product>>
@ The data vector tests depend on definition of the linear algebra
test package.
<<Data vector test dependencies>>=
(:file "data-vector"
       :depends-on ("defpackage"))
@

\section{Creating a Data Vector Tests}
\label{sec:creating-data-vectors-tests}

The [[make-vector]] function returns either a column or row vector.
Either the initial element or the initial contents may be specified,
but not both. If neither is specified, the elements of the vector are
initialized to zero. The only error checking that is tested is the
presence of both the [[:initial-element]] and [[:initial-contents]]
keyword. The rest of the error checking is handled by [[make-array]].
<<Test: Make a data vector>>=
(define-test make-data-vector
  <<Make a default data vector>>
  <<Specify the data vector type>>
  <<Specify the data vector element type>>
  <<Specify the data vector initial element>>
  <<Specify the data vector initial contents>>
  <<Data vector error with initial element and contents>>)

@ Making a vector with no options should result in a column vector of
[[size]] initialized with zeroes.
<<Make a default data vector>>=
;; A default vector.
(assert-true
 (typep (linear-algebra:make-vector 10)
        'linear-algebra::vector-object))
(assert-true
 (typep (linear-algebra:make-vector 10)
        'linear-algebra:column-vector))
(assert-rational-equal
 (vector 0 0 0 0 0 0 0 0 0 0)
 (linear-algebra:make-vector 10))
@ Two types of vectors can be defined with [[make-vector]], a
[[column-vector]] and a [[row-vector]].
<<Specify the data vector type>>=
;; Specify the vector type
(assert-true
 (typep (linear-algebra:make-vector
         10 :vector-type 'linear-algebra:column-vector)
        'linear-algebra:column-vector))
(assert-true
 (typep (linear-algebra:make-vector
         10 :vector-type 'linear-algebra:row-vector)
        'linear-algebra:row-vector))
@ The data type of the vector elements is specified with the
[[:element-type]] keyword. This option is tested for 2 data types,
[[single-float]] and [[(complex single-float)]].
<<Specify the data vector element type>>=
;; Specify the element type.
(assert-true
 (subtypep (array-element-type
            (linear-algebra::contents
             (linear-algebra:make-vector
             10 :element-type 'single-float)))
           'single-float))
(assert-true
 (subtypep (array-element-type
            (linear-algebra::contents
             (linear-algebra:make-vector
             10 :element-type '(complex single-float))))
           '(complex single-float)))
@ The keyword [[:initial-element]] is tested using a single-float
value of 1.0 and a complex value of (1.0,2.0).
<<Specify the data vector initial element>>=
;; Specify the initial element.
(assert-float-equal
 (vector 1.0 1.0 1.0 1.0 1.0)
 (linear-algebra:make-vector 5 :initial-element 1.0))
(assert-float-equal
 (vector #C(1.0 2.0) #C(1.0 2.0)
         #C(1.0 2.0) #C(1.0 2.0))
 (linear-algebra:make-vector 4 :initial-element #C(1.0 2.0)))
@ The keyword [[:initial-contents]] is tested by constructing a new
vector from random data and comparing each element of the new vector
and the data.
<<Specify the data vector initial contents>>=
;; Specify the initial contents.
(let ((data (make-random-list 100 1.0)))
  (assert-float-equal
   (make-array 100 :initial-contents data)
   (linear-algebra:make-vector 100 :initial-contents data)))
@ This is the only test for an error in a combination of keyword
arguments.
<<Data vector error with initial element and contents>>=
;; It is an error to specify both initial element and contents.
(assert-error
 'error
 (linear-algebra:make-vector
  3 :initial-element 1.0
  :initial-contents (list 1.1 2.2 3.3)))
@

There are 2 convience functions for creating small column and row
vectors. These functions are tested for type and content.
[[column-vector]] returns a column vector with the supplied content.
<<Test: Create a column vector>>=
(define-test column-vector
  ;; Column vector
  (assert-true
   (typep (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)
          'linear-algebra:column-vector))
  ;; Contents
  (assert-float-equal
   (vector 1.0 2.0 3.0 4.0 5.0)
   (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)))

@ Similarly, [[row-vector]] returns a row vector with the supplied
content.
<<Test: Create a row vector>>=
(define-test row-vector
  ;; row vector
  (assert-true
   (typep (linear-algebra:row-vector 1.0 2.0 3.0 4.0 5.0)
          'linear-algebra:row-vector))
  ;; Contents
  (assert-float-equal
   (vector 1.0 2.0 3.0 4.0 5.0)
   (linear-algebra:row-vector 1.0 2.0 3.0 4.0 5.0)))

@ 

\section{Test Data Vector Predicates}
\label{sec:test-data-vector-predicates}

There are 3 predicates specific to linear algebra vectors. The first
predicate returns true if the object is a column vector. The testing
checks one true result and one false result.
<<Test: Column vector predicate>>=
(define-test column-vector-p
  (assert-true
   (linear-algebra:column-vector-p
    (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)))
  (assert-false
   (linear-algebra:column-vector-p
    (linear-algebra:row-vector 1 2 3 4 5))))

@ The second predicate returns true if the object is a row vector. The
testing checks one true result and one false result.
<<Test: Row vector predicate>>=
(define-test row-vector-p
  (assert-true
   (linear-algebra:row-vector-p
    (linear-algebra:row-vector 1.0 2.0 3.0 4.0 5.0)))
  (assert-false
   (linear-algebra:row-vector-p
    (linear-algebra:column-vector 1 2 3 4 5))))

@ The final predicate returns true if the index is valid for the
vector. The testing validates this predicate for the end indices as
well as a middle indice for a column and row vector.
<<Test: Data vector bounds predicate>>=
(define-test data-vector-in-bounds-p
  ;; Column vector bounds
  (let ((cvec (linear-algebra:column-vector 1 2 3 4 5)))
    (assert-true
     (linear-algebra:vector-in-bounds-p cvec 0))
    (assert-true
     (linear-algebra:vector-in-bounds-p cvec 4))
    (assert-true
     (linear-algebra:vector-in-bounds-p cvec (random 5)))
    (assert-false
     (linear-algebra:vector-in-bounds-p cvec 10)))
  ;; Row vector bounds
  (let ((rvec (linear-algebra:column-vector 1 2 3 4 5)))
    (assert-true
     (linear-algebra:vector-in-bounds-p rvec 0))
    (assert-true
     (linear-algebra:vector-in-bounds-p rvec 4))
    (assert-true
     (linear-algebra:vector-in-bounds-p rvec (random 5)))
    (assert-false
     (linear-algebra:vector-in-bounds-p rvec 10))))

@ 

\section{Test Data Vector Inspection}
\label{sec:test-data-vector-inspection}

Tests for the 2 vector inspection functions are presented in this
section. The first inspection function returns the specific element
type. It is tested on both the column and row vectors.
<<Test: Data vector element type>>=
(define-test data-vector-element-type
  ;; Column vector
  (assert-true
   (subtypep
    (linear-algebra:vector-element-type
     (linear-algebra:make-vector
      5 :element-type 'single-float
      :vector-type 'linear-algebra:column-vector))
    'single-float))
  ;; Row vector
  (assert-true
   (subtypep
    (linear-algebra:vector-element-type
     (linear-algebra:make-vector
      5 :element-type 'single-float
      :vector-type 'linear-algebra:row-vector))
    'single-float)))

@ The second inspection function returns the length of the vector. It
is also tested on both types of linear algebra vectors.
<<Test: Data vector length>>=
(define-test data-vector-length
  (assert-eq
   5 (linear-algebra:vector-length
      (linear-algebra:column-vector 1 2 3 4 5)))
  (assert-eq
   5 (linear-algebra:vector-length
      (linear-algebra:row-vector 1 2 3 4 5))))

@ 

\section{Test Data Vector Reference}
\label{sec:test-data-vector-reference}

The [[vref]] function is used to reference an element of a vector and
is settable.
<<Test: Data vector element reference>>=
(define-test data-vref
  <<Reference the data vector element>>
  <<Set the data vector element>>
  <<Not a data vector type error>>)

@ Three elements are used for the testing, the first element, the last
element and a random intermediate element.
<<Reference the data vector element>>=
;; Reference the element of a vector.
(let* ((size 1000)
       (index (random-interior-index size))
       (end   (1- size))
       (list   (make-random-list size 100.0))
       (vector (linear-algebra:make-vector
                size :initial-contents list)))
  (assert-float-equal
   (nth 0 list) (linear-algebra:vref vector 0))
  (assert-float-equal
   (nth index list) (linear-algebra:vref vector index))
  (assert-float-equal
   (nth end list) (linear-algebra:vref vector end)))
@ Similiarly, the first, last and a random intermediate element are
set using [[vref]] for testing.
<<Set the data vector element>>=
;; Setting an element of a vector.
(let* ((size 1000)
       (val0  (random 100.0))
       (vali  (random 100.0))
       (valn  (random 100.0))
       (index (random-interior-index size))
       (end   (1- size))
       (list   (make-random-list size 100.0))
       (vector (linear-algebra:make-vector
                size :initial-contents list)))
  (setf (linear-algebra:vref vector 0)     val0)
  (setf (linear-algebra:vref vector index) vali)
  (setf (linear-algebra:vref vector end)   valn)
  (assert-float-equal
   val0 (aref (linear-algebra::contents vector) 0))
  (assert-float-equal
   vali (aref (linear-algebra::contents vector) index))
  (assert-float-equal
   valn (aref (linear-algebra::contents vector) end)))
@ The only error handling [[vref]] performs is to verify that the
argument is a vector. The following 2 tests validate this error
checking for referencing and setting a vector.
<<Not a data vector type error>>=
;; VREF only works for vectors.
(let ((list (make-list 1000 :initial-element 10.0))
      (index (random 1000)))
  (assert-error
   'error (linear-algebra:vref list index))
  (assert-error
   'error (setf (linear-algebra:vref list index) 42.0)))
@

\section{Test Copying Data Vectors}
\label{sec:test-copying-data-vectors}

The tests for [[copy-vector]] verify that a new vector of the same
type is returned.
<<Test: Copy the data vector>>=
(define-test copy-data-vector
  ;; Column vector
  (let* ((vec (linear-algebra:column-vector 1 2 3 4 5))
         (new (linear-algebra:copy-vector vec)))
    (assert-true (subtypep (type-of new) (type-of vec)))
    (assert-false (eq vec new))
    (assert-false (eq (linear-algebra::contents vec)
                      (linear-algebra::contents new)))
    (assert-rational-equal vec new))
  ;; Row vector
  (let* ((vec (linear-algebra:row-vector 1 2 3 4 5))
         (new (linear-algebra:copy-vector vec)))
    (assert-true (subtypep (type-of new) (type-of vec)))
    (assert-false (eq vec new))
    (assert-false (eq (linear-algebra::contents vec)
                      (linear-algebra::contents new)))
    (assert-rational-equal vec new)))

@ 

\section{Test Subsets of Data Vectors}
\label{sec:test-vector-data-subsets}

Subsets of vectors are modified with 2 functions, [[subvector]] and
[[replace-vector]]. The subset of a data vector is returned from
[[subvector]].
<<Test: Subset of the data vector>>=
(define-test data-subvector
  <<Subvector of the data vector>>
  <<Set the subvector of the data vector>>)

@ The subvector of a data vector should return a new vector with the
modified subset.
<<Subvector of the data vector>>=
;; Get subvectors
(let* ((data (list 0 1 2 3 4 5 6 7 8 9))
       (vec  (linear-algebra:column-vector
              0 1 2 3 4 5 6 7 8 9))
       (index (random-interior-index 10))
       (subvec0 (linear-algebra:subvector
                 vec index))
       (subvec1 (linear-algebra:subvector
                 vec 0 index)))
  (assert-true
   (subtypep (type-of vec) (type-of subvec0)))
  (assert-true
   (subtypep (type-of vec) (type-of subvec1)))
  (assert-rational-equal
   (subseq data index) subvec0)
  (assert-rational-equal
   (subseq data 0 index) subvec1))
@ The subvector is settable.
<<Set the subvector of the data vector>>=
;; Set subvectors
(let ((vec (linear-algebra:make-vector 10))
      (data (linear-algebra:make-vector
             5 :initial-element 1)))
  (assert-rational-equal
   #(1 1 1 1 1)
   (setf (linear-algebra:subvector vec 7) data))
  (assert-rational-equal
   '(0 0 0 0 0 0 0 1 1 1) vec))
@ Finally, the subset of a vector can be destructively modified.
\emph{The discussion of this testing needs to be expanded.}
<<Test: Destructively replace the data vector subset>>=
(define-test replace-data-vector
  (flet ((zero-vector () (linear-algebra:make-vector 10)))
    (let ((data (linear-algebra:make-vector
		 5 :initial-element 1)))
      (assert-rational-equal
       #(1 1 1 1 1 0 0 0 0 0)
        (linear-algebra:replace-vector (zero-vector) data))
      (assert-rational-equal
       #(0 0 1 1 1 1 1 0 0 0)
       (linear-algebra:replace-vector (zero-vector) data
				      :start1 2))
      (assert-rational-equal
       #(0 0 0 0 0 0 0 0 1 1)
       (linear-algebra:replace-vector (zero-vector) data
				      :start1 8))
      (assert-rational-equal
       #(1 1 1 0 0 0 0 0 0 0)
       (linear-algebra:replace-vector (zero-vector) data
				      :end1 3))
      (assert-rational-equal
       #(0 0 1 1 0 0 0 0 0 0)
       (linear-algebra:replace-vector (zero-vector) data
				      :start1 2 :end1 4))
      (assert-rational-equal
       #(1 1 1 0 0 0 0 0 0 0)
       (linear-algebra:replace-vector (zero-vector) data
				      :start2 2))
      (assert-rational-equal
       #(1 1 0 0 0 0 0 0 0 0)
       (linear-algebra:replace-vector (zero-vector) data
	                              :end2 2))
      (assert-rational-equal
       #(1 1 1 0 0 0 0 0 0 0)
       (linear-algebra:replace-vector (zero-vector) data
				      :start2 1 :end2 4))
      (assert-rational-equal
       #(0 0 1 1 1 0 0 0 0 0)
       (linear-algebra:replace-vector (zero-vector) data
				      :start1 2 :start2 2))
      (assert-rational-equal
       #(0 0 1 1 1 0 0 0 0 0)
       (linear-algebra:replace-vector (zero-vector) data
				      :start1 2 :end2 3)))))

@ 

\section{Test Data Vector Mapping Functions}
\label{sec:test-data-vector-mapping-functions}

The vector mapping methods specialized on data vectors are organized
into 2 functions. An internal component that does not verify the
arguments and an external method that verifies the arguments and then
calls the internal version. The internal version simply wraps the
corresponding sequence mapping function with an instance of a data
vector. Therefore, the data vector version of [[map-vector]] calls the
[[\%map-data-vector]] function.
<<Test: Map over the data vector>>=
(define-test %map-data-vector
  (let ((col-data (linear-algebra:column-vector 1 1 1 1 1))
	(row-data (linear-algebra:row-vector 1 1 1 1 1)))
    (assert-true
     (typep (linear-algebra::%map-data-vector
	     'linear-algebra:column-vector
	     #'identity col-data)
	    'linear-algebra:column-vector))
    (assert-true
     (typep (linear-algebra::%map-data-vector
	     'linear-algebra:row-vector
	     #'identity col-data)
	    'linear-algebra:row-vector))
    (assert-true
     (typep (linear-algebra::%map-data-vector
	     'linear-algebra:column-vector
	     #'identity row-data)
	    'linear-algebra:column-vector))
    (assert-true
     (typep (linear-algebra::%map-data-vector
	     'linear-algebra:row-vector
	     #'identity row-data)
	    'linear-algebra:row-vector))
    (assert-rational-equal
     '(3 3 3 3 3)
     (linear-algebra::%map-data-vector
      'linear-algebra:column-vector
      #'+ col-data col-data col-data))
    (assert-rational-equal
     '(3 3 3 3 3)
     (linear-algebra::%map-data-vector
      'linear-algebra:row-vector
      #'+ row-data row-data row-data))
    (assert-rational-equal
     '(4 4 4 4 4)
     (linear-algebra::%map-data-vector
      'linear-algebra:column-vector
      #'+ col-data row-data col-data row-data))))

@ The external interface verifies that the result type is valid and
that all of the arguments are data vectors.
<<Test: Map over the data vector>>=
(define-test map-data-vector
  (let ((col-data (linear-algebra:column-vector 1 1 1 1 1))
	(row-data (linear-algebra:row-vector 1 1 1 1 1)))
    (assert-error 'error (linear-algebra:map-vector
			  'vector #'identity col-data))
    (assert-error 'error (linear-algebra:map-vector
			  'linear-algebra:column-vector
			  #'identity col-data
			  #(2 2 2 2 2)))
    (assert-rational-equal
     '(3 3 3 3 3)
     (linear-algebra:map-vector
      'linear-algebra:column-vector
      #'+ col-data row-data col-data))))

@ Similarly, the data vector version of [[map-into-vector]] calls the
internal [[\%map-into-data-vector]].
<<Test: Map into the data vector>>=
(define-test %map-into-data-vector
  (let ((col-data (linear-algebra:column-vector 1 1 1 1 1))
	(row-data (linear-algebra:row-vector 1 1 1 1 1)))
    (assert-true
     (typep (linear-algebra::%map-into-data-vector
	     col-data #'identity col-data)
	    'linear-algebra:column-vector))
    (assert-true
     (typep (linear-algebra::%map-into-data-vector
	     row-data #'identity col-data)
	    'linear-algebra:row-vector))
    (assert-true
     (typep (linear-algebra::%map-into-data-vector
	     col-data #'identity row-data)
	    'linear-algebra:column-vector))
    (assert-true
     (typep (linear-algebra::%map-into-data-vector
	     row-data #'identity row-data)
	    'linear-algebra:row-vector))
    (assert-rational-equal
     '(3 3 3 3 3)
     (linear-algebra::%map-into-data-vector
      (linear-algebra:column-vector 0 0 0 0 0)
      #'+ col-data col-data col-data))
    (assert-rational-equal
     '(3 3 3 3 3)
     (linear-algebra::%map-into-data-vector
      (linear-algebra:row-vector 0 0 0 0 0)
      #'+ row-data row-data row-data))
    (assert-rational-equal
     '(4 4 4 4 4)
     (linear-algebra::%map-into-data-vector
      col-data #'+ col-data row-data col-data row-data))))

@ Unlike [[map-vector]], the external interface for
[[map-into-vector]] only has to verify that all of the vectors are
data vectors since.
<<Test: Map into the data vector>>=
(define-test map-into-data-vector
  (let ((col-data (linear-algebra:column-vector 1 1 1 1 1))
	(row-data (linear-algebra:row-vector 1 1 1 1 1)))
    (assert-error 'error (linear-algebra:map-into-vector
			  #(0 0 0 0 0) #'identity col-data))
    (assert-error 'error (linear-algebra:map-vector
			  (linear-algebra:column-vector 0 0 0 0 0)
			  #'identity col-data))
    (assert-rational-equal
     '(3 3 3 3 3)
     (linear-algebra:map-into-vector
      col-data #'+ col-data row-data col-data))))

@ 

\section{Test Householder Reflection of a Data Vector}
\label{sec:test-householder-reflection-data-vector}

The implementation of the Householder reflection relies on vector data
operations. Consequently, it must be tested for each vector subclass.
<<Test: Householder reflection of the data vector>>=
;;; Householder Reflection
(define-test data-vector-householder-reflection
  (multiple-value-bind (beta tau vector)
      (linear-algebra:householder-reflection
       #C(1.0 2.0)
       (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0))
    (assert-float-equal -7.745967 beta)
    (assert-float-equal #C(1.1290995 0.2581989) tau)
    (assert-float-equal
     #(#C(0.2 -0.4) #C(0.4 -0.8) #C(0.6 -1.2) #C(0.8 -1.6) #C(1.0 -2.0))
     vector)))

@ 

\section{Test Rotation of a Data vector}
\label{sec:test-rotate-data-vector}

The function [[apply-rotation]] should return 2 vectors that contain
the rotation described by [[cc]] and [[ss]] applied to the input
vectors.
<<Test: Apply coordinate rotation to the data vectors>>=
;;; Apply rotation
(define-test apply-rotation-data-vector
  ;; Float
  (let ((vec1 (linear-algebra:make-vector
	       5 :element-type 'single-float
	       :initial-contents '(3.0 5.0 7.0 11.0 13.0)))
        (vec2 (linear-algebra:make-vector
	       5 :element-type 'single-float
	       :initial-contents '(4.0 9.0 16.0 25.0 36.0))))
    ;; Position 0
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 0) (linear-algebra:vref vec2 0))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:apply-rotation vec1 vec2 cc ss)
        (assert-float-equal rr (linear-algebra:vref rvec1 0))
        (assert-float-equal
	 #(5.0 10.200001 17.0 26.6 36.600002) rvec1)
        (assert-float-equal
         #(0.0 1.4000001 4.0000005 6.200001 11.2) rvec2)))
    ;; Position 1
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 1) (linear-algebra:vref vec2 1))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:apply-rotation vec1 vec2 cc ss)
        (assert-float-equal rr (linear-algebra:vref rvec1 1))
        (assert-float-equal
         #(4.953558 10.2956295 17.386017 27.196003 37.78302) rvec1)
        (assert-float-equal
         #(-0.67990017 0.0 1.651186 2.525344 6.1191006) rvec2)))
    ;; Position 2
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 2) (linear-algebra:vref vec2 2))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:apply-rotation vec1 vec2 cc ss)
        (assert-float-equal rr (linear-algebra:vref rvec1 2))
        (assert-float-equal
         #(4.867086 10.249511 17.46425 27.312943 38.19231) rvec1)
        (assert-float-equal
         #(-1.1451968 -0.97341704 0.0 -0.05725956 2.519433) rvec2)))
    ;; Position 3
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 3) (linear-algebra:vref vec2 3))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:apply-rotation vec1 vec2 cc ss)
        (assert-float-equal rr (linear-algebra:vref rvec1 3))
        (assert-float-equal
         #(4.8694763 10.251528 17.46421 27.313 38.186943) rvec1)
        (assert-float-equal
         #(-1.1349905 -0.95192766 0.036612988 9.536743e-7 2.599495) rvec2)))
    ;; Position 4
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 4) (linear-algebra:vref vec2 4))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:apply-rotation vec1 vec2 cc ss)
        (assert-float-equal rr (linear-algebra:vref rvec1 4))
        (assert-float-equal
         #(4.781149 10.163207 17.426374 27.249937 38.27532) rvec1)
        (assert-float-equal
         #(-1.4630839 -1.6459692 -1.1495662 -1.8549814 0.0) rvec2))))
  ;; Complex
  (let ((vec1 (linear-algebra:make-vector
               2 :element-type '(complex single-float)
               :initial-contents #(#C(3.0 5.0) #C(7.0 11.0))))
        (vec2 (linear-algebra:make-vector
               2 :element-type '(complex single-float)
               :initial-contents #(#C(4.0 9.0) #C(16.0 25.0)))))
    ;; Position 0
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 0) (linear-algebra:vref vec2 0))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:apply-rotation vec1 vec2 cc ss)
        (assert-float-equal rr (linear-algebra:vref rvec1 0))
        (assert-float-equal
         #(#C(5.888673 9.814455) #C(19.85367 25.27784)) rvec1)
        (assert-float-equal
         #(#C(-4.7683716e-7 -4.7683716e-7) #C(3.326425 2.6071978)) rvec2)))
    ;; Position 1
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 1) (linear-algebra:vref vec2 1))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:apply-rotation vec1 vec2 cc ss)
	;; FIXME : The error should not be this large.
	(let ((*epsilon* (* 32 single-float-epsilon)))
	  (assert-float-equal rr (linear-algebra:vref rvec1 1)))
        (assert-float-equal
         #(#C(4.8474817 10.2603855) #C(17.405037 27.350775)) rvec1)
        (assert-float-equal
         #(#C(-1.1497688 -0.9510431) #C(0.0 0.0)) rvec2)))))

@ The destructive version, [[napply-rotation]], stores the result in
the input vectors.
<<Test: Destructively apply coordinate rotation to the data vectors>>=
;;; Destructively apply rotation
(define-test napply-rotation-data-vector
  ;; Float, position 0
  (let ((vec1 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(3.0 5.0 7.0 11.0 13.0)))
        (vec2 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(4.0 9.0 16.0 25.0 36.0))))
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 0) (linear-algebra:vref vec2 0))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:napply-rotation vec1 vec2 cc ss)
        (assert-eq vec1 rvec1)
        (assert-eq vec2 rvec2)
        (assert-float-equal rr (linear-algebra:vref vec1 0))
        (assert-float-equal
         #(5.0 10.200001 17.0 26.6 36.600002) vec1)
        (assert-float-equal
         #(0.0 1.4000001 4.0000005 6.200001 11.2) vec2))))
  ;; Float, position 1
  (let ((vec1 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(3.0 5.0 7.0 11.0 13.0)))
        (vec2 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(4.0 9.0 16.0 25.0 36.0))))
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 1) (linear-algebra:vref vec2 1))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:napply-rotation vec1 vec2 cc ss)
        (assert-eq vec1 rvec1)
        (assert-eq vec2 rvec2)
        (assert-float-equal rr (linear-algebra:vref vec1 1))
        (assert-float-equal
         #(4.953558 10.2956295 17.386017 27.196003 37.78302) vec1)
        (assert-float-equal
         #(-0.67990017 0.0 1.651186 2.525344 6.1191006) vec2))))
  ;; Float, position 2
  (let ((vec1 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(3.0 5.0 7.0 11.0 13.0)))
        (vec2 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(4.0 9.0 16.0 25.0 36.0))))
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 2) (linear-algebra:vref vec2 2))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:napply-rotation vec1 vec2 cc ss)
        (assert-eq vec1 rvec1)
        (assert-eq vec2 rvec2)
        (assert-float-equal rr (linear-algebra:vref vec1 2))
        (assert-float-equal
         #(4.867086 10.249511 17.46425 27.312943 38.19231) vec1)
        (assert-float-equal
         #(-1.1451968 -0.97341704 0.0 -0.05725956 2.519433) vec2))))
  ;; Float, position 3
  (let ((vec1 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(3.0 5.0 7.0 11.0 13.0)))
        (vec2 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(4.0 9.0 16.0 25.0 36.0))))
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 3) (linear-algebra:vref vec2 3))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:napply-rotation vec1 vec2 cc ss)
        (assert-eq vec1 rvec1)
        (assert-eq vec2 rvec2)
        (assert-float-equal rr (linear-algebra:vref vec1 3))
        (assert-float-equal
         #(4.8694763 10.251528 17.46421 27.313 38.186943) vec1)
        (assert-float-equal
         #(-1.1349905 -0.95192766 0.036612988 9.536743e-7 2.599495) vec2))))
  ;; Float, position 4
  (let ((vec1 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(3.0 5.0 7.0 11.0 13.0)))
        (vec2 (linear-algebra:make-vector
               5 :element-type 'single-float
               :initial-contents #(4.0 9.0 16.0 25.0 36.0))))
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 4) (linear-algebra:vref vec2 4))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:napply-rotation vec1 vec2 cc ss)
        (assert-eq vec1 rvec1)
        (assert-eq vec2 rvec2)
        (assert-float-equal rr (linear-algebra:vref vec1 4))
        (assert-float-equal
         #(4.781149 10.163207 17.426374 27.249937 38.27532) vec1)
        (assert-float-equal
         #(-1.4630839 -1.6459692 -1.1495662 -1.8549814 0.0) vec2))))
  ;; Complex, position 0
  (let ((vec1 (linear-algebra:make-vector
               2 :element-type '(complex single-float)
               :initial-contents #(#C(3.0 5.0) #C(7.0 11.0))))
        (vec2 (linear-algebra:make-vector
               2 :element-type '(complex single-float)
               :initial-contents #(#C(4.0 9.0) #C(16.0 25.0)))))
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 0) (linear-algebra:vref vec2 0))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:napply-rotation vec1 vec2 cc ss)
        (assert-eq vec1 rvec1)
        (assert-eq vec2 rvec2)
        (assert-float-equal rr (linear-algebra:vref vec1 0))
        (assert-float-equal
         #(#C(5.888673 9.814455) #C(19.85367 25.27784)) vec1)
        (assert-float-equal
         #(#C(-4.7683716e-7 -4.7683716e-7) #C(3.326425 2.6071978)) vec2))))
  ;; Complex, position 1
  (let ((vec1 (linear-algebra:make-vector
               2 :element-type '(complex single-float)
               :initial-contents #(#C(3.0 5.0) #C(7.0 11.0))))
        (vec2 (linear-algebra:make-vector
               2 :element-type '(complex single-float)
               :initial-contents #(#C(4.0 9.0) #C(16.0 25.0)))))
    (multiple-value-bind (cc ss rr)
	(linear-algebra:givens-rotation
	 (linear-algebra:vref vec1 1) (linear-algebra:vref vec2 1))
      (multiple-value-bind (rvec1 rvec2)
	  (linear-algebra:napply-rotation vec1 vec2 cc ss)
        (assert-eq vec1 rvec1)
        (assert-eq vec2 rvec2)
        ;; FIXME : Why is this error so large?
	(let ((*epsilon* (* 32 single-float-epsilon)))
	  (assert-float-equal rr (linear-algebra:vref vec1 1)))
        (assert-float-equal
         #(#C(4.8474817 10.2603855) #C(17.405037 27.350775)) vec1)
        (assert-float-equal
         #(#C(-1.1497688 -0.9510431) #C(0.0 0.0)) vec2)))))

@

\section{Test Scaled Sums of Data Vectors}
\label{sec:test-scaled-data-vector-sums}

The scaled sum of the squares of a vector is tested for both real and
complex values. Edge cases need to be identified and added to this
unit test.
<<Test: Scaled sum of squares for data vectors>>=
(define-test data-vector-sumsq
  ;; Real
  (let ((col-data (linear-algebra:column-vector
		   -6 -5 -4 -3 -2 -1 0 1 2 3 4 5))
	(row-data (linear-algebra:row-vector
		   -6 -5 -4 -3 -2 -1 0 1 2 3 4 5)))
    (multiple-value-bind (scale sumsq)
	(linear-algebra:sumsq col-data)
      (assert-rational-equal 6 scale)
      (assert-rational-equal 73/18 sumsq))
    (multiple-value-bind (scale sumsq)
	(linear-algebra:sumsq row-data)
      (assert-rational-equal 6 scale)
      (assert-rational-equal 73/18 sumsq)))
  ;; Complex
  (let ((col-data (linear-algebra:column-vector
		   #C(1 0) #C(3 1) #C(2 3) #C(0 4)
		   #C(-2 3) #C(-3 1) #C(-1 0)))
	(row-data (linear-algebra:row-vector
		   #C(1 0) #C(3 1) #C(2 3) #C(0 4)
		   #C(-2 3) #C(-3 1) #C(-1 0))))
    (multiple-value-bind (scale sumsq)
	(linear-algebra:sumsq col-data)
      (assert-float-equal 4.0 scale)
      (assert-float-equal #C (2.75 -1.125) sumsq))
    (multiple-value-bind (scale sumsq)
	(linear-algebra:sumsq row-data)
      (assert-float-equal 4.0 scale)
      (assert-float-equal #C(2.75 -1.125) sumsq))))

@ The scaled sum of the powers of p of a vector is a generalization of
[[sumsq]]. As in the case of [[sumsq]], edge cases need to be
identified and added to this unit test.
<<Test: Scaled sum of the powers of p for data vectors>>=
(define-test data-vector-sump
  ;; Real
  (let ((col-data (linear-algebra:column-vector
		   -6 -5 -4 -3 -2 -1 0 1 2 3 4 5))
        (row-data (linear-algebra:row-vector
		   -6 -5 -4 -3 -2 -1 0 1 2 3 4 5)))
    (multiple-value-bind (scale sump)
	(linear-algebra:sump col-data 2)
      (assert-rational-equal 6 scale)
      (assert-rational-equal 73/18 sump))
    (multiple-value-bind (scale sump)
	(linear-algebra:sump row-data 2)
      (assert-rational-equal 6 scale)
      (assert-rational-equal 73/18 sump))
    (multiple-value-bind (scale sump)
	(linear-algebra:sump col-data 3)
      (assert-rational-equal 6 scale)
      (assert-rational-equal 1 sump))
    (multiple-value-bind (scale sump)
	(linear-algebra:sump row-data 3)
      (assert-rational-equal 6 scale)
      (assert-rational-equal 1 sump)))
  ;; Complex
  (let ((col-data (linear-algebra:column-vector
		   #C(1 0) #C(3 1) #C(2 3) #C(0 4)
		   #C(-2 3) #C(-3 1) #C(-1 0)))
	(row-data (linear-algebra:row-vector
		   #C(1 0) #C(3 1) #C(2 3) #C(0 4)
		   #C(-2 3) #C(-3 1) #C(-1 0))))
    (multiple-value-bind (scale sump)
	(linear-algebra:sump col-data 2)
      (assert-float-equal 4.0 scale)
      (assert-float-equal #C(2.75 -1.125) sump))
    (multiple-value-bind (scale sump)
	(linear-algebra:sump row-data 2)
      (assert-float-equal 4.0 scale)
      (assert-float-equal #C(2.75 -1.125) sump))
    (multiple-value-bind (scale sump)
	(linear-algebra:sump col-data 3)
      (assert-float-equal 4.0 scale)
      (assert-float-equal #C(2.6639833 0.54687494) sump))
    (multiple-value-bind (scale sump)
	(linear-algebra:sump row-data 3)
      (assert-float-equal 4.0 scale)
      (assert-float-equal #C(2.6639833 0.54687494) sump))))

@ 

\section{Vector Norm}
\label{sec:vector-norm}

The vector norm function dispatches the input to the appropriate
specialized function. Appropriate values for the optional parameter p
are an integer and the keyword [[:infinity]].
<<Test: Data vector norm>>=
;;; Data vector norm
(define-test data-vector-norm
  (let ((data (linear-algebra:column-vector
	       -6 -5 -4 -3 -2 -1 0 1 2 3 4 5))
        (zdata (linear-algebra:column-vector
		#C(1 0) #C(3 1) #C(2 3) #C(0 4)
		#C(-2 3) #C(-3 1) #C(-1 0))))
    (assert-rational-equal
     36 (linear-algebra:norm data))
    (assert-float-equal
     19.535658 (linear-algebra:norm zdata))
    (assert-float-equal
     12.083046 (linear-algebra:norm data :measure 2))
    (assert-float-equal
     8.0 (linear-algebra:norm zdata :measure 2))
    (assert-float-equal
     8.732892 (linear-algebra:norm data :measure 3))
    (assert-float-equal
     6.064035 (linear-algebra:norm zdata :measure 3))
    (assert-rational-equal
     6 (linear-algebra:norm data :measure :infinity))
    (assert-float-equal
     4.0 (linear-algebra:norm zdata :measure :infinity))))

@ The Taxicab norm is tested directly.
<<Test: Data vector Taxicab norm>>=
;;; Taxicab norm
(define-test %data-vector-1-norm
  (assert-rational-equal
   36 (linear-algebra::%data-vector-1-norm
       (linear-algebra:column-vector
	-6 -5 -4 -3 -2 -1 0 1 2 3 4 5)))
  (assert-float-equal
   19.535658
   (linear-algebra::%data-vector-1-norm
    (linear-algebra:column-vector
     #C(1 0) #C(3 1) #C(2 3) #C(0 4)
     #C(-2 3) #C(-3 1) #C(-1 0)))))

@ The Euclidean norm function is tested directly.
<<Test: Data vector Euclidean norm>>=
;;; Euclidean norm
(define-test %data-vector-2-norm
  (assert-float-equal
   12.083046
   (linear-algebra::%data-vector-2-norm
    (linear-algebra:column-vector
     -6 -5 -4 -3 -2 -1 0 1 2 3 4 5)))
  (assert-float-equal
   8.0
   (linear-algebra::%data-vector-2-norm
    (linear-algebra:column-vector
     #C(1 0) #C(3 1) #C(2 3) #C(0 4)
     #C(-2 3) #C(-3 1) #C(-1 0)))))

@ The P-norm function is tested directly.
<<Test: Data vector P-norm>>=
;;; P-norm
(define-test %data-vector-p-norm
  (let ((data (linear-algebra:column-vector
	       -6 -5 -4 -3 -2 -1 0 1 2 3 4 5))
        (zdata (linear-algebra:column-vector
		#C(1 0) #C(3 1) #C(2 3) #C(0 4)
		#C(-2 3) #C(-3 1) #C(-1 0))))
    (assert-rational-equal
     36 (linear-algebra::%data-vector-p-norm data 1))
    (assert-float-equal
     19.535656 (linear-algebra::%data-vector-p-norm zdata 1))
    (assert-float-equal
     12.083046 (linear-algebra::%data-vector-p-norm data 2))
    (assert-float-equal
     8.0 (linear-algebra::%data-vector-p-norm zdata 2))
    (assert-float-equal
     8.732892 (linear-algebra::%data-vector-p-norm data 3))
    (assert-float-equal
     6.064035 (linear-algebra::%data-vector-p-norm zdata 3))))

@ Finally, the infinity norm is tested.
<<Test: Data vector Infinity norm>>=
;;; Data vector Infinity norm
(define-test %data-vector-infinity-norm
  (assert-rational-equal
   6 (linear-algebra::%data-vector-infinity-norm
      (linear-algebra:column-vector
       -6 -5 -4 -3 -2 -1 0 1 2 3 4 5)))
  (assert-float-equal
   4.0 (linear-algebra::%data-vector-infinity-norm
	(linear-algebra:column-vector
	 #C(1 0) #C(3 1) #C(2 3) #C(0 4)
	 #C(-2 3) #C(-3 1) #C(-1 0)))))

@

\section{Test Data Vector Transpose}
\label{sec:data-vector-transpose}

The transpose of a column vector is a row vector. Conversely, the
transpose of a row vector is a column vector.
<<Test: Data vector transpose>>=
;;; Data vector transpose
(define-test data-vector-transpose
  (let ((col-data (linear-algebra:column-vector
		   1.0 2.0 3.0 4.0 5.0))
	(row-data (linear-algebra:row-vector
		   1.0 2.0 3.0 4.0 5.0)))
    (assert-true
     (typep (linear-algebra:transpose col-data)
	    'linear-algebra:row-vector))
    (assert-true
     (typep (linear-algebra:transpose row-data)
	    'linear-algebra:column-vector))
    (assert-float-equal
     col-data (linear-algebra:transpose col-data))
    (assert-float-equal
     row-data (linear-algebra:transpose row-data))))

@ Data vectors can be destructively transposed using [[change-class]].
<<Test: Destructive data vector transpose>>=
(define-test data-vector-ntranspose
  (let ((col-data (linear-algebra:column-vector
                   1.0 2.0 3.0 4.0 5.0))
        (row-data (linear-algebra:row-vector
                   1.0 2.0 3.0 4.0 5.0)))
    (assert-true
     (typep (linear-algebra:ntranspose col-data)
            'linear-algebra:row-vector))
    (assert-true
     (typep col-data 'linear-algebra:row-vector))
    (assert-float-equal
     #(1.0 2.0 3.0 4.0 5.0)
     (linear-algebra:transpose col-data))
    (assert-true
     (typep (linear-algebra:ntranspose row-data)
            'linear-algebra:column-vector))
    (assert-true
     (typep row-data 'linear-algebra:column-vector))
    (assert-float-equal
     #(1.0 2.0 3.0 4.0 5.0)
     (linear-algebra:transpose row-data))))

@ 

\section{Test Data Vector Permutation}
\label{sec:test-data-vector-permutation}

The same permutation matrix is used to test permutation of both the
row and column vectors.
<<Test: Data vector permutation>>=
;;; Data vector permutation
(define-test data-vector-permute
  (let ((rvec (linear-algebra:row-vector
               1.1 2.2 3.3 4.4 5.5))
        (cvec (linear-algebra:column-vector
               1.1 2.2 3.3 4.4 5.5))
        (rerr (linear-algebra:row-vector
               1.1 2.2 3.3 4.4 5.5 6.6))
        (cerr (linear-algebra:column-vector
               1.1 2.2 3.3 4.4 5.5 6.6))
        (pmat (linear-algebra:make-matrix
               5 5 :matrix-type
               'linear-algebra:permutation-matrix
               :initial-contents
               '((0 0 1 0 0)
                 (0 0 0 0 1)
                 (1 0 0 0 0)
                 (0 1 0 0 0)
                 (0 0 0 1 0)))))
    (assert-float-equal
     #(3.3 4.4 1.1 5.5 2.2)
     (linear-algebra:permute rvec pmat))
    (assert-float-equal
     #(3.3 5.5 1.1 2.2 4.4)
     (linear-algebra:permute pmat cvec))
    (assert-error
     'error (linear-algebra:permute rerr pmat))
    (assert-error
     'error (linear-algebra:permute pmat cerr))))

@ Two additional tests are performed for the destructive permutation
of a data vector to verify that the data vector object has been
modified.
<<Test: Destructive data vector permutation>>=
(define-test data-vector-npermute
  (let ((rvec (linear-algebra:row-vector
               1.1 2.2 3.3 4.4 5.5))
        (cvec (linear-algebra:column-vector
               1.1 2.2 3.3 4.4 5.5))
        (rerr (linear-algebra:row-vector
               1.1 2.2 3.3 4.4 5.5 6.6))
        (cerr (linear-algebra:column-vector
               1.1 2.2 3.3 4.4 5.5 6.6))
        (pmat (linear-algebra:make-matrix
               5 5 :matrix-type
               'linear-algebra:permutation-matrix
               :initial-contents
               '((0 0 0 0 1)
                 (0 0 1 0 0)
                 (1 0 0 0 0)
                 (0 1 0 0 0)
                 (0 0 0 1 0)))))
    (assert-eq rvec (linear-algebra:npermute rvec pmat))
    (assert-float-equal #(3.3 4.4 2.2 5.5 1.1) rvec)
    (assert-eq cvec (linear-algebra:npermute pmat cvec))
    (assert-float-equal #(5.5 3.3 1.1 2.2 4.4) cvec)
    (assert-error
     'error (linear-algebra:npermute rerr pmat))
    (assert-error
     'error (linear-algebra:npermute pmat cerr))))

@

\section{Test Data Vector Scale}
\label{sec:test-data-vector-scale}

The first vector scaling function, [[scale]], returns an new vector.
<<Test: Data vector scale>>=
;;; Data vector scale
(define-test data-vector-scale
  (assert-float-equal
   #(2.0 4.0 6.0 8.0 10.0)
   (linear-algebra:scale
    2.0 (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)))
  (assert-float-equal
   #(#C(1.0 1.0) #C(2.0 2.0) #C(3.0 3.0) #C(4.0 4.0) #C(5.0 5.0))
   (linear-algebra:scale
    #C(1.0 1.0) (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)))
  (assert-float-equal
   #(#C(2.0 2.0) #C(4.0 4.0) #C(6.0 6.0) #C(8.0 8.0) #C(10.0 10.0))
   (linear-algebra:scale
    2.0 (linear-algebra:column-vector
	 #C(1.0 1.0) #C(2.0 2.0) #C(3.0 3.0) #C(4.0 4.0) #C(5.0 5.0))))
  (assert-float-equal
   #(#C(0.0 4.0) #C(0.0 8.0) #C(0.0 12.0) #C(0.0 16.0) #C(0.0 20.0))
   (linear-algebra:scale
    #C(2.0 2.0)
    (linear-algebra:column-vector
     #C(1.0 1.0) #C(2.0 2.0) #C(3.0 3.0) #C(4.0 4.0) #C(5.0 5.0)))))

@ The second version destructively modifies the vector.
<<Test: Destructive data vector scale>>=
(define-test data-vector-nscale
  (assert-float-equal
   #(2.0 4.0 6.0 8.0 10.0)
   (linear-algebra:nscale
    2.0 (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)))
  (assert-float-equal
   #(#C(1.0 1.0) #C(2.0 2.0) #C(3.0 3.0) #C(4.0 4.0) #C(5.0 5.0))
   (linear-algebra:nscale
    #C(1.0 1.0) (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)))
  (assert-float-equal
   #(#C(2.0 2.0) #C(4.0 4.0) #C(6.0 6.0) #C(8.0 8.0) #C(10.0 10.0))
   (linear-algebra:nscale
    2.0 (linear-algebra:column-vector
	 #C(1.0 1.0) #C(2.0 2.0) #C(3.0 3.0) #C(4.0 4.0) #C(5.0 5.0))))
  (assert-float-equal
   #(#C(0.0 4.0) #C(0.0 8.0) #C(0.0 12.0) #C(0.0 16.0) #C(0.0 20.0))
   (linear-algebra:nscale
    #C(2.0 2.0)
    (linear-algebra:column-vector
     #C(1.0 1.0) #C(2.0 2.0) #C(3.0 3.0) #C(4.0 4.0) #C(5.0 5.0)))))

@ 

\section{Test Data Vector Addition}
\label{sec:test-data-vector-addition}

Vector addition is a binary operation with keyword scaling values for
each vector.
<<Test: Data vector addition>>=
;;; Vector addition
(define-test add-data-vector
  ;; Real
  (let ((vec1 (linear-algebra:column-vector 1.1 2.2 3.3 4.4))
	(vec2 (linear-algebra:column-vector 1.1 2.2 3.3 4.4)))
    (assert-float-equal
     #(2.2 4.4 6.6 8.8)
     (linear-algebra:add vec1 vec2))
    (assert-float-equal
     #(3.3 6.6 9.9 13.2)
     (linear-algebra:add vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(3.3 6.6 9.9 13.2)
     (linear-algebra:add vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(4.4 8.8 13.2 17.6)
     (linear-algebra:add vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  (let ((vec1 (linear-algebra:row-vector 1.1 2.2 3.3 4.4))
	(vec2 (linear-algebra:row-vector 1.1 2.2 3.3 4.4)))
    (assert-float-equal
     #(2.2 4.4 6.6 8.8)
     (linear-algebra:add vec1 vec2))
    (assert-float-equal
     #(3.3 6.6 9.9 13.2)
     (linear-algebra:add vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(3.3 6.6 9.9 13.2)
     (linear-algebra:add vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(4.4 8.8 13.2 17.6)
     (linear-algebra:add vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  ;; Complex
  (let ((vec1 (linear-algebra:column-vector #C(1.1 2.2) #C(3.3 4.4)))
	(vec2 (linear-algebra:column-vector #C(1.1 2.2) #C(3.3 4.4))))
    (assert-float-equal
     #(#C(2.2 4.4) #C(6.6 8.8))
     (linear-algebra:add vec1 vec2))
    (assert-float-equal
     #(#C(3.3 6.6) #C(9.9 13.2))
     (linear-algebra:add vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(#C(3.3 6.6) #C(9.9 13.2))
     (linear-algebra:add vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(#C(4.4 8.8) #C(13.2 17.6))
     (linear-algebra:add vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  (let ((vec1 (linear-algebra:row-vector #C(1.1 2.2) #C(3.3 4.4)))
	(vec2 (linear-algebra:row-vector #C(1.1 2.2) #C(3.3 4.4))))
    (assert-float-equal
     #(#C(2.2 4.4) #C(6.6 8.8))
     (linear-algebra:add vec1 vec2))
    (assert-float-equal
     #(#C(3.3 6.6) #C(9.9 13.2))
     (linear-algebra:add vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(#C(3.3 6.6) #C(9.9 13.2))
     (linear-algebra:add vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(#C(4.4 8.8) #C(13.2 17.6))
     (linear-algebra:add vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  ;; Errors
  (assert-error
   'error
   (linear-algebra:add
    (linear-algebra:column-vector 1.1 2.2 3.3 4.4)
    (linear-algebra:row-vector 1.1 2.2 3.3 4.4)))
  (assert-error
   'error
   (linear-algebra:add
    (linear-algebra:row-vector 1.1 2.2 3.3 4.4)
    (linear-algebra:column-vector 1.1 2.2 3.3 4.4))))

@ The function [[nadd]] add 2 vectors returning the result in the
first vector.
<<Test: Destructive data vector addition>>=
;;; Destructive vector addition
(define-test nadd-data-vector
  ;; Real
  (let ((vec1 (linear-algebra:column-vector 1.1 2.2 3.3 4.4))
	(vec2 (linear-algebra:column-vector 1.1 2.2 3.3 4.4)))
    (assert-eq vec1 (linear-algebra:nadd vec1 vec2))
    (assert-float-equal
     #(2.2 4.4 6.6 8.8) vec1)
    (assert-float-equal
     #(4.4 8.8 13.2 17.6)
     (linear-algebra:nadd vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(9.9 19.8 29.7 39.6)
     (linear-algebra:nadd vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(22.0 44.0 66.0 88.0)
     (linear-algebra:nadd vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  (let ((vec1 (linear-algebra:row-vector 1.1 2.2 3.3 4.4))
	(vec2 (linear-algebra:row-vector 1.1 2.2 3.3 4.4)))
    (assert-eq vec1 (linear-algebra:nadd vec1 vec2))
    (assert-float-equal
     #(2.2 4.4 6.6 8.8) vec1)
    (assert-float-equal
     #(4.4 8.8 13.2 17.6)
     (linear-algebra:nadd vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(9.9 19.8 29.7 39.6)
     (linear-algebra:nadd vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(22.0 44.0 66.0 88.0)
     (linear-algebra:nadd vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  ;; Complex
  (let ((vec1 (linear-algebra:column-vector #C(1.1 2.2) #C(3.3 4.4)))
	(vec2 (linear-algebra:column-vector #C(1.1 2.2) #C(3.3 4.4))))
    (assert-eq vec1 (linear-algebra:nadd vec1 vec2))
    (assert-float-equal
     #(#C(2.2 4.4) #C(6.6 8.8)) vec1)
    (assert-float-equal
     #(#C(4.4 8.8) #C(13.2 17.6))
     (linear-algebra:nadd vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(#C(9.9 19.8) #C(29.7 39.6))
     (linear-algebra:nadd vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(#C(22.0 44.0) #C(66.0 88.0))
     (linear-algebra:nadd vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  (let ((vec1 (linear-algebra:row-vector #C(1.1 2.2) #C(3.3 4.4)))
	(vec2 (linear-algebra:row-vector #C(1.1 2.2) #C(3.3 4.4))))
    (assert-eq vec1 (linear-algebra:nadd vec1 vec2))
    (assert-float-equal
     #(#C(2.2 4.4) #C(6.6 8.8)) vec1)
    (assert-float-equal
     #(#C(4.4 8.8) #C(13.2 17.6))
     (linear-algebra:nadd vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(#C(9.9 19.8) #C(29.7 39.6))
     (linear-algebra:nadd vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(#C(22.0 44.0) #C(66.0 88.0))
     (linear-algebra:nadd vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  ;; Errors
  (assert-error
   'error
   (linear-algebra:nadd
    (linear-algebra:column-vector 1.1 2.2 3.3 4.4)
    (linear-algebra:row-vector 1.1 2.2 3.3 4.4)))
  (assert-error
   'error
   (linear-algebra:nadd
    (linear-algebra:row-vector 1.1 2.2 3.3 4.4)
    (linear-algebra:column-vector 1.1 2.2 3.3 4.4))))

@

\section{Test Data Vector Subtraction}
\label{sec:test-data-vector-subtraction}

Vector subtraction is a binary operation with keyword scaling values
for each vector.
<<Test: Data vector subtraction>>=
;;; Vector subtraction
(define-test subtract-data-vector
  ;; Real
  (let ((vec1 (linear-algebra:column-vector 1.1 2.2 3.3 4.4))
	(vec2 (linear-algebra:column-vector 1.1 2.2 3.3 4.4)))
    (assert-float-equal
     #(0.0 0.0 0.0 0.0)
     (linear-algebra:subtract vec1 vec2))
    (assert-float-equal
     #(1.1 2.2 3.3 4.4)
     (linear-algebra:subtract vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(-1.1 -2.2 -3.3 -4.4)
     (linear-algebra:subtract vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(0.0 0.0 0.0 0.0)
     (linear-algebra:subtract vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  (let ((vec1 (linear-algebra:row-vector 1.1 2.2 3.3 4.4))
	(vec2 (linear-algebra:row-vector 1.1 2.2 3.3 4.4)))
    (assert-float-equal
     #(0.0 0.0 0.0 0.0)
     (linear-algebra:subtract vec1 vec2))
    (assert-float-equal
     #(1.1 2.2 3.3 4.4)
     (linear-algebra:subtract vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(-1.1 -2.2 -3.3 -4.4)
     (linear-algebra:subtract vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(0.0 0.0 0.0 0.0)
     (linear-algebra:subtract vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  ;; Complex
  (let ((vec1 (linear-algebra:column-vector #C(1.1 2.2) #C(3.3 4.4)))
	(vec2 (linear-algebra:column-vector #C(1.1 2.2) #C(3.3 4.4))))
    (assert-float-equal
     #(#C(0.0 0.0) #C(0.0 0.0))
     (linear-algebra:subtract vec1 vec2))
    (assert-float-equal
     #(#C(1.1 2.2) #C(3.3 4.4))
     (linear-algebra:subtract vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(#C(-1.1 -2.2) #C(-3.3 -4.4))
     (linear-algebra:subtract vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(#C(0.0 0.0) #C(0.0 0.0))
     (linear-algebra:subtract vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  (let ((vec1 (linear-algebra:row-vector #C(1.1 2.2) #C(3.3 4.4)))
	(vec2 (linear-algebra:row-vector #C(1.1 2.2) #C(3.3 4.4))))
    (assert-float-equal
     #(#C(0.0 0.0) #C(0.0 0.0))
     (linear-algebra:subtract vec1 vec2))
    (assert-float-equal
     #(#C(1.1 2.2) #C(3.3 4.4))
     (linear-algebra:subtract vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(#C(-1.1 -2.2) #C(-3.3 -4.4))
     (linear-algebra:subtract vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(#C(0.0 0.0) #C(0.0 0.0))
     (linear-algebra:subtract vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  ;; Errors
  (assert-error
   'error
   (linear-algebra:subtract
    (linear-algebra:column-vector 1.1 2.2 3.3 4.4)
    (linear-algebra:row-vector 1.1 2.2 3.3 4.4)))
  (assert-error
   'error
   (linear-algebra:subtract
    (linear-algebra:row-vector 1.1 2.2 3.3 4.4)
    (linear-algebra:column-vector 1.1 2.2 3.3 4.4))))

@ The function [[nsubtract]] subtracts 2 vectors returning the result
in the first vector.
<<Test: Destructive data vector subtraction>>=
;;; Destructive vector subtraction
(define-test nsubtract-data-vector
  ;; Real
  (let ((vec1 (linear-algebra:column-vector 1.1 2.2 3.3 4.4))
	(vec2 (linear-algebra:column-vector 1.1 2.2 3.3 4.4)))
    (assert-eq vec1 (linear-algebra:nsubtract vec1 vec2))
    (assert-float-equal
     #(0.0 0.0 0.0 0.0) vec1)
    (assert-float-equal
     #(-2.2 -4.4 -6.6 -8.8)
     (linear-algebra:nsubtract vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(-5.5 -11.0 -16.5 -22.0)
     (linear-algebra:nsubtract vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(-13.2 -26.4 -39.6 -52.8)
     (linear-algebra:nsubtract vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  (let ((vec1 (linear-algebra:row-vector 1.1 2.2 3.3 4.4))
	(vec2 (linear-algebra:row-vector 1.1 2.2 3.3 4.4)))
    (assert-eq vec1 (linear-algebra:nsubtract vec1 vec2))
    (assert-float-equal
     #(0.0 0.0 0.0 0.0) vec1)
    (assert-float-equal
     #(-2.2 -4.4 -6.6 -8.8)
     (linear-algebra:nsubtract vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(-5.5 -11.0 -16.5 -22.0)
     (linear-algebra:nsubtract vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(-13.2 -26.4 -39.6 -52.8)
     (linear-algebra:nsubtract vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  ;; Complex
  (let ((vec1 (linear-algebra:column-vector #C(1.1 2.2) #C(3.3 4.4)))
	(vec2 (linear-algebra:column-vector #C(1.1 2.2) #C(3.3 4.4))))
    (assert-eq vec1 (linear-algebra:nsubtract vec1 vec2))
    (assert-float-equal
     #(#C(0.0 0.0) #C(0.0 0.0)) vec1)
    (assert-float-equal
     #(#C(-2.2 -4.4) #C(-6.6 -8.8))
     (linear-algebra:nsubtract vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(#C(-5.5 -11.0) #C(-16.5 -22.0))
     (linear-algebra:nsubtract vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(#C(-13.2 -26.4) #C(-39.6 -52.8))
     (linear-algebra:nsubtract vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  (let ((vec1 (linear-algebra:row-vector #C(1.1 2.2) #C(3.3 4.4)))
	(vec2 (linear-algebra:row-vector #C(1.1 2.2) #C(3.3 4.4))))
    (assert-eq vec1 (linear-algebra:nsubtract vec1 vec2))
    (assert-float-equal
     #(#C(0.0 0.0) #C(0.0 0.0)) vec1)
    (assert-float-equal
     #(#C(-2.2 -4.4) #C(-6.6 -8.8))
     (linear-algebra:nsubtract vec1 vec2 :scalar2 2.0))
    (assert-float-equal
     #(#C(-5.5 -11.0) #C(-16.5 -22.0))
     (linear-algebra:nsubtract vec1 vec2 :scalar1 2.0))
    (assert-float-equal
     #(#C(-13.2 -26.4) #C(-39.6 -52.8))
     (linear-algebra:nsubtract vec1 vec2 :scalar1 2.0 :scalar2 2.0)))
  ;; Errors
  (assert-error
   'error
   (linear-algebra:nsubtract
    (linear-algebra:column-vector 1.1 2.2 3.3 4.4)
    (linear-algebra:row-vector 1.1 2.2 3.3 4.4)))
  (assert-error
   'error
   (linear-algebra:nsubtract
    (linear-algebra:row-vector 1.1 2.2 3.3 4.4)
    (linear-algebra:column-vector 1.1 2.2 3.3 4.4))))

@

\section{Test Data Vector Dot Product}
\label{sec:test-data-vector-dot-product}

The dot product function is tested for real and complex vectors. With
complex vectors, the conjugate keyword is also tested. The only error
is generated when the vectors are unequal length.
<<Test: Data vector dot product>>=
;;; Vector data dot product
(define-test data-vector-dot-product
  ;; Real vectors
  (assert-rational-equal
   55 (linear-algebra:product
       (linear-algebra:row-vector 1 2 3 4 5)
       (linear-algebra:column-vector 1 2 3 4 5)))
  (assert-float-equal
   55.0 (linear-algebra:product
	 (linear-algebra:row-vector 1.0 2.0 3.0 4.0 5.0)
	 (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)))
  (assert-float-equal
   55.0d0 (linear-algebra:product
	   (linear-algebra:row-vector 1.0d0 2.0d0 3.0d0 4.0d0 5.0d0)
	   (linear-algebra:column-vector 1.0d0 2.0d0 3.0d0 4.0d0 5.0d0)))
  ;; Real vectors with conjugate keyword
  (assert-rational-equal
   55 (linear-algebra:product
       (linear-algebra:row-vector 1 2 3 4 5)
       (linear-algebra:column-vector 1 2 3 4 5)
       :conjugate t))
  ;; Complex vectors
  (assert-rational-equal
   #C(8 18) (linear-algebra:product
	     (linear-algebra:row-vector #C(1 1) #C(2 1) #C(3 1))
	     (linear-algebra:column-vector #C(1 2) #C(2 2) #C(3 2))))
  (assert-float-equal
   #C(8.0 18.0) (linear-algebra:product
		 (linear-algebra:row-vector #C(1.0 1.0) #C(2.0 1.0) #C(3.0 1.0))
		 (linear-algebra:column-vector #C(1.0 2.0) #C(2.0 2.0) #C(3.0 2.0))))
  (assert-float-equal
   #C(8.0d0 18.0d0)
   (linear-algebra:product
    (linear-algebra:row-vector #C(1.0d0 1.0d0) #C(2.0d0 1.0d0) #C(3.0d0 1.0d0))
    (linear-algebra:column-vector #C(1.0d0 2.0d0) #C(2.0d0 2.0d0) #C(3.0d0 2.0d0))))
  ;; Complex conjugate
  (assert-rational-equal
   #C(20 6)
   (linear-algebra:product
    (linear-algebra:row-vector #C(1 1) #C(2 1) #C(3 1))
    (linear-algebra:column-vector #C(1 2) #C(2 2) #C(3 2))
    :conjugate t))
  (assert-float-equal
   #C(20.0 6.0)
   (linear-algebra:product
    (linear-algebra:row-vector #C(1.0 1.0) #C(2.0 1.0) #C(3.0 1.0))
    (linear-algebra:column-vector #C(1.0 2.0) #C(2.0 2.0) #C(3.0 2.0))
    :conjugate t))
  (assert-float-equal
   #C(20.0d0 6.0d0)
   (linear-algebra:product
    (linear-algebra:row-vector #C(1.0d0 1.0d0) #C(2.0d0 1.0d0) #C(3.0d0 1.0d0))
    (linear-algebra:column-vector #C(1.0d0 2.0d0) #C(2.0d0 2.0d0) #C(3.0d0 2.0d0))
    :conjugate t))
  ;; Errors
  (assert-error 'error (linear-algebra:product
			(linear-algebra:row-vector 1 2 3)
			(linear-algebra:column-vector 1 2 3 4)))
  (assert-error 'error (linear-algebra:product
			(linear-algebra:column-vector 1 2 3)
			(linear-algebra:column-vector 1 2 3)))
  (assert-error 'error (linear-algebra:product
			(linear-algebra:row-vector 1 2 3)
			(linear-algebra:row-vector 1 2 3)))
  (assert-error 'error (linear-algebra:product
			(linear-algebra:column-vector 1 2 3)
			(linear-algebra:row-vector 1 2 3))))

@ 

\chapter{Matrix Tests}
\label{chap:matrix-tests}

Unit testing of matrix construction, data operations and fundamental
operations is defined in this defined in this chapter.

\section{Matrix Interface Tests}
\label{sec:matrix-interface-tests}

The matrix interface is primarily composed of generic functions that
do not directly require testing. For generic functions that have
identical behavior regardless of the class, though, macros are
provided to generate the appropriate tests for implementations of the
function. The only direct test is for the matrix object predicate.
<<matrix.lisp>>=
<<In linear algebra unit tests>>
;;; Matrix object predicate
(define-test matrixp
  (assert-true (linear-algebra:matrixp
		(make-instance 'linear-algebra:matrix-object)))
  (assert-false (linear-algebra:matrixp t)))

<<Macro: Generate tests for MATRIX-IN-BOUNDS-P>>
<<Macro: Generate tests for MATRIX-ELEMENT-TYPE>>
<<Macro: Generate tests for MATRIX-DIMENSIONS>>
<<Macro: Generate tests for MATRIX-ROW-DIMENSION>>
<<Macro: Generate tests for MATRIX-COLUMN-DIMENSION>>
<<Macro: Return a matrix modified with (SETF SUBMATRIX)>>
<<Macro: Generate tests for MATRIX-VALIDATED-RANGE>>
@ The matrix interface tests depend on the definition of the linear
algebra test package.
<<Matrix dependencies>>=
(:file "matrix"
       :depends-on ("defpackage"))
@

The first function that with class independent behavior is
[[matrix-in-bounds-p]]. Five simple tests are performed. The first
test verifies that given a valid, random, row and column, [[t]] is
returned. The remaining tests verify that false is returned for
negative indices and indices that exceed the bounds.
<<Macro: Generate tests for MATRIX-IN-BOUNDS-P>>=
;;; Matrix bounds
(defmacro test-matrix-in-bounds-p (matrix-type &optional
                                   (initial-contents nil initial-contents-p))
  (let ((mat (gensym "MATRIX-")))
    `(let ((,mat (linear-algebra:make-matrix
                  10 10 :matrix-type ,matrix-type
                  ,@(when initial-contents-p
                          `(:initial-contents ,initial-contents)))))
      (assert-true
       (linear-algebra:matrix-in-bounds-p
        ,mat (random 10) (random 10)))
      (assert-false
       (linear-algebra:matrix-in-bounds-p ,mat -1 0))
      (assert-false
       (linear-algebra:matrix-in-bounds-p ,mat 0 -1))
      (assert-false
       (linear-algebra:matrix-in-bounds-p ,mat 10 0))
      (assert-false
       (linear-algebra:matrix-in-bounds-p ,mat 0 10)))))

@ The [[matrix-element-type]] is tested by comparing the type returned
with that returned from [[array-element-type]]. The type that an array
can be specialized with is implementation dependent. Currently, the
element type of a matrix cannot be more specific than that of an
array. Fourteen tests are generated, seven for real element types and
seven for the corresponding complex element types.
<<Macro: Generate tests for MATRIX-ELEMENT-TYPE>>=
;;; Matrix element type
(defmacro test-matrix-element-type (matrix-type &optional
                                    (test-real-p t) (test-complex-p t))
  (let ((numeric-types (gensym "NUMERIC-TYPES-"))
        (mtype (gensym "MTYPE-"))
        (ntype (gensym "NTYPE-")))
    `(let ((,mtype ,matrix-type)
           (,numeric-types
            '(integer fixnum bit
              short-float single-float double-float long-float)))
      (dolist (,ntype ,numeric-types)
        ;; Real
        ,(when
          test-real-p
          `(assert-true
            (subtypep
             (linear-algebra:matrix-element-type
              (linear-algebra:make-matrix
               2 2 :matrix-type ,mtype :element-type ,ntype))
             (array-element-type
              (make-array '(2 2) :element-type ,ntype)))))
        ;; Complex
        ,(when
          test-complex-p
          `(assert-true
            (subtypep
             (linear-algebra:matrix-element-type
              (linear-algebra:make-matrix
               2 2 :matrix-type ,mtype :element-type `(complex ,,ntype)))
             (array-element-type
              (make-array '(2 2) :element-type `(complex ,,ntype))))))))))

@ A single test is generated for [[matrix-dimensions]] that verifies
the return values is the list of dimensions.
<<Macro: Generate tests for MATRIX-DIMENSIONS>>=
;;; Matrix dimensions
(defmacro test-matrix-dimensions (matrix-type rows columns)
  `(assert-equal
    (list ,rows ,columns)
    (linear-algebra:matrix-dimensions
     (linear-algebra:make-matrix
      ,rows ,columns :matrix-type ,matrix-type))))

@ Similarly, a single test is generated for [[matrix-row-dimension]]
that verifies the return values equals the rows.
<<Macro: Generate tests for MATRIX-ROW-DIMENSION>>=
;;; Matrix row dimension
(defmacro test-matrix-row-dimension (matrix-type rows columns)
  `(assert-eq ,rows
    (linear-algebra:matrix-row-dimension
     (linear-algebra:make-matrix
      ,rows ,columns :matrix-type ,matrix-type))))

@ Finally, a single test is also generated for
[[matrix-column-dimension]].
<<Macro: Generate tests for MATRIX-COLUMN-DIMENSION>>=
;;; Matrix column dimension
(defmacro test-matrix-column-dimension (matrix-type rows columns)
  `(assert-eq ,columns
    (linear-algebra:matrix-column-dimension
     (linear-algebra:make-matrix
      ,rows ,columns :matrix-type ,matrix-type))))

@ The [[(setf submatrix)]] function returns the data, not the modified
matrix. The testing, though, needs to verify that the modified matrix.
A convenience macro, therefore, is used to set the submatrix and
return the modified matrix.
<<Macro: Return a matrix modified with (SETF SUBMATRIX)>>=
;;; Return a matrix modified with (SETF SUBMATRIX)
(defmacro setf-submatrix (rows columns matrix-type submatrix-form data-form)
  "Return the matrix modified with (SETF SUBMATRIX)"
  (let ((matrix (second submatrix-form)))
    `(let ((,matrix (zero-matrix ,rows ,columns
                                 :matrix-type ,matrix-type)))
      (setf ,submatrix-form ,data-form)
      ,matrix)))

@ The tests of [[matrix-validated-range]] are identical regardless of
the type of the matrix. Therefore, a macro is used to generate those
tests for each type of matrix.
<<Macro: Generate tests for MATRIX-VALIDATED-RANGE>>=
;;; Matrix validated range
(defmacro test-matrix-validated-range (matrix-type rows columns)
  "Test that matrix-validate-range executes correctly."
  (let ((matrix  (gensym "MATRIX-"))
        (row1 (gensym "ROW1-"))
        (row2 (gensym "ROW2-"))
        (col1 (gensym "COL1-"))
        (col2 (gensym "COL2-")))
    `(let ((,matrix (linear-algebra:make-matrix
                     ,rows ,columns :matrix-type ,matrix-type))
           (,row1 (random ,rows))
           (,row2 (random ,rows))
           (,col1 (random ,columns))
           (,col2 (random ,columns)))
      (assert-equal
       (list ,row1 ,col1 ,rows ,columns)
       (linear-algebra:matrix-validated-range ,matrix ,row1 ,col1))
      (assert-equal
       (list (min ,row1 ,row2) ,col1 (max ,row1 ,row2) ,columns)
       (linear-algebra:matrix-validated-range
        ,matrix (min ,row1 ,row2) ,col1 (max ,row1 ,row2)))
      (assert-equal
       (list ,row1 (min ,col1 ,col2) ,rows (max ,col1 ,col2))
       (linear-algebra:matrix-validated-range
        ,matrix ,row1 (min ,col1 ,col2) nil (max ,col1 ,col2)))
      (assert-equal
       (list (min ,row1 ,row2) (min ,col1 ,col2)
             (max ,row1 ,row2) (max ,col1 ,col2))
       (linear-algebra:matrix-validated-range
        ,matrix
        (min ,row1 ,row2) (min ,col1 ,col2)
        (max ,row1 ,row2) (max ,col1 ,col2)))
      (assert-error
       'error
       (linear-algebra:matrix-validated-range ,matrix (1+ ,rows) ,col1))
      (assert-error
       'error
       (linear-algebra:matrix-validated-range ,matrix ,row1 (1+ ,columns)))
      (assert-error
       'error
       (linear-algebra:matrix-validated-range
        ,matrix (1- ,rows) ,col1 1))
      (assert-error
       'error
       (linear-algebra:matrix-validated-range
        ,matrix ,row1 (1- ,columns) ,rows 1))
      (assert-error
       'error
       (linear-algebra:matrix-validated-range
        ,matrix
        (1- ,rows) (1- ,columns) 1 1)))))

@

\section{Test the Identity Matrix}
\label{sec:test-identity-matrix}

<<identity-matrix.lisp>>=
<<In linear algebra unit tests>>
<<Test: Make an identity matrix>>
<<Test: Identity matrix predicate>>
<<Test: Identity matrix bounds predicate>>
<<Test: Identity matrix element type>>
<<Test: Identity matrix dimensions>>
<<Test: Identity matrix row dimension>>
<<Test: Identity matrix column dimension>>
<<Test: Identity matrix element reference>>
<<Test: Copy an identity matrix>>
<<Test: Subset of the identity matrix>>
<<Test: Destructively replace the subset of the identity matrix>>
<<Test: Identity matrix validated range>>
@ The identity matrix tests depend on the linear algebra test package
and the matrix test macros.
<<Identity matrix dependencies>>=
(:file "identity-matrix"
       :depends-on ("defpackage" "matrix"))
@

\subsection{Creating an Identity Matrix Tests}
\label{sec:creating-identity-matrix-tests}

For identity matrices, [[make-matrix]] is tested for default
initialization, specifying the element type and generating an error
when the initial element, initial contents or both are specified.
<<Test: Make an identity matrix>>=
(define-test make-identity-matrix
  <<Make an identity matrix>>
  <<Specify the identity matrix element type>>
  <<Identity matrix construction errors>>)

@ An identity matrix should generally be created without specifying
any options.
<<Make an identity matrix>>=
;; A default identity matrix
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:identity-matrix)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:identity-matrix))
  (assert-true (zerop (aref (linear-algebra::contents matrix) 0)))
  (assert-rational-equal 1 (aref (linear-algebra::contents matrix) 1)))
@ It can be useful to specify the element type.
<<Specify the identity matrix element type>>=
;; Specify the identity matrix element type
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:identity-matrix
               :element-type 'single-float)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:identity-matrix))
  (assert-eq (array-element-type
              (linear-algebra::contents matrix))
             (array-element-type
              (make-array '(10 10) :element-type 'single-float)))
  (assert-true (zerop (aref (linear-algebra::contents matrix) 0)))
  (assert-float-equal 1.0 (aref (linear-algebra::contents matrix) 1)))
@ Otherwise, everything else is an error.
<<Identity matrix construction errors>>=
;; Specify the identity matrix initial element
(assert-error
 'error
 (linear-algebra:make-matrix
  10 10
  :matrix-type 'linear-algebra:identity-matrix
  :initial-element 1.0))
;; Specify the identity matrix contents - Nested list
(assert-error
 'error
 (linear-algebra:make-matrix
  3 3
  :matrix-type 'linear-algebra:identity-matrix
  :initial-contents
  '((1.0 0.0 0.0)
    (0.0 1.0 0.0)
    (0.0 0.0 1.0))))
;; Specify the identity matrix contents - Nested vector
(assert-error
 'error
 (linear-algebra:make-matrix
  3 3
  :matrix-type 'linear-algebra:identity-matrix
  :initial-contents
  #(#(1.0 0.0 0.0)
    #(0.0 1.0 0.0)
    #(0.0 0.0 1.0))))
;; Specify the identity matrix contents - 2D array
(assert-error
 'error
 (linear-algebra:make-matrix
  3 3
  :matrix-type 'linear-algebra:identity-matrix
  :initial-contents
  #2A((1.0 0.0 0.0)
      (0.0 1.0 0.0)
      (0.0 0.0 1.0))))
;; Specify initial element and initial contents
(assert-error 'error
              (linear-algebra:make-matrix
               3 3 :initial-element 1.0
               :matrix-type
               'linear-algebra:identity-matrix
               :initial-contents
               '((1.0 0.0 0.0)
                 (0.0 1.0 0.0)
                 (0.0 0.0 1.0))))
@

\subsection{Test Identity Matrix Predicates}
\label{sec:test-identity-matrix-predicates}

The [[identity-matrix-P]] function should return true if passed an
identity matrix object.
<<Test: Identity matrix predicate>>=
;;; Test the identity matrix predicate
 (define-test identity-matrix-predicate
   (assert-true
    (linear-algebra:identity-matrix-p
     (linear-algebra:make-matrix
      10 10 :matrix-type 'linear-algebra:identity-matrix)))
   (assert-false
    (linear-algebra:identity-matrix-p (make-array '(10 10)))))

@ The other identity matrix predicate should return true for valid
indices.
<<Test: Identity matrix bounds predicate>>=
;;; Test the identity matrix bounds
(define-test identity-matrix-in-bounds-p
  (test-matrix-in-bounds-p 'linear-algebra:identity-matrix))

@

\subsection{Test Identity Matrix Inspection}
\label{sec:test-identity-matrix-inspection}

All identity matrix inpsection tests are generated from the matrix
test macros.
<<Test: Identity matrix element type>>=
;;; Test the identity matrix element type
(define-test identity-matrix-element-type
  (test-matrix-element-type 'linear-algebra:identity-matrix))

@ The matrix dimensions are tested using a 7x7 identity matrix.
<<Test: Identity matrix dimensions>>=
;;; Test the identity matrix dimensions
(define-test identity-matrix-dimensions
  (test-matrix-dimensions 'linear-algebra:identity-matrix 7 7))

@ The matrix row dimension is tested for a value of 7.
<<Test: Identity matrix row dimension>>=
;;; Test the identity matrix row dimension
(define-test identity-matrix-row-dimension
  (test-matrix-row-dimension 'linear-algebra:identity-matrix 7 7))

@ Finally, the matrix column dimension is tested for a value of 7.
<<Test: Identity matrix column dimension>>=
;;; Test the identity matrix column dimension
(define-test identity-matrix-column-dimension
  (test-matrix-column-dimension 'linear-algebra:identity-matrix 7 7))

@ 

\subsection{Test Referencing Identity Matrices}
\label{sec:test-referencing-identity-matrices}

The four corners of the identity matrix and a random interior point
are tested for equality.
<<Test: Identity matrix element reference>>=
;;; Reference identity matrix elements
(define-test identity-matrix-mref
  (let* ((rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random-interior-index columns)
                        (random-interior-index columns)))
                   ((/= i0 rowi) i0)))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:identity-matrix
                  :element-type
                  'single-float)))
    (assert-float-equal
     1.0 (linear-algebra:mref matrix 0 0))
    (assert-float-equal
     0.0 (linear-algebra:mref matrix 0 cend))
    (assert-float-equal
     0.0 (linear-algebra:mref matrix rend 0))
    (assert-float-equal
     1.0 (linear-algebra:mref matrix rend cend))
    (assert-float-equal
     1.0 (linear-algebra:mref matrix rowi rowi))
    (assert-float-equal
     1.0 (linear-algebra:mref matrix coli coli))
    (assert-float-equal
     0.0 (linear-algebra:mref matrix rowi coli))))

@ It is an error to set an element of an identity matrix.
<<Test: Identity matrix element reference>>=
;;; Set identity matrix elements
(define-test identity-matrix-setf-mref
  (assert-error
   'error
   (setf (linear-algebra:mref
          (linear-algebra:make-matrix
           10 10 :matrix-type
           'linear-algebra:identity-matrix)
          (random 10) (random 10))
         1.0)))

@

\subsection{Test Copying Identity Matrices}
\label{sec:test-copying-identity-matrices}

Three tests are performed on [[copy-matrix]] for identity matrices.
The first test verifies that the matrix returned is not [[EQ]] to the
original matrix. The second test verifies that the contents are not
[[EQ]]. Finally, the elements are tested for equality.
<<Test: Copy an identity matrix>>=
;;; Copy the identity matrix
(define-test copy-identity-matrix
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type
                 'linear-algebra:identity-matrix)))
    (assert-true
     (linear-algebra:identity-matrix-p
      (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq matrix (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq (linear-algebra::contents matrix)
         (linear-algebra::contents
          (linear-algebra:copy-matrix matrix))))))

@ 

\subsection{Testing Subsets of Identity Matrices}
\label{sec:testing-identity-matrix-subsets}

The subset of a identity matrix is tested for 3 subsets and 6 errors.
<<Test: Subset of the identity matrix>>=
;;; Test the submatrix of a identity matrix
(define-test identity-submatrix
  (let ((matrix (linear-algebra:make-matrix
                 10 10
                 :matrix-type
                 'linear-algebra:identity-matrix
                 :element-type 'single-float)))
    <<Subsets of an identity matrix>>
    <<Invalid subsets of an identity matrix>>))

@ The first subset is the entire matrix. The second subset is
specified with a start row and column. The final subset is for a fully
specified range.
<<Subsets of an identity matrix>>=
;; The entire matrix
(assert-true
 (typep (linear-algebra:submatrix matrix 0 0)
        'linear-algebra:identity-matrix))
(assert-rational-equal
 10 (slot-value (linear-algebra:submatrix matrix 0 0)
                'linear-algebra::size))
;; Start row and column to the end
(assert-true
 (typep (linear-algebra:submatrix matrix 3 3)
        'linear-algebra:identity-matrix))
(assert-rational-equal
 7 (slot-value (linear-algebra:submatrix matrix 3 3)
               'linear-algebra::size))
;; End row and column
(assert-true
 (typep (linear-algebra:submatrix matrix 2 2
                                  :row-end 8
                                  :column-end 8)
        'linear-algebra:identity-matrix))
(assert-rational-equal
 6 (slot-value (linear-algebra:submatrix matrix 2 2
                                         :row-end 8
                                         :column-end 8)
               'linear-algebra::size))
;; Dense matrix
(assert-true
 (typep (linear-algebra:submatrix matrix 2 2
                                  :row-end 4
                                  :column-end 6)
        'linear-algebra:dense-matrix))
(assert-float-equal
 #2A((1.0 0.0 0.0 0.0)
     (0.0 1.0 0.0 0.0))
 (linear-algebra:submatrix matrix 2 2
                           :row-end 4
                           :column-end 6))
;; Square matrix
(assert-true
 (typep (linear-algebra:submatrix matrix 0 2
                                  :row-end 3
                                  :column-end 5)
        'linear-algebra:square-matrix))
(assert-float-equal
 #2A((0.0 0.0 0.0)
     (0.0 0.0 0.0)
     (1.0 0.0 0.0))
 (linear-algebra:submatrix matrix 0 2
                           :row-end 3
                           :column-end 5))
@ The first 4 errors result from specifying the start row, start
column, end row or end column in excess of the dimensions. The last 2
errors result from the start row exceeding the end row or the start
column exceeding the end column.
<<Invalid subsets of an identity matrix>>=
;; Start row exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 11 5))
;; Start column exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 11))
;; End row exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :row-end 11))
;; End column exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :column-end 11))
;; Start row exceeds end row
(assert-error 'error (linear-algebra:submatrix matrix 7 7 :row-end 6))
;; Start column exceeds end column
(assert-error 'error (linear-algebra:submatrix matrix 7 7 :column-end 6))
@ Setting the subset of an identity matrix is an error.
<<Test: Subset of the identity matrix>>=
(define-test setf-identity-submatrix
  (assert-error
   'error
   (setf (linear-algebra:submatrix
          (linear-algebra:make-matrix
           10 10 :matrix-type
           'linear-algebra:identity-matrix)
          5 5)
         (unit-matrix 5 5))))

@ Destructively replacing the subset of an identity matrix is also an
error.
<<Test: Destructively replace the subset of the identity matrix>>=
(define-test identity-matrix-replace
  ;; Replace the entire matrix
  (assert-error
   'error
   (linear-algebra:replace-matrix
    (linear-algebra:make-matrix
     5 5 :matrix-type 'linear-algebra:identity-matrix)
    (unit-matrix 5 5))))

@ 


The final group of tests is generated by the macro
[[test-matrix-validated-range]] for the identity matrix object.
<<Test: Identity matrix validated range>>=
;;; Validate a range for an identity matrix.
(define-test identity-matrix-validated-range
  (test-matrix-validated-range
   'linear-algebra:identity-matrix 10 10))

@ 

\section{Permutation Matrix}
\label{sec:permutation-matrix}

<<permutation-matrix.lisp>>=
<<In linear algebra unit tests>>
<<Test: Make a permutation matrix>>
<<Test: Permutation matrix predicate>>
<<Test: Permutation matrix bounds predicate>>
<<Test: Permutation matrix element type>>
<<Test: Permutation matrix dimensions>>
<<Test: Permutation matrix row dimension>>
<<Test: Permutation matrix column dimension>>
<<Test: Permutation matrix element reference>>
<<Test: Copy a permutation matrix>>
<<Test: Subset of the permutation matrix>>
<<Test: Permutation matrix transpose>>
<<Test: Initialize destructive permutation matrix transpose>>
<<Test: Destructive permutation matrix transpose>>
<<Test: Permutation matrix validated range>>
@ The permutation matrix tests depend on the linear algebra test
package and the matrix test macros.
<<Permutation matrix dependencies>>=
(:file "permutation-matrix"
       :depends-on ("defpackage" "matrix"))
@

\subsection{Creating a Permutation Matrix Tests}
\label{sec:creating-permutation-matrix-tests}

The permutation matrix is tested for default construction,
construction with initial contents and contstruction errors.
<<Test: Make a permutation matrix>>=
(define-test make-permutation-matrix
  <<Make a default permutation matrix>>
  <<Specify the permutation matrix initial contents>>
  <<Permutation matrix construction errors>>)

@ A default permutation matrix is equivalent to an identity matrix.
<<Make a default permutation matrix>>=
;; A default permutation matrix
(let ((matrix (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:permutation-matrix)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:permutation-matrix))
  (assert-rational-equal
   #(0 1 2 3 4)
   (linear-algebra::contents matrix)))
@ Initial contents specified by a nested list are tested.
<<Specify the permutation matrix initial contents>>=
;; Specify the permutation matrix contents - Nested list
(let ((matrix (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:permutation-matrix
               :initial-contents
               '((0 0 0 0 1)
                 (1 0 0 0 0)
                 (0 1 0 0 0)
                 (0 0 0 1 0)
                 (0 0 1 0 0)))))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:permutation-matrix))
  (assert-rational-equal
   #(4 0 1 3 2)
   (linear-algebra::contents matrix)))
@ The initial contents can also be specified by a nested vector.
<<Specify the permutation matrix initial contents>>=
;; Specify the permutation matrix contents - Nested vector
(let ((matrix (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:permutation-matrix
               :initial-contents
               #(#(0 0 0 0 1)
                 #(1 0 0 0 0)
                 #(0 1 0 0 0)
                 #(0 0 0 1 0)
                 #(0 0 1 0 0)))))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:permutation-matrix))
  (assert-rational-equal
   #(4 0 1 3 2)
   (linear-algebra::contents matrix)))
@ Finally, the initial contents specified by a 2D array are tested.
<<Specify the permutation matrix initial contents>>=
;; Specify the permutation matrix contents - 2D array
(let ((matrix (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:permutation-matrix
               :initial-contents
               #2A((0 0 0 0 1)
                   (1 0 0 0 0)
                   (0 1 0 0 0)
                   (0 0 0 1 0)
                   (0 0 1 0 0)))))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:permutation-matrix))
  (assert-rational-equal
   #(4 0 1 3 2)
   (linear-algebra::contents matrix)))
@ The permutation matrix is verified to generate an error if the
element type or initial element is specified. It is also verified to
generate an error with an invalid permutation for the initial
contents.
<<Permutation matrix construction errors>>=
;; Erroneous 2D array input data
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:permutation-matrix
               :initial-contents
               #3A(((1.1 1.2) (2.1 2.2))
                   ((3.1 3.2) (4.1 4.2))
                   ((5.1 5.2) (6.1 6.2)))))
(assert-error 'error
              (linear-algebra:make-matrix
               3 4
               :matrix-type 'linear-algebra:permutation-matrix
               :initial-contents
               (random-permutation-array 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               4 3
               :matrix-type 'linear-algebra:permutation-matrix
               :initial-contents
               (random-permutation-array 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               3 3 :element-type 'single-float
               :matrix-type 'linear-algebra:permutation-matrix))
(assert-error 'error
              (linear-algebra:make-matrix
               3 3
               :matrix-type 'linear-algebra:permutation-matrix
               :initial-contents
               #2A((0 1 0)
                   (1 0 0)
                   (1 0 1))))
@

\subsection{Test Permutation Matrix Predicates}
\label{sec:test-permutation-matrix-predicates}

The [[permutation-matrix-p]] function should return true if passed an
permutation matrix object.
<<Test: Permutation matrix predicate>>=
;;; Test the permutation matrix predicate
 (define-test permutation-matrix-predicate
   (assert-true
    (linear-algebra:permutation-matrix-p
     (linear-algebra:make-matrix
      10 10 :matrix-type 'linear-algebra:permutation-matrix)))
   (assert-false
    (linear-algebra:permutation-matrix-p (make-array '(10 10)))))

@ The other permutation matrix predicate should return true for valid
indices.
<<Test: Permutation matrix bounds predicate>>=
;;; Test the permutation matrix bounds
(define-test permutation-matrix-in-bounds-p
  (test-matrix-in-bounds-p 'linear-algebra:permutation-matrix))

@

\subsection{Test Permutation Matrix Inspection}
\label{sec:test-permutation-matrix-inspection}

All permutation matrix inpsection tests are generated from the matrix
test macros except for the matrix element type. The permutation matrix
element type is always [[FIXNUM]] and it is an error to specify any
other type.
<<Test: Permutation matrix element type>>=
;;; Test the permutation matrix element type
(define-test permutation-matrix-element-type
  (assert-eq 'fixnum
             (linear-algebra:matrix-element-type
              (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:permutation-matrix)))
  (dolist (element-type '(single-float double-float))
    (assert-error 'error
                  (linear-algebra:matrix-element-type
                   (linear-algebra:make-matrix
                    5 5
                    :element-type element-type
                    :matrix-type
                    'linear-algebra:permutation-matrix)))))

@ The matrix dimensions are tested using a 9x9 permutation matrix.
<<Test: Permutation matrix dimensions>>=
;;; Test the permutation matrix dimensions
(define-test permutation-matrix-dimensions
  (test-matrix-dimensions 'linear-algebra:permutation-matrix 9 9))

@ The matrix row dimension is tested for a value of 9.
<<Test: Permutation matrix row dimension>>=
;;; Test the permutation matrix row dimension
(define-test permutation-matrix-row-dimension
  (test-matrix-row-dimension 'linear-algebra:permutation-matrix 9 9))

@ Finally, the matrix column dimension is tested for a value of 9.
<<Test: Permutation matrix column dimension>>=
;;; Test the permutation matrix column dimension
(define-test permutation-matrix-column-dimension
  (test-matrix-column-dimension 'linear-algebra:permutation-matrix 9 9))

@ 

\subsection{Test Referencing Permutation Matrices}
\label{sec:test-referencing-permutation-matrices}

Every element of a 5x5 permutation matrix is verified for [[mref]].
<<Test: Permutation matrix element reference>>=
;;; Reference permutation matrix elements
(define-test permutation-matrix-mref
  (let ((pvec #(2 3 4 0 1))
        (matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type
                 'linear-algebra:permutation-matrix
                 :initial-contents
                 '((0 0 1 0 0)
                   (0 0 0 1 0)
                   (0 0 0 0 1)
                   (1 0 0 0 0)
                   (0 1 0 0 0)))))
    (do ((i0 0 (1+ i0)))
        ((>= i0 5))
      (do ((i1 0 (1+ i1)))
          ((>= i1 5))
        (if (= i1 (svref pvec i0))
            (assert-rational-equal
             1 (linear-algebra:mref matrix i0 i1))
            (assert-rational-equal
             0 (linear-algebra:mref matrix i0 i1)))))))

@ Similarly, [[(setf mref)]] is verified on every element of a
permutation matrix.
<<Test: Permutation matrix element reference>>=
;;; Set permutation matrix elements
(define-test permutation-matrix-setf-mref
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type
                 'linear-algebra:permutation-matrix
                 :initial-contents
                 (random-permutation-array 5))))
    (dotimes (i0 5)
      (dotimes (i1 5)
        (setf (linear-algebra:mref matrix i0 i1) 1)
        (assert-true
         (= 5 (length
               (remove-duplicates
                (linear-algebra::contents matrix))))
         i0 i1 (linear-algebra::contents matrix))))))

@ 

\subsection{Test Copying Permutation Matrices}
\label{sec:test-copying-permutation-matrices}

Three tests are performed on [[copy-matrix]] for permutation matrices.
The first test verifies that the matrix returned is not [[EQ]] to the
original matrix. The second test verifies that the contents are not
[[EQ]]. Finally, the elements are tested for equality.
<<Test: Copy a permutation matrix>>=
;;; Copy the permutation matrix
(define-test copy-permutation-matrix
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type 'linear-algebra:permutation-matrix
                 :initial-contents
                 (random-permutation-array 5))))
    (assert-true
     (linear-algebra:permutation-matrix-p
      (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq matrix (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq (linear-algebra::contents matrix)
         (linear-algebra::contents
          (linear-algebra:copy-matrix matrix))))
    (assert-rational-equal
     (linear-algebra::contents matrix)
     (linear-algebra::contents
      (linear-algebra:copy-matrix matrix)))))

@ 

\subsection{Testing Subsets of Permutation Matrices}
\label{sec:testing-permutation-matrix-subsets}

The subset of a permutation matrix is tested for 3 subsets and 6
errors.
<<Test: Subset of the permutation matrix>>=
;;; Test the submatrix of a permutation matrix
(define-test permutation-matrix-submatrix
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type
                 'linear-algebra:permutation-matrix
                 :initial-contents
                 '((0 0 0 0 1)
                   (0 0 0 1 0)
                   (0 0 1 0 0)
                   (1 0 0 0 0)
                   (0 1 0 0 0)))))
    <<Subsets of the permutation matrix>>
    <<Invalid subsets of the permutation matrix>>))

@ The first subset is the entire matrix. The second subset is
specified with a start row and column. The final subset is for a fully
specified range.
<<Subsets of the permutation matrix>>=
;; The entire matrix
(assert-rational-equal
 #2A((0 0 0 0 1)
     (0 0 0 1 0)
     (0 0 1 0 0)
     (1 0 0 0 0)
     (0 1 0 0 0))
 (linear-algebra:submatrix matrix 0 0))
;; Start row and column to the end
(assert-rational-equal
 #2A((1 0 0) (0 0 0) (0 0 0))
 (linear-algebra:submatrix matrix 2 2))
;; End row and column
(assert-rational-equal
 #2A((0 1) (1 0) (0 0))
 (linear-algebra:submatrix matrix 1 2 :row-end 4 :column-end 4)
 (linear-algebra::contents
  (linear-algebra:submatrix matrix 1 2 :row-end 4 :column-end 4)))
@ The first 4 errors result from specifying the start row, start
column, end row or end column in excess of the dimensions. The last 2
errors result from the start row exceeding the end row or the start
column exceeding the end column.
<<Invalid subsets of the permutation matrix>>=
;; Start row exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 6 5))
;; Start column exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 6))
;; End row exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :row-end 6))
;; End column exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :column-end 6))
;; Start row exceeds end row
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :row-end 3))
;; Start column exceeds end column
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :column-end 3))
@ 

\subsection{Test Permutation Matrix Transpose}
\label{sec:permutation-matrix-transpose}

The transpose of a permutation matrix is tested with a single matrix.
<<Test: Permutation matrix transpose>>=
(define-test permutation-matrix-transpose
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type
                 'linear-algebra:permutation-matrix
                 :initial-contents
                 '((0 0 0 0 1)
                   (0 0 0 1 0)
                   (0 0 1 0 0)
                   (1 0 0 0 0)
                   (0 1 0 0 0)))))
    (assert-rational-equal
     #(3 4 2 1 0)
     (linear-algebra::contents
      (linear-algebra:transpose matrix)))))

@ The destructive transpose of a permutation matrix relies on an
initialization function to determine the number of rows to skip and
the starting row for the transpose.
<<Test: Initialize destructive permutation matrix transpose>>=
(define-test permutation-matrix-%init-ntranspose
  (multiple-value-bind (row0 skip)
      (linear-algebra::%init-ntranspose #(4 3 2 0 1))
    (assert-eql 0 row0)
    (assert-eql 1 skip))
  (multiple-value-bind (row0 skip)
      (linear-algebra::%init-ntranspose #(0 1 4 2 3))
    (assert-eql 2 row0)
    (assert-eql 2 skip))
  (multiple-value-bind (row0 skip)
      (linear-algebra::%init-ntranspose #(4 1 2 3 0))
    (assert-eql 0 row0)
    (assert-eql 3 skip)))

@ The destructive transpose of a permutation matrix is tested using
the same matrix as the non-destructive test and using a matrix that
necessitates the initialization function.
<<Test: Destructive permutation matrix transpose>>=
(define-test permutation-matrix-ntranspose
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type
                 'linear-algebra:permutation-matrix
                 :initial-contents
                 '((0 0 0 0 1)
                   (0 0 0 1 0)
                   (0 0 1 0 0)
                   (1 0 0 0 0)
                   (0 1 0 0 0)))))
    (assert-eq matrix (linear-algebra:ntranspose matrix))
    (assert-rational-equal
     #(3 4 2 1 0)
     (linear-algebra::contents matrix)))
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type
                 'linear-algebra:permutation-matrix
                 :initial-contents
                 '((1 0 0 0 0)
                   (0 1 0 0 0)
                   (0 0 0 1 0)
                   (0 0 0 0 1)
                   (0 0 1 0 0)))))
    (assert-eq matrix (linear-algebra:ntranspose matrix))
    (assert-rational-equal
     #(0 1 4 2 3)
     (linear-algebra::contents matrix))))

@

\subsection{Test Validate the Range of a Permutation Matrix}
\label{sec:test-valid-permutation-range}

The final group of tests is generated by the macro
[[test-matrix-validated-range]] for the symmetric matrix object.
<<Test: Permutation matrix validated range>>=
;;; Validate a range for a permutation matrix.
(define-test permutation-matrix-validated-range
  (test-matrix-validated-range
   'linear-algebra:permutation-matrix 10 10))

@ 

\chapter{Test Dense Matrices}
\label{chap:test-dense-matrices}

<<dense-matrix.lisp>>=
<<In linear algebra unit tests>>
;;; Test dense matrix data operations
<<Test: Make a dense matrix>>
<<Test: Dense matrix predicate>>
<<Test: Dense matrix bounds predicate>>
<<Test: Dense matrix element type>>
<<Test: Dense matrix dimensions>>
<<Test: Dense matrix row dimension>>
<<Test: Dense matrix column dimension>>
<<Test: Dense matrix element reference>>
<<Test: Copy a dense matrix>>
<<Test: Subset of the dense matrix>>
<<Test: Destructively replace a subset of the dense matrix>>
<<Test: Dense matrix validated range>>
;;; Test dense matrix utility operations
<<Test: Scaled sum of squares of the dense matrix>>
<<Test: Scaled sum of powers of p of the dense matrix>>
;;; Test dense matrix fundamental operations
<<Test: Dense matrix 1 norm>>
<<Test: Dense matrix max norm>>
<<Test: Dense matrix Frobenius norm>>
<<Test: Dense matrix infinity norm>>
<<Test: Dense matrix norm>>
<<Test: Dense matrix transpose>>
<<Test: Destructive dense matrix transpose>>
<<Test: Dense matrix scale>>
<<Test: Destructive dense matrix scale>>
<<Test: Dense matrix product>>
@ The dense matrix tests depend on the linear algebra test package and
the matrix test macros.
<<Dense matrix dependencies>>=
(:file "dense-matrix"
       :depends-on ("defpackage" "matrix"))
@

\section{Creating a Dense Matrix Tests}
\label{sec:creating-dense-matrix-tests}

For dense matrices, [[make-matrix]] is tested for default
initialization, specifying the element type, specifying the initial
element, specifying the initial contents and generating an error when
both the initial element and initial contents are specified.
<<Test: Make a dense matrix>>=
(define-test make-dense-matrix
  <<Make a default dense matrix>>
  <<Specify the dense matrix element type>>
  <<Specify the dense matrix initial element>>
  <<Specify the dense matrix initial contents>>
  <<Dense matrix construction errors>>)

@ A dense matrix with none of the other keywords specified should be
initialized with zero.
<<Make a default dense matrix>>=
;; A default dense matrix
(let ((matrix (linear-algebra:make-matrix
               10 15
               :matrix-type 'linear-algebra:dense-matrix)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:dense-matrix))
  (assert-rational-equal
   (make-array '(10 15) :initial-element 0)
   matrix))
@ Specifying the element type is verified for [[SINGLE-FLOAT]], but
further testing should be implemented.
<<Specify the dense matrix element type>>=
;; Specify the dense matrix element type
(let ((matrix (linear-algebra:make-matrix
               10 15
               :matrix-type 'linear-algebra:dense-matrix
               :element-type 'single-float)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:dense-matrix))
  (assert-eq (array-element-type
              (linear-algebra::contents matrix))
             (array-element-type
              (make-array '(10 15) :element-type 'single-float)))
  (assert-float-equal
   (make-array '(10 15) :initial-element 0.0
               :element-type 'single-float)
   matrix))
@ If a value other than zero is required, is specified with
[[:initial-element]].
<<Specify the dense matrix initial element>>=
;; Specify the dense matrix initial element
(let ((matrix (linear-algebra:make-matrix
               10 15
               :matrix-type 'linear-algebra:dense-matrix
               :initial-element 1.0)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:dense-matrix))
  (assert-float-equal
   (make-array '(10 15) :initial-element 1.0)
   matrix))
@ The initial contents can be initialized with a nested sequence or a
2D array. The sequence can be a nested list
<<Specify the dense matrix initial contents>>=
;; Specify the dense matrix contents - Nested list
(let* ((data '((1.1 1.2 1.3 1.4)
               (2.1 2.2 2.3 2.4)
               (3.1 3.2 3.3 3.4))) 
       (matrix (linear-algebra:make-matrix
                3 4
                :matrix-type 'linear-algebra:dense-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:dense-matrix))
  (assert-float-equal
   (make-array '(3 4) :initial-contents data)
   matrix))
@ or a nested vector.
<<Specify the dense matrix initial contents>>=
;; Specify the dense matrix contents - Nested vector
(let* ((data #(#(1.1 1.2 1.3 1.4)
               #(2.1 2.2 2.3 2.4)
               #(3.1 3.2 3.3 3.4)))
       (matrix (linear-algebra:make-matrix
                3 4
                :matrix-type 'linear-algebra:dense-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:dense-matrix))
  (assert-float-equal
   (make-array '(3 4) :initial-contents data)
   matrix))
@ Finally, the initial contents can be a 2D array.
<<Specify the dense matrix initial contents>>=
;; Specify the dense matrix contents - 2D array
(let* ((data (make-array '(3 4) :initial-contents
                         '((1.1 1.2 1.3 1.4)
                           (2.1 2.2 2.3 2.4)
                           (3.1 3.2 3.3 3.4))))
       (matrix (linear-algebra:make-matrix
                3 4
                :matrix-type 'linear-algebra:dense-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:dense-matrix))
  (assert-float-equal data matrix))
@ The default behavior of [[make-array]] is relied upon for error
checking when constructing a dense matrix using nested lists or
vector. The validity of 2D array input data is verified within the
linear algebra package and requires testing.
<<Dense matrix construction errors>>=
;; Erroneous 2D array input data
(assert-error 'error
              (linear-algebra:make-matrix
               3 4 :initial-contents
               #3A(((1.1 1.2) (2.1 2.2))
                   ((3.1 3.2) (4.1 4.2))
                   ((5.1 5.2) (6.1 6.2)))))
(assert-error 'error
              (linear-algebra:make-matrix
               2 3 :initial-contents
               (coordinate-array 0 0 3 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               3 2 :initial-contents
               (coordinate-array 0 0 3 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               2 3 :element-type 'single-float
               :initial-contents
               #2A((1 2 3) (4 5 6))))
@ As with arrays, it is an error to specify both the initial element
and the initial contents.
<<Dense matrix construction errors>>=
;; Specify initial element and initial contents
(assert-error 'error
              (linear-algebra:make-matrix
               3 4 :initial-element 1.1
               :initial-contents
               (coordinate-array 0 0 3 4)))
@ 

\section{Test Dense Matrix Predicates}
\label{sec:test-dense-matrix-predicates}

The [[dense-matrix-p]] function should return true if passed a dense
matrix object.
<<Test: Dense matrix predicate>>=
;;; Test the dense matrix predicate
(define-test dense-matrix-predicate
  (assert-true
   (linear-algebra:dense-matrix-p
    (linear-algebra:make-matrix
     10 15 :matrix-type 'linear-algebra:dense-matrix)))
  (assert-false
   (linear-algebra:dense-matrix-p (make-array '(10 15)))))

@ The other dense matrix predicate should return true for valid
indices.
<<Test: Dense matrix bounds predicate>>=
;;; Test the dense matrix bounds
(define-test dense-matrix-in-bounds-p
  (test-matrix-in-bounds-p 'linear-algebra:dense-matrix))

@ 

\section{Test Dense Matrix Inspection}
\label{sec:test-dense-matrix-inspection}

All dense matrix inspection tests are generated from the matrix test
macros.
<<Test: Dense matrix element type>>=
;;; Test the dense matrix element type
(define-test dense-matrix-element-type
  (test-matrix-element-type 'linear-algebra:dense-matrix))

@ The matrix dimensions are tested using a 5x7 dense matrix.
<<Test: Dense matrix dimensions>>=
;;; Test the dense matrix dimensions
(define-test dense-matrix-dimensions
  (test-matrix-dimensions 'linear-algebra:dense-matrix 5 7))

@ The matrix row dimension is tested for a value of 5.
<<Test: Dense matrix row dimension>>=
;;; Test the dense matrix row dimension
(define-test dense-matrix-row-dimension
  (test-matrix-row-dimension 'linear-algebra:dense-matrix 5 7))

@ Finally, the matrix column dimension is tested for a value of 7.
<<Test: Dense matrix column dimension>>=
;;; Test the dense matrix column dimension
(define-test dense-matrix-column-dimension
  (test-matrix-column-dimension 'linear-algebra:dense-matrix 5 7))

@ 

\section{Test Referencing Dense Matrices}
\label{sec:test-referencing-dense-matrices}

The four corners of the dense matrix and a random interior point are
tested for equality against the input data.
<<Test: Dense matrix element reference>>=
;;; Reference dense matrix elements
(define-test dense-matrix-mref
  (let* ((initial-contents
          '((1.1 1.2 1.3 1.4 1.5)
            (2.1 2.2 2.3 2.4 2.5)
            (3.1 3.2 3.3 3.4 3.5)))
         (rows 3) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (random-interior-index columns))
         (data (make-array
                (list rows columns)
                :initial-contents
                initial-contents))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:dense-matrix
                  :initial-contents
                  initial-contents)))
    (assert-float-equal
     (aref data 0 0)
     (linear-algebra:mref matrix 0 0))
    (assert-float-equal
     (aref data 0 cend)
     (linear-algebra:mref matrix 0 cend))
    (assert-float-equal
     (aref data rend 0)
     (linear-algebra:mref matrix rend 0))
    (assert-float-equal
     (aref data rend cend)
     (linear-algebra:mref matrix rend cend))
    (assert-float-equal
     (aref data rowi coli)
     (linear-algebra:mref matrix rowi coli))))

@ Similarly, the four corners and a random interior point of a dense
matrix are set and then compared with the original value.
<<Test: Dense matrix element reference>>=
;;; Set dense matrix elements
(define-test dense-matrix-setf-mref
  (let* ((rows 3) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (random-interior-index columns))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type 'linear-algebra:dense-matrix
                  :initial-contents
                  '((1.1 1.2 1.3 1.4 1.5)
                    (2.1 2.2 2.3 2.4 2.5)
                    (3.1 3.2 3.3 3.4 3.5)))))
    (destructuring-bind (val1 val2 val3 val4 val5)
        (make-random-list 5 1.0)
      (setf (linear-algebra:mref matrix 0 0)    val1)
      (setf (linear-algebra:mref matrix 0 cend) val2)
      (setf (linear-algebra:mref matrix rend 0) val3)
      (setf (linear-algebra:mref matrix rend cend) val4)
      (setf (linear-algebra:mref matrix rowi coli) val5)
      (assert-float-equal val1 (linear-algebra:mref matrix 0 0))
      (assert-float-equal val2 (linear-algebra:mref matrix 0 cend))
      (assert-float-equal val3 (linear-algebra:mref matrix rend 0))
      (assert-float-equal val4 (linear-algebra:mref matrix rend cend))
      (assert-float-equal val5 (linear-algebra:mref matrix rowi coli)))))

@ 

\section{Test Copying Dense Matrices}
\label{sec:test-copying-dense-matrices}

Three tests are performed on [[copy-matrix]] for dense matrices. The
first test verifies that the matrix returned is not [[EQ]] to the
original matrix. The second test verifies that the contents are not
[[EQ]]. Finally, the elements are tested for equality.
<<Test: Copy a dense matrix>>=
;;; Copy the dense matrix
(define-test copy-dense-matrix
  (let ((matrix (linear-algebra:make-matrix
                 3 5
                 :matrix-type 'linear-algebra:dense-matrix
                 :initial-contents
                 '((1.1 1.2 1.3 1.4 1.5)
                   (2.1 2.2 2.3 2.4 2.5)
                   (3.1 3.2 3.3 3.4 3.5)))))
    (assert-true
     (linear-algebra:dense-matrix-p
      (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq matrix (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq (linear-algebra::contents matrix)
         (linear-algebra::contents
          (linear-algebra:copy-matrix matrix))))
    (assert-float-equal
     matrix (linear-algebra:copy-matrix matrix))))

@ 

\section{Testing Subsets of Dense Matrices}
\label{sec:testing-dense-matrix-subsets}

The subset of a dense matrix is tested for 3 subsets and 6 errors.
<<Test: Subset of the dense matrix>>=
;;; Test the submatrix of a dense matrix
(define-test dense-submatrix
  (let ((matrix (linear-algebra:make-matrix
                 7 10
                 :matrix-type
                 'linear-algebra:dense-matrix
                 :initial-contents
                 (coordinate-array 0 0 7))))
    <<Subsets of a dense matrix>>
    <<Invalid subsets of a dense matrix>>))

@ The first subset is the entire matrix. The second subset is
specified with a start row and column. The final subset is for a fully
specified range.
<<Subsets of a dense matrix>>=
;; The entire matrix
(assert-float-equal
 (coordinate-array 0 0 7)
 (linear-algebra:submatrix matrix 0 0))
;; Start row and column to the end
(assert-float-equal
 (coordinate-array 3 3 7)
 (linear-algebra:submatrix matrix 3 3))
;; End row and column
(assert-float-equal
 (coordinate-array 3 4 5 5)
 (linear-algebra:submatrix matrix 3 4 :row-end 5 :column-end 5))
@ The first 4 errors result from specifying the start row, start
column, end row or end column in excess of the dimensions. The last 2
errors result from the start row exceeding the end row or the start
column exceeding the end column.
<<Invalid subsets of a dense matrix>>=
;; Start row exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 8 5))
;; Start column exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 11))
;; End row exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :row-end 8))
;; End column exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :column-end 11))
;; Start row exceeds end row
(assert-error 'error (linear-algebra:submatrix matrix 7 7 :row-end 6))
;; Start column exceeds end column
(assert-error 'error (linear-algebra:submatrix matrix 7 7 :column-end 6))
@

A submatrix of a dense matrix is settable. Testing is performed
considering 5 basic submatrices. The test of each submatrix is
performed for multiple ranges to verify that the minimum size range is
set based on the size of the matrices as well as the specified ranges.
<<Test: Subset of the dense matrix>>=
;;; Set the submatrix of a dense matrix
(define-test setf-dense-submatrix
  <<Set the upper left submatrix of the dense matrix>>
  <<Set the upper right submatrix of the dense matrix>>
  <<Set the lower left submatrix of the dense matrix>>
  <<Set the lower right submatrix of the dense matrix>>
  <<Set the middle submatrix of the dense matrix>>)

@ The first submatrix for testing is the upper left submatrix. The
result of this test should be a 5x5 matrix, initially all zeroes, with
the upper left 2x2 submatrix set to ones.
<<Set the upper left submatrix of the dense matrix>>=
;; Upper left submatrix
(let ((array-ul (make-array
                 '(5 5) :initial-contents
                 '((1 1 0 0 0)
                   (1 1 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)))))
  (assert-rational-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 0 0)
    (unit-matrix 2 2)))
  (assert-rational-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 0 0 :row-end 2 :column-end 2)
    (linear-algebra:submatrix (unit-matrix 5 5) 0 0)))
  (assert-rational-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 0 0)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 0 0 :row-end 2 :column-end 2)))
  (assert-rational-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 0 0 :row-end 2 :column-end 2)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 2 2 :row-end 4 :column-end 4))))
@ The next submatrix is the upper right submatrix. The result of this
test is also a 5x5 matrix, initially all zeroes, with the upper right
2x2 submatrix set to ones.
<<Set the upper right submatrix of the dense matrix>>=
;; Upper right submatrix
(let ((array-ur (make-array
                 '(5 5) :initial-contents
                 '((0 0 0 1 1)
                   (0 0 0 1 1)
                   (0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)))))
  (assert-rational-equal
   array-ur
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 0 3)
    (unit-matrix 2 2)))
  (assert-rational-equal
   array-ur
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 0 3)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 0 3 :row-end 2 :column-end 5)))
  (assert-rational-equal
   array-ur
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 0 3 :row-end 2 :column-end 5)
    (unit-matrix 5 5)))
  (assert-rational-equal
   array-ur
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 0 3 :row-end 2 :column-end 5)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 2 2 :row-end 4 :column-end 4))))
@ The third submatrix is the lower left submatrix. Again, the result
is a 5x5 matrix, initially all zeroes, with the lower left 2x2
submatrix set to ones.
<<Set the lower left submatrix of the dense matrix>>=
;; Lower left submatrix
(let ((array-ll (make-array
                 '(5 5) :initial-contents
                 '((0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)
                   (1 1 0 0 0)
                   (1 1 0 0 0)))))
  (assert-rational-equal
   array-ll
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 3 0)
    (unit-matrix 2 2)))
  (assert-rational-equal
   array-ll
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 3 0)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 0 3 :row-end 2 :column-end 5)))
  (assert-rational-equal
   array-ll
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 3 0 :row-end 5 :column-end 2)
    (unit-matrix 5 5)))
  (assert-rational-equal
   array-ll
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 3 0 :row-end 5 :column-end 2)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 2 2 :row-end 4 :column-end 4))))
@ Only the lower right corner remains.
<<Set the lower right submatrix of the dense matrix>>=
;; Lower right submatrix
(let ((array-lr (make-array
                 '(5 5)
                 :initial-contents
                 '((0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 1 1)
                   (0 0 0 1 1)))))
  (assert-rational-equal
   array-lr
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 3 3)
    (unit-matrix 2 2)))
  (assert-rational-equal
   array-lr
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 3 3)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 0 3 :row-end 2 :column-end 5)))
  (assert-rational-equal
   array-lr
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 3 3 :row-end 5 :column-end 5)
    (unit-matrix 5 5)))
  (assert-rational-equal
   array-lr
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 3 3 :row-end 5 :column-end 5)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 2 2 :row-end 4 :column-end 4))))
@ The final test is for the middle of the matrix. As before, the
result is a 5x5 matrix initially all zeroes. But in this case, the
middle 3x3 submatrix is set to ones.
<<Set the middle submatrix of the dense matrix>>=
;; Middle submatrix
(let ((array-mid (make-array
                  '(5 5)
                  :initial-contents
                  '((0 0 0 0 0)
                    (0 1 1 1 0)
                    (0 1 1 1 0)
                    (0 1 1 1 0)
                    (0 0 0 0 0)))))
  (assert-rational-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 1 1)
    (unit-matrix 3 3)))
  (assert-rational-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 1 1)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 1 1 :row-end 4 :column-end 4)))
  (assert-rational-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 1 1 :row-end 4 :column-end 4)
    (unit-matrix 5 5)))
  (assert-rational-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:dense-matrix
    (linear-algebra:submatrix matrix 1 1 :row-end 4 :column-end 4)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 1 1 :row-end 4 :column-end 4))))
@ 

The final function in the matrix interface is the [[replace-matrix]]
function. The testing covers 4 types of replacement: replacing the
entire matrix, replacing the first 2 rows, replacing the first 3
columns and replace a center portion.
<<Test: Destructively replace a subset of the dense matrix>>=
;;; Replace all or part of a dense matrix
(define-test dense-matrix-replace
  <<Replace the entire dense matrix>>
  <<Replace the first 2 rows of the dense matrix>>
  <<Replace the first 3 columns of the dense matrix>>
  <<Replace the center of the dense matrix>>)

@ The first test is a single test that replaces every element of the
first matrix with the second.
<<Replace the entire dense matrix>>=
;; Replace the entire matrix
(assert-rational-equal
 (unit-matrix 5 5)
 (linear-algebra:replace-matrix
  (zero-matrix 5 5) (unit-matrix 5 5)))
@ The second group of tests replaces the first 2 rows of the matrix.
The test is repeated to test applicable keyword arguments.
<<Replace the first 2 rows of the dense matrix>>=
;; Replace the first 2 rows
(let ((result (make-array
               '(5 5)
               :initial-contents
               '((1 1 1 1 1)
                 (1 1 1 1 1)
                 (0 0 0 0 0)
                 (0 0 0 0 0)
                 (0 0 0 0 0)))))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 2 5)))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 2 7)))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5) :row2 3))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5) :row1-end 2))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5) :row2-end 2)))
@ The third group of tests replaces the first 3 columns of the
matrix. The test is repeated to test applicable keyword arguments.
<<Replace the first 3 columns of the dense matrix>>=
;; Replace the first 3 columns
(let ((result (make-array
               '(5 5)
               :initial-contents
               '((1 1 1 0 0)
                 (1 1 1 0 0)
                 (1 1 1 0 0)
                 (1 1 1 0 0)
                 (1 1 1 0 0)))))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 3)))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 7 3)))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5) :column2 2))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5) :column1-end 3))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5) :column2-end 3)))
@ The final group of tests replaces the center elements of the matrix.
As before, the test is repeated for various combinations of applicable
keywords.
<<Replace the center of the dense matrix>>=
;; Replace the center
(let ((result (make-array
               '(5 5)
               :initial-contents
               '((0 0 0 0 0)
                 (0 1 1 1 0)
                 (0 1 1 1 0)
                 (0 1 1 1 0)
                 (0 0 0 0 0)))))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 3 3) :row1 1 :column1 1))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5)
    :row1 1 :column1 1
    :row1-end 4 :column1-end 4))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5)
    :row1 1 :column1 1
    :row2-end 3 :column2-end 3))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5)
    (unit-matrix 5 5)
    :row1 1 :column1 1
    :row2 2 :column2 2)))
@ 

The final group of tests is generated by the macro
[[test-matrix-validated-range]] for the dense matrix object.
<<Test: Dense matrix validated range>>=
;;; Validate a range for a dense matrix.
(define-test dense-matrix-validated-range
  (test-matrix-validated-range
   'linear-algebra:dense-matrix 10 10))

@ 

\section{Test Scaled Sums of Dense Matrix}
\label{sec:dense-matrix-scaled-sums}

The tests for the scaled sums of dense matrices are cursory. They
should be expanded to cover edge values. Only a single test is
performed for the scaled sum of the squares.
<<Test: Scaled sum of squares of the dense matrix>>=
(define-test dense-matrix-sumsq
  (multiple-value-bind (scale sumsq)
      (linear-algebra:sumsq
       (linear-algebra:make-matrix
        4 5 :initial-contents
        #2A((1.1 1.2 1.3 1.4 1.5)
            (2.1 2.2 2.3 2.4 2.5)
            (3.1 3.2 3.3 3.4 3.5)
            (4.1 4.2 4.3 4.4 4.5))))
    (assert-float-equal 4.5 scale)
    (assert-float-equal 8.997532 sumsq)))

@ Another test is performed of the scaled sum of the P powers.
<<Test: Scaled sum of powers of p of the dense matrix>>=
(define-test dense-matrix-sump
  (multiple-value-bind (scale sump)
      (linear-algebra:sump
       (linear-algebra:make-matrix
        4 5 :initial-contents
        #2A((1.1 1.2 1.3 1.4 1.5)
            (2.1 2.2 2.3 2.4 2.5)
            (3.1 3.2 3.3 3.4 3.5)
            (4.1 4.2 4.3 4.4 4.5)))
       3.5)
    (assert-float-equal 4.5 scale)
    (assert-float-equal 6.540154 sump)))

@ 

\section{Test Dense Matrix Norm}
\label{sec:test-dense-matrix-norm}

Each specific type of dense matrix norm is tested using 1 value. The
dense matrix method is tested for each type of norm plus verified to
generate an error for an unknown type of norm. The dense matrix 1 norm
is tested for a single floating point value.
<<Test: Dense matrix 1 norm>>=
(define-test %dense-matrix-1-norm
  (assert-float-equal
   17.0 (linear-algebra::%dense-matrix-1-norm
         (linear-algebra:make-matrix
          5 4 :initial-contents
          #2A((1.1 1.2 1.3 1.4)
              (2.1 2.2 2.3 2.4)
              (3.1 3.2 3.3 3.4)
              (4.1 4.2 4.3 4.4)
              (5.1 5.2 5.3 5.4))))))

@ The dense matrix max norm is also tested for a single floating point
value.
<<Test: Dense matrix max norm>>=
(define-test %dense-matrix-max-norm
  (assert-float-equal
   5.4 (linear-algebra::%dense-matrix-max-norm
        (linear-algebra:make-matrix
         5 4 :initial-contents
         #2A((1.1 1.2 1.3 1.4)
             (2.1 2.2 2.3 2.4)
             (3.1 3.2 3.3 3.4)
             (4.1 4.2 4.3 4.4)
             (5.1 5.2 5.3 5.4))))))

@ Likewise, the dense matrix Frobenius norm is tested against a single
value.
<<Test: Dense matrix Frobenius norm>>=
(define-test %dense-matrix-frobenius-norm
  (assert-float-equal
   15.858751 (linear-algebra::%dense-matrix-frobenius-norm
              (linear-algebra:make-matrix
               5 4 :initial-contents
               #2A((1.1 1.2 1.3 1.4)
                   (2.1 2.2 2.3 2.4)
                   (3.1 3.2 3.3 3.4)
                   (4.1 4.2 4.3 4.4)
                   (5.1 5.2 5.3 5.4))))))

@ Again, the dense matrix infinity norm is tested for a single
floating point value.
<<Test: Dense matrix infinity norm>>=
(define-test %dense-matrix-infinity-norm
  (assert-float-equal
   21.0 (linear-algebra::%dense-matrix-infinity-norm
         (linear-algebra:make-matrix
          5 4 :initial-contents
          #2A((1.1 1.2 1.3 1.4)
              (2.1 2.2 2.3 2.4)
              (3.1 3.2 3.3 3.4)
              (4.1 4.2 4.3 4.4)
              (5.1 5.2 5.3 5.4))))))

@ Finally, the dense matrix norm is tested for each of the specific
norms and for an unknown norm error.
<<Test: Dense matrix norm>>=
(define-test dense-matrix-norm
  (let ((matrix (linear-algebra:make-matrix
                 5 4 :initial-contents
                 #2A((1.1 1.2 1.3 1.4)
                     (2.1 2.2 2.3 2.4)
                     (3.1 3.2 3.3 3.4)
                     (4.1 4.2 4.3 4.4)
                     (5.1 5.2 5.3 5.4)))))
    (assert-float-equal
     17.0 (linear-algebra:norm matrix))
    (assert-float-equal
     17.0 (linear-algebra:norm matrix :measure 1))
    (assert-float-equal
     5.4 (linear-algebra:norm matrix :measure :max))
    (assert-float-equal
     15.858751 (linear-algebra:norm matrix :measure :frobenius))
    (assert-float-equal
     21.0 (linear-algebra:norm matrix :measure :infinity))
    (assert-error
     'error
     (linear-algebra:norm matrix :measure :unknown))))

@ 

\section{Test Dense Matrix Transpose}
\label{sec:dense-matrix-transpose}

The implementation of [[transpose]] for the dense matrix is tested for
3 cases. First, the transpose of a real matrix is tested. Second,
the transpose of a complex matrix is tested. Finally, the conjugate
transpose of a complex matrix is transposed.
<<Test: Dense matrix transpose>>=
(define-test dense-matrix-transpose
  <<Dense matrix transpose>>
  <<Complex dense matrix transpose>>
  <<Complex dense matrix conjugate transpose>>)

@ To test a real matrix transpose, a 5 row by 4 column matrix is
created and verified against a 4 row by 5 column array representing
the transpose.
<<Dense matrix transpose>>=
(let ((matrix (linear-algebra:make-matrix
               5 4 :initial-contents
               #2A((1.1 1.2 1.3 1.4)
                   (2.1 2.2 2.3 2.4)
                   (3.1 3.2 3.3 3.4)
                   (4.1 4.2 4.3 4.4)
                   (5.1 5.2 5.3 5.4))))
      (transpose #2A((1.1 2.1 3.1 4.1 5.1)
                     (1.2 2.2 3.2 4.2 5.2)
                     (1.3 2.3 3.3 4.3 5.3)
                     (1.4 2.4 3.4 4.4 5.4))))
  (assert-true
   (typep (linear-algebra:transpose matrix)
          'linear-algebra:dense-matrix))
  (assert-float-equal
   transpose (linear-algebra:transpose matrix)))
@ For the complex transpose, a 5 row by 2 column complex matrix is
created and compared against an array representation of the transpose.
<<Complex dense matrix transpose>>=
(let ((matrix (linear-algebra:make-matrix
               5 2 :initial-contents
               #2A((#C(1.1 1.2) #C(1.3 1.4))
                   (#C(2.1 2.2) #C(2.3 2.4))
                   (#C(3.1 3.2) #C(3.3 3.4))
                   (#C(4.1 4.2) #C(4.3 4.4))
                   (#C(5.1 5.2) #C(5.3 5.4)))))
      (transpose #2A((#C(1.1 1.2) #C(2.1 2.2) #C(3.1 3.2) #C(4.1 4.2) #C(5.1 5.2))
                     (#C(1.3 1.4) #C(2.3 2.4) #C(3.3 3.4) #C(4.3 4.4) #C(5.3 5.4)))))
  (assert-true
   (typep (linear-algebra:transpose matrix)
          'linear-algebra:dense-matrix)
   (assert-float-equal
    transpose (linear-algebra:transpose matrix))))
@ Finally, a conjugate transpose is performed on the complex matrix
and verified against the array solution.
<<Complex dense matrix conjugate transpose>>=
(let ((matrix (linear-algebra:make-matrix
               5 2 :initial-contents
               #2A((#C(1.1 1.2) #C(1.3 1.4))
                   (#C(2.1 2.2) #C(2.3 2.4))
                   (#C(3.1 3.2) #C(3.3 3.4))
                   (#C(4.1 4.2) #C(4.3 4.4))
                   (#C(5.1 5.2) #C(5.3 5.4)))))
      (transpose #2A((#C(1.1 -1.2) #C(2.1 -2.2) #C(3.1 -3.2)
                        #C(4.1 -4.2) #C(5.1 -5.2))
                     (#C(1.3 -1.4) #C(2.3 -2.4) #C(3.3 -3.4)
                        #C(4.3 -4.4) #C(5.3 -5.4)))))
  (assert-true
   (typep (linear-algebra:transpose matrix :conjugate t)
          'linear-algebra:dense-matrix)
   (assert-float-equal
    transpose (linear-algebra:transpose matrix :conjugate t))))
@

The destructive transpose of a dense matrix is limited to matrices
with an equal number of rows and columns. The test for this error is
performed in addition to the tests performed for the transpose of a
dense matrix for a total for 4 test cases.
<<Test: Destructive dense matrix transpose>>=
(define-test dense-matrix-ntranspose
  <<Destructive transpose dimensions error>>
  <<Dense matrix destructive transpose>>
  <<Complex dense matrix destructive transpose>>
  <<Complex dense matrix destructive conjugate transpose>>)

@ The error test simply passes a new, non-square, dense matrix to
[[ntranspose]].
<<Destructive transpose dimensions error>>=
(assert-error 'error
              (linear-algebra:ntranspose
               (linear-algebra:make-matrix
                5 4 :initial-contents
                #2A((1.1 1.2 1.3 1.4)
                    (2.1 2.2 2.3 2.4)
                    (3.1 3.2 3.3 3.4)
                    (4.1 4.2 4.3 4.4)
                    (5.1 5.2 5.3 5.4)))))
@ The destructive transpose of the real matrix is tested to be the
identical object of the original and then the contents are tested.
<<Dense matrix destructive transpose>>=
(let ((matrix (linear-algebra:make-matrix
               4 4 :initial-contents
               #2A((1.1 1.2 1.3 1.4)
                   (2.1 2.2 2.3 2.4)
                   (3.1 3.2 3.3 3.4)
                   (4.1 4.2 4.3 4.4))))
      (transpose #2A((1.1 2.1 3.1 4.1)
                     (1.2 2.2 3.2 4.2)
                     (1.3 2.3 3.3 4.3)
                     (1.4 2.4 3.4 4.4))))
  (assert-eq matrix (linear-algebra:ntranspose matrix))
  (assert-float-equal transpose matrix)) 
@ Similarly, the complex matrix is tested to be the identical object
and then the contents are tested.
<<Complex dense matrix destructive transpose>>=
(let ((matrix (linear-algebra:make-matrix
               2 2 :initial-contents
               #2A((#C(1.1 1.2) #C(1.3 1.4))
                   (#C(2.1 2.2) #C(2.3 2.4)))))
      (transpose #2A((#C(1.1 1.2) #C(2.1 2.2))
                     (#C(1.3 1.4) #C(2.3 2.4)))))
  (assert-eq matrix (linear-algebra:ntranspose matrix))
  (assert-float-equal transpose matrix))
@ Finally, the destructive conjugate transpose is tested for the same
2 cases.
<<Complex dense matrix destructive conjugate transpose>>=
(let ((matrix (linear-algebra:make-matrix
               2 2 :initial-contents
               #2A((#C(1.1 1.2) #C(1.3 1.4))
                   (#C(2.1 2.2) #C(2.3 2.4)))))
      (transpose #2A((#C(1.1 -1.2) #C(2.1 -2.2))
                     (#C(1.3 -1.4) #C(2.3 -2.4)))))
  (assert-eq matrix (linear-algebra:ntranspose matrix :conjugate t))
  (assert-float-equal transpose matrix))
@

\section{Test Dense Matrix Scale}
\label{sec:dense-matrix-scale}

A single test is performed for scaling a dense matrix.
<<Test: Dense matrix scale>>=
(define-test dense-matrix-scale
  (assert-float-equal #2A(( 3.3  3.6  3.9  4.2)
                          ( 6.3  6.6  6.9  7.2)
                          ( 9.3  9.6  9.9 10.2)
                          (12.3 12.6 12.9 13.2)
                          (15.3 15.6 15.9 16.2))
                      (linear-algebra:scale
                       3.0 (linear-algebra:make-matrix
                            5 4 :initial-contents
                            #2A((1.1 1.2 1.3 1.4)
                                (2.1 2.2 2.3 2.4)
                                (3.1 3.2 3.3 3.4)
                                (4.1 4.2 4.3 4.4)
                                (5.1 5.2 5.3 5.4))))))

@ An additional test is performed for the destructive scale of a dense
matrix to verify that the matrix returned is [[EQ]] to the original.
<<Test: Destructive dense matrix scale>>=
(define-test dense-matrix-nscale
  (let ((matrix (linear-algebra:make-matrix
                 5 4 :initial-contents
                 #2A((1.1 1.2 1.3 1.4)
                     (2.1 2.2 2.3 2.4)
                     (3.1 3.2 3.3 3.4)
                     (4.1 4.2 4.3 4.4)
                     (5.1 5.2 5.3 5.4)))))
    (assert-eq matrix (linear-algebra:nscale 3.0 matrix))
    (assert-float-equal
     #2A(( 3.3  3.6  3.9  4.2)
         ( 6.3  6.6  6.9  7.2)
         ( 9.3  9.6  9.9 10.2)
         (12.3 12.6 12.9 13.2)
         (15.3 15.6 15.9 16.2))
     matrix)))

@

\section{Test Dense Matrix Product}
\label{sec:dense-matrix-product}

The implementation of [[product]] for dense matrices is tested for 4
cases. First, the type of the object returned is verified. Second, it
is verified with no keywords. Third, it is verified with the
[[:scalar]] keyword. Finally, it is verified that an error is
generated if the dimensions of the arguments are not compatible.
<<Test: Dense matrix product>>=
(define-test dense-matrix-product
  <<Row vector - dense matrix product>>
  <<Dense matrix - column vector product>>
  <<Dense matrix - matrix product>>)

@ The first group of tests cover a dense matrix pre-multiplied by a
row vector.
<<Row vector - dense matrix product>>=
;; Row vector - dense matrix
(assert-true
 (typep (linear-algebra:product
         (linear-algebra:row-vector 1.0 2.0 3.0)
         (unit-matrix 3 5))
        'linear-algebra:row-vector))
(assert-float-equal
 #(15.0 30.0 45.0)
 (linear-algebra:product
  (linear-algebra:row-vector 1.0 2.0 3.0 4.0 5.0)
  (linear-algebra:make-matrix
   5 3 :initial-contents
   #2A((1.0 2.0 3.0)
       (1.0 2.0 3.0)
       (1.0 2.0 3.0)
       (1.0 2.0 3.0)
       (1.0 2.0 3.0)))))
(assert-float-equal
 #(31.5 63.0 94.5)
 (linear-algebra:product
  (linear-algebra:row-vector 1.0 2.0 3.0 4.0 5.0)
  (linear-algebra:make-matrix
   5 3 :initial-contents
   #2A((1.0 2.0 3.0)
       (1.0 2.0 3.0)
       (1.0 2.0 3.0)
       (1.0 2.0 3.0)
       (1.0 2.0 3.0)))
  :scalar 2.1))
(assert-error
 'error
 (linear-algebra:product
  (linear-algebra:row-vector 1.0 2.0 3.0 4.0 5.0 6.0)
  (linear-algebra:make-matrix 5 3 :initial-element 1.0)))
@ The second group of tests cover a dense matrix multiplied with a
column vector.
<<Dense matrix - column vector product>>=
;; Dense matrix - column vector
(assert-true
 (typep (linear-algebra:product
         (unit-matrix 5 3)
         (linear-algebra:column-vector 1.0 2.0 3.0))
        'linear-algebra:column-vector))
(assert-float-equal
 #(15.0 30.0 45.0)
 (linear-algebra:product
  (linear-algebra:make-matrix
   3 5 :initial-contents
   #2A((1.0 1.0 1.0 1.0 1.0)
       (2.0 2.0 2.0 2.0 2.0)
       (3.0 3.0 3.0 3.0 3.0)))
  (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)))
(assert-float-equal
 #(31.5 63.0 94.5)
 (linear-algebra:product
  (linear-algebra:make-matrix
   3 5 :initial-contents
   #2A((1.0 1.0 1.0 1.0 1.0)
       (2.0 2.0 2.0 2.0 2.0)
       (3.0 3.0 3.0 3.0 3.0)))
  (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0)
  :scalar 2.1))
(assert-error
 'error
 (linear-algebra:product
  (linear-algebra:make-matrix 3 5 :initial-element 1.0)
  (linear-algebra:column-vector 1.0 2.0 3.0 4.0 5.0 6.0)))
@ The final group of tests cover a dense matrix multiplied by another
dense matrix.
<<Dense matrix - matrix product>>=
;; Dense matrix - matrix
(assert-true
 (typep (linear-algebra:product
         (unit-matrix 3 5) (unit-matrix 5 4))
        'linear-algebra:dense-matrix))
(assert-float-equal
 #2A((15.0 15.0 15.0 15.0)
     (30.0 30.0 30.0 30.0)
     (45.0 45.0 45.0 45.0))
 (linear-algebra:product
  (linear-algebra:make-matrix
   3 5 :initial-contents
   #2A((1.0 1.0 1.0 1.0 1.0)
       (2.0 2.0 2.0 2.0 2.0)
       (3.0 3.0 3.0 3.0 3.0)))
  (linear-algebra:make-matrix
   5 4 :initial-contents
   #2A((1.0 1.0 1.0 1.0)
       (2.0 2.0 2.0 2.0)
       (3.0 3.0 3.0 3.0)
       (4.0 4.0 4.0 4.0)
       (5.0 5.0 5.0 5.0)))))
(assert-float-equal
 #2A((31.5 31.5 31.5 31.5)
     (63.0 63.0 63.0 63.0)
     (94.5 94.5 94.5 94.5))
 (linear-algebra:product
  (linear-algebra:make-matrix
   3 5 :initial-contents
   #2A((1.0 1.0 1.0 1.0 1.0)
       (2.0 2.0 2.0 2.0 2.0)
       (3.0 3.0 3.0 3.0 3.0)))
  (linear-algebra:make-matrix
   5 4 :initial-contents
   #2A((1.0 1.0 1.0 1.0)
       (2.0 2.0 2.0 2.0)
       (3.0 3.0 3.0 3.0)
       (4.0 4.0 4.0 4.0)
       (5.0 5.0 5.0 5.0)))
  :scalar 2.1))
(assert-error
 'error
 (linear-algebra:product (unit-matrix 3 5) (unit-matrix 6 7)))
@ 

\chapter{Test Square Matrices}
\label{chap:test-square-matrices}

The tests for square matrices are identical to those for dense
matrices with the modification of the test data to have an equal
number of rows to columns.
<<square-matrix.lisp>>=
<<In linear algebra unit tests>>
<<Test: Make a square matrix>>
<<Test: Square matrix predicate>>
<<Test: Square matrix bounds predicate>>
<<Test: Square matrix element type>>
<<Test: Square matrix dimensions>>
<<Test: Square matrix row dimension>>
<<Test: Square matrix column dimension>>
<<Test: Square matrix element reference>>
<<Test: Copy a square matrix>>
<<Test: Subset of the square matrix>>
<<Test: Destructively replace a subset of the square matrix>>
<<Test: Square matrix validated range>>
@ The square matrix tests depend on the linear algebra test package
and the matrix test macros.
<<Square matrix dependencies>>=
(:file "square-matrix"
       :depends-on ("defpackage" "matrix"))
@

\section{Creating a Square Matrix Tests}
\label{sec:creating-square-matrix-tests}

For square matrices, [[make-matrix]] is tested for default
initialization, specifying the element type, specifying the initial
element, specifying the initial contents and two input errors. The
first error test verifies that unequal rows and columns generate an
error. The second error test verifies that an error is generated when
both the initial element and initial contents are specified.
<<Test: Make a square matrix>>=
(define-test make-square-matrix
  <<Make a default square matrix>>
  <<Specify the square matrix element type>>
  <<Specify the square matrix initial element>>
  <<Specify the square matrix initial contents>>
  <<Square matrix construction errors>>)

@ A square matrix with none of the other keywords specified should be
initialized with zero.
<<Make a default square matrix>>=
;; A default square matrix
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:square-matrix)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:square-matrix))
  (assert-rational-equal
   (make-array '(10 10) :initial-element 0)
   matrix))
@ Specifying the element type is verified for [[SINGLE-FLOAT]], but
further testing should be implemented.
<<Specify the square matrix element type>>=
;; Specify the square matrix element type
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:square-matrix
               :element-type 'single-float)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:square-matrix))
  (assert-eq (array-element-type
              (linear-algebra::contents matrix))
             (array-element-type
              (make-array '(10 10) :element-type 'single-float)))
  (assert-float-equal
   (make-array '(10 10) :initial-element 0.0
               :element-type 'single-float)
   matrix))
@ If a value other than zero is required, is specified with
[[:INITIAL-ELEMENT]].
<<Specify the square matrix initial element>>=
;; Specify the square matrix initial element
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:square-matrix
               :initial-element 1.0)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:square-matrix))
  (assert-float-equal
   (make-array '(10 10) :initial-element 1.0)
   matrix))
@ The initial contents can be initialized with a nested sequence or a
2D array. The sequence can be a nested list
<<Specify the square matrix initial contents>>=
;; Specify the square matrix contents - Nested list
(let* ((data '((1.1 1.2 1.3 1.4)
               (2.1 2.2 2.3 2.4)
               (3.1 3.2 3.3 3.4)
               (4.1 4.2 4.3 4.4))) 
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:square-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:square-matrix))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ or a nested vector.
<<Specify the square matrix initial contents>>=
;; Specify the square matrix contents - Nested vector
(let* ((data #(#(1.1 1.2 1.3 1.4)
               #(2.1 2.2 2.3 2.4)
               #(3.1 3.2 3.3 3.4)
               #(4.1 4.2 4.3 4.4)))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:square-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:square-matrix))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ Finally, the initial contents can be a 2D array.
<<Specify the square matrix initial contents>>=
;; Specify the square matrix contents - 2D array
(let* ((data (make-array '(4 4) :initial-contents
                         '((1.1 1.2 1.3 1.4)
                           (2.1 2.2 2.3 2.4)
                           (3.1 3.2 3.3 3.4)
                           (4.1 4.2 4.3 4.4))))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:square-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:square-matrix))
  (assert-float-equal data matrix))
@ A before method is implemented for initialization of a square matrix
that verifies that the number of rows is equal to the number of
columns. Otherwise, the error checking of the dense matrices is relied
upon.
<<Square matrix construction errors>>=
;; Erroneous 2D array input data
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:square-matrix
               :initial-contents
               #3A(((1.1 1.2) (2.1 2.2))
                   ((3.1 3.2) (4.1 4.2))
                   ((5.1 5.2) (6.1 6.2)))))
(assert-error 'error
              (linear-algebra:make-matrix
               3 4
               :matrix-type 'linear-algebra:square-matrix
               :initial-contents
               (coordinate-array 0 0 3 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               4 3
               :matrix-type 'linear-algebra:square-matrix
               :initial-contents
               (coordinate-array 0 0 4 3)))
(assert-error 'error
              (linear-algebra:make-matrix
               3 3 :element-type 'single-float
               :matrix-type 'linear-algebra:square-matrix
               :initial-contents
               #2A((1 2 3) (4 5 6) (7 8 9))))
@ As with arrays, it is an error to specify both the initial element
and the initial contents.
<<Square matrix construction errors>>=
;; Specify initial element and initial contents
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:square-matrix
               :initial-element 1.1
               :initial-contents
               (coordinate-array 0 0 4 4)))
@ 

\section{Test Square Matrix Predicates}
\label{sec:test-square-matrix-predicates}

The [[square-matrix-p]] function should return true if passed a square
matrix object.
<<Test: Square matrix predicate>>=
;;; Test the square matrix predicate
(define-test square-matrix-predicate
  (assert-true
   (linear-algebra:square-matrix-p
    (linear-algebra:make-matrix
     10 10 :matrix-type 'linear-algebra:square-matrix)))
  (assert-false
   (linear-algebra:square-matrix-p (make-array '(10 10)))))

@ The other square matrix predicate should return true for valid
indices.
<<Test: Square matrix bounds predicate>>=
;;; Test the square matrix bounds
(define-test square-matrix-in-bounds-p
  (test-matrix-in-bounds-p 'linear-algebra:square-matrix))

@ 

\section{Test Square Matrix Inspection}
\label{sec:test-square-matrix-inspection}

All square matrix inspection tests are generated from the matrix test
macros.
<<Test: Square matrix element type>>=
;;; Test the square matrix element type
(define-test square-matrix-element-type
  (test-matrix-element-type 'linear-algebra:square-matrix))

@ The matrix dimensions are tested using a 9x9 square matrix.
<<Test: Square matrix dimensions>>=
;;; Test the square matrix dimensions
(define-test square-matrix-dimensions
  (test-matrix-dimensions 'linear-algebra:square-matrix 9 9))

@ The matrix row dimension is tested for a value of 9.
<<Test: Square matrix row dimension>>=
;;; Test the square matrix row dimension
(define-test square-matrix-row-dimension
  (test-matrix-row-dimension 'linear-algebra:square-matrix 9 9))

@ Finally, the matrix column dimension is tested for a value of 9.
<<Test: Square matrix column dimension>>=
;;; Test the square matrix column dimension
(define-test square-matrix-column-dimension
  (test-matrix-column-dimension 'linear-algebra:square-matrix 9 9))

@ 

\section{Test Referencing Square Matrices}
\label{sec:test-referencing-square-matrices}

The four corners of the square matrix and a random interior point are
tested for equality against the input data.
<<Test: Square matrix element reference>>=
;;; Reference square matrix elements
(define-test square-matrix-mref
  (let* ((initial-contents
          '((1.1 1.2 1.3 1.4 1.5)
            (2.1 2.2 2.3 2.4 2.5)
            (3.1 3.2 3.3 3.4 3.5)
            (4.1 4.2 4.3 4.4 4.5)
            (5.1 5.2 5.3 5.4 5.5)))
         (rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (random-interior-index columns))
         (data (make-array
                (list rows columns)
                :initial-contents
                initial-contents))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:square-matrix
                  :initial-contents
                  initial-contents)))
    (assert-float-equal
     (aref data 0 0)
     (linear-algebra:mref matrix 0 0))
    (assert-float-equal
     (aref data 0 cend)
     (linear-algebra:mref matrix 0 cend))
    (assert-float-equal
     (aref data rend 0)
     (linear-algebra:mref matrix rend 0))
    (assert-float-equal
     (aref data rend cend)
     (linear-algebra:mref matrix rend cend))
    (assert-float-equal
     (aref data rowi coli)
     (linear-algebra:mref matrix rowi coli))))

@ Similarly, the four corners and a random interior point of a square
matrix are set and then compared with the original value.
<<Test: Square matrix element reference>>=
;;; Set square matrix elements
(define-test square-matrix-setf-mref
  (let* ((rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (random-interior-index columns))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type 'linear-algebra:square-matrix
                  :initial-contents
                  '((1.1 1.2 1.3 1.4 1.5)
                    (2.1 2.2 2.3 2.4 2.5)
                    (3.1 3.2 3.3 3.4 3.5)
                    (4.1 4.2 4.3 4.4 4.5)
                    (5.1 5.2 5.3 5.4 5.5)))))
    (destructuring-bind (val1 val2 val3 val4 val5)
        (make-random-list 5 1.0)
      (setf (linear-algebra:mref matrix 0 0)    val1)
      (setf (linear-algebra:mref matrix 0 cend) val2)
      (setf (linear-algebra:mref matrix rend 0) val3)
      (setf (linear-algebra:mref matrix rend cend) val4)
      (setf (linear-algebra:mref matrix rowi coli) val5)
      (assert-float-equal val1 (linear-algebra:mref matrix 0 0))
      (assert-float-equal val2 (linear-algebra:mref matrix 0 cend))
      (assert-float-equal val3 (linear-algebra:mref matrix rend 0))
      (assert-float-equal val4 (linear-algebra:mref matrix rend cend))
      (assert-float-equal val5 (linear-algebra:mref matrix rowi coli)))))

@ 

\section{Test Copying Square Matrices}
\label{sec:test-copying-square-matrices}

Three tests are performed on [[copy-matrix]] for square matrices. The
first test verifies that the matrix returned is not [[EQ]] to the
original matrix. The second test verifies that the contents are not
[[EQ]]. Finally, the elements are tested for equality.
<<Test: Copy a square matrix>>=
;;; Copy the square matrix
(define-test copy-square-matrix
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type 'linear-algebra:square-matrix
                 :initial-contents
                 (coordinate-array 0 0 5 5))))
    (assert-true
     (linear-algebra:square-matrix-p
      (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq matrix (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq (linear-algebra::contents matrix)
         (linear-algebra::contents
          (linear-algebra:copy-matrix matrix))))
    (assert-float-equal
     matrix (linear-algebra:copy-matrix matrix))))

@ 

\section{Testing Subsets of Square Matrices}
\label{sec:testing-square-matrix-subsets}

The subset of a square matrix is tested for 3 subsets and 6 errors.
<<Test: Subset of the square matrix>>=
;;; Test the submatrix of a square matrix
(define-test square-submatrix
  (let ((matrix (linear-algebra:make-matrix
                 10 10
                 :matrix-type
                 'linear-algebra:square-matrix
                 :initial-contents
                 (coordinate-array))))
    <<Subsets of a square matrix>>
    <<Invalid subsets of a square matrix>>))

@ The first subset is the entire matrix. The second subset is
specified with a start row and column. The final subset is for a fully
specified range.
<<Subsets of a square matrix>>=
;; The entire matrix
(assert-float-equal
 (coordinate-array)
 (linear-algebra:submatrix matrix 0 0))
;; Start row and column to the end
(assert-float-equal
 (coordinate-array 3 3)
 (linear-algebra:submatrix matrix 3 3))
;; End row and column
(assert-float-equal
 (coordinate-array 3 4 5 5)
 (linear-algebra:submatrix matrix 3 4 :row-end 5 :column-end 5))
@ The first 4 errors result from specifying the start row, start
column, end row or end column in excess of the dimensions. The last 2
errors result from the start row exceeding the end row or the start
column exceeding the end column.
<<Invalid subsets of a square matrix>>=
;; Start row exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 11 5))
;; Start column exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 11))
;; End row exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :row-end 11))
;; End column exceeds dimensions
(assert-error 'error (linear-algebra:submatrix matrix 5 5 :column-end 11))
;; Start row exceeds end row
(assert-error 'error (linear-algebra:submatrix matrix 7 7 :row-end 6))
;; Start column exceeds end column
(assert-error 'error (linear-algebra:submatrix matrix 7 7 :column-end 6))
@

A submatrix of a square matrix is settable. Testing is performed
considering 5 basic submatrices. The test of each submatrix is
performed for multiple ranges to verify that the minimum size range is
set based on the size of the matrices as well as the specified ranges.
The [[(setf submatrix)]] function returns the data, not the modified
matrix.  The testing, though, needs to verify that the modified
matrix. A local macro, therefore, is used to set the submatrix and
return the modified matrix. This macro relies on symbol capture and is
therefore not generally usable. The symbol [[matrix]] must be the
matrix argument to the submatrix form.
<<Test: Subset of the square matrix>>=
;;; Set the submatrix of a square matrix
(define-test setf-square-submatrix
  <<Set the upper left submatrix of the square matrix>>
  <<Set the upper right submatrix of the square matrix>>
  <<Set the lower left submatrix of the square matrix>>
  <<Set the lower right submatrix of the square matrix>>
  <<Set the middle submatrix of the square matrix>>)

@ The first submatrix for testing is the upper left submatrix. The
result of this test should be a 5x5 matrix, initially all zeroes, with
the upper left 2x2 submatrix set to ones.
<<Set the upper left submatrix of the square matrix>>=
;; Upper left submatrix
(let ((array-ul (make-array
                 '(5 5) :initial-contents
                 '((1 1 0 0 0)
                   (1 1 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)))))
  (assert-rational-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 0 0)
    (unit-matrix 2 2)))
  (assert-rational-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 0 0 :row-end 2 :column-end 2)
    (linear-algebra:submatrix (unit-matrix 5 5) 0 0)))
  (assert-rational-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 0 0)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 0 0 :row-end 2 :column-end 2)))
  (assert-rational-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 0 0 :row-end 2 :column-end 2)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 2 2 :row-end 4 :column-end 4))))
@ The next submatrix is the upper right submatrix. The result of this
test is also a 5x5 matrix, initially all zeroes, with the upper right
2x2 submatrix set to ones.
<<Set the upper right submatrix of the square matrix>>=
;; Upper right submatrix
(let ((array-ur (make-array
                 '(5 5) :initial-contents
                 '((0 0 0 1 1)
                   (0 0 0 1 1)
                   (0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)))))
  (assert-rational-equal
   array-ur
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 0 3)
    (unit-matrix 2 2)))
  (assert-rational-equal
   array-ur
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 0 3)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 0 3 :row-end 2 :column-end 5)))
  (assert-rational-equal
   array-ur
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 0 3 :row-end 2 :column-end 5)
    (unit-matrix 5 5)))
  (assert-rational-equal
   array-ur
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 0 3 :row-end 2 :column-end 5)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 2 2 :row-end 4 :column-end 4))))
@ The third submatrix is the lower left submatrix. Again, the result
is a 5x5 matrix, initially all zeroes, with the lower left 2x2
submatrix set to ones.
<<Set the lower left submatrix of the square matrix>>=
;; Lower left submatrix
(let ((array-ll (make-array
                 '(5 5) :initial-contents
                 '((0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)
                   (1 1 0 0 0)
                   (1 1 0 0 0)))))
  (assert-rational-equal
   array-ll
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 3 0)
    (unit-matrix 2 2)))
  (assert-rational-equal
   array-ll
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 3 0)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 0 3 :row-end 2 :column-end 5)))
  (assert-rational-equal
   array-ll
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 3 0 :row-end 5 :column-end 2)
    (unit-matrix 5 5)))
  (assert-rational-equal
   array-ll
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 3 0 :row-end 5 :column-end 2)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 2 2 :row-end 4 :column-end 4))))
@ Only the lower right corner remains.
<<Set the lower right submatrix of the square matrix>>=
;; Lower right submatrix
(let ((array-lr (make-array
                 '(5 5)
                 :initial-contents
                 '((0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 0 0)
                   (0 0 0 1 1)
                   (0 0 0 1 1)))))
  (assert-rational-equal
   array-lr
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 3 3)
    (unit-matrix 2 2)))
  (assert-rational-equal
   array-lr
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 3 3)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 0 3 :row-end 2 :column-end 5)))
  (assert-rational-equal
   array-lr
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 3 3 :row-end 5 :column-end 5)
    (unit-matrix 5 5)))
  (assert-rational-equal
   array-lr
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 3 3 :row-end 5 :column-end 5)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 2 2 :row-end 4 :column-end 4))))
@ The final test is for the middle of the matrix. As before, the
result is a 5x5 matrix initially all zeroes. But in this case, the
middle 3x3 submatrix is set to ones.
<<Set the middle submatrix of the square matrix>>=
;; Middle submatrix
(let ((array-mid (make-array
                  '(5 5)
                  :initial-contents
                  '((0 0 0 0 0)
                    (0 1 1 1 0)
                    (0 1 1 1 0)
                    (0 1 1 1 0)
                    (0 0 0 0 0)))))
  (assert-rational-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 1 1)
    (unit-matrix 3 3)))
  (assert-rational-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 1 1)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 1 1 :row-end 4 :column-end 4)))
  (assert-rational-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 1 1 :row-end 4 :column-end 4)
    (unit-matrix 5 5)))
  (assert-rational-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:square-matrix
    (linear-algebra:submatrix matrix 1 1 :row-end 4 :column-end 4)
    (linear-algebra:submatrix
     (unit-matrix 5 5) 1 1 :row-end 4 :column-end 4))))
@ 

The final function in the matrix interface is the [[replace-matrix]]
function. The testing covers 4 types of replacement: replacing the
entire matrix, replacing the first 2 rows, replacing the first 3
columns and replace a center portion.
<<Test: Destructively replace a subset of the square matrix>>=
;;; Replace all or part of a square matrix
(define-test square-matrix-replace
  <<Replace the entire square matrix>>
  <<Replace the first 2 rows of the square matrix>>
  <<Replace the first 3 columns of the square matrix>>
  <<Replace the center of the square matrix>>)

@ The first test is a single test that replaces every element of the
first matrix with the second.
<<Replace the entire square matrix>>=
;; Replace the entire matrix
(assert-rational-equal
 (unit-matrix 5 5)
 (linear-algebra:replace-matrix
  (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
  (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)))
@ The second group of tests replaces the first 2 rows of the matrix.
The test is repeated to test applicable keyword arguments.
<<Replace the first 2 rows of the square matrix>>=
;; Replace the first 2 rows
(let ((result (make-array
               '(5 5)
               :initial-contents
               '((1 1 1 1 1)
                 (1 1 1 1 1)
                 (0 0 0 0 0)
                 (0 0 0 0 0)
                 (0 0 0 0 0)))))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 2 5)))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 2 7)))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :row2 3))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :row1-end 2))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :row2-end 2)))
@ The third group of tests replaces the first 3 columns of the
matrix. The test is repeated to test applicable keyword arguments.
<<Replace the first 3 columns of the square matrix>>=
;; Replace the first 3 columns
(let ((result (make-array
               '(5 5)
               :initial-contents
               '((1 1 1 0 0)
                 (1 1 1 0 0)
                 (1 1 1 0 0)
                 (1 1 1 0 0)
                 (1 1 1 0 0)))))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 3)))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 7 3)))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :column2 2))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :column1-end 3))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :column2-end 3)))
@ The final group of tests replaces the center elements of the matrix.
As before, the test is repeated for various combinations of applicable
keywords.
<<Replace the center of the square matrix>>=
;; Replace the center
(let ((result (make-array
               '(5 5)
               :initial-contents
               '((0 0 0 0 0)
                 (0 1 1 1 0)
                 (0 1 1 1 0)
                 (0 1 1 1 0)
                 (0 0 0 0 0)))))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 3 3 :matrix-type 'linear-algebra:square-matrix)
    :row1 1 :column1 1))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :row1 1 :column1 1
    :row1-end 4 :column1-end 4))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :row1 1 :column1 1
    :row2-end 3 :column2-end 3))
  (assert-rational-equal
   result
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    (unit-matrix 5 5 :matrix-type 'linear-algebra:square-matrix)
    :row1 1 :column1 1
    :row2 2 :column2 2)))
@ 

The final group of tests is generated by the macro
[[test-matrix-validated-range]] for the square matrix object.
<<Test: Square matrix validated range>>=
;;; Validate a range for a square matrix.
(define-test square-matrix-validated-range
  (test-matrix-validated-range
   'linear-algebra:square-matrix 10 10))
@ 

\chapter{Hermitian Matrix}
\label{chap:hermitian-matrix}

<<hermitian-matrix.lisp>>=
<<In linear algebra unit tests>>
<<Function: Make a Hermitian matrix>>
<<Function: Make a unit Hermitian matrix>>
<<Test: Make a Hermitian matrix>>
<<Test: Hermitian matrix predicate>>
<<Test: Hermitian matrix bounds predicate>>
<<Test: Hermitian matrix element type>>
<<Test: Hermitian matrix dimensions>>
<<Test: Hermitian matrix row dimension>>
<<Test: Hermitian matrix column dimension>>
<<Test: Hermitian matrix element reference>>
<<Test: Copy a Hermitian matrix>>
<<Test: Subset of the Hermitian matrix>>
<<Test: Destructively replace a subset of the Hermitian matrix>>
<<Test: Hermitian matrix validated range>>
@ The hermitian matrix tests depend on the linear algebra test package
and the matrix test macros.
<<Hermitian matrix dependencies>>=
(:file "hermitian-matrix"
       :depends-on ("defpackage" "matrix"))
@ A function that creates a Hermitian matrix is defined as a
convenience for the [[(setf submatrix)]] and [[replace-matrix]] unit
tests. The Hermitian matrix is composed of elements that represent the
coordinates of the matrix, one indexed.
<<Function: Make a Hermitian matrix>>=
(defun hermitian-matrix (&optional (start 0) (end 10))
  (linear-algebra:make-matrix
   (- end start) (- end start)
   :matrix-type 'linear-algebra:hermitian-matrix
   :initial-contents (hermitian-array start end)))

@ Another convenience function is used to create a unit Hermitian
matrix. It is required since a Hermitian matrix is cannot strictly be
a unit matrix.
<<Function: Make a unit Hermitian matrix>>=
(defun unit-hermitian-matrix (size)
  "Return a ROWSxCOLUMNS unit Hermitian matrix."
  (linear-algebra:make-matrix
   size size
   :matrix-type 'linear-algebra:hermitian-matrix
   :initial-contents
   (let ((init (make-array (list size size))))
     (dotimes (i0 size init)
       (setf (aref init i0 i0) #C(1 0))
       (dotimes (i1 i0)
         (setf
          (aref init i0 i1) #C(1 -1)
          (aref init i1 i0) #C(1  1)))))))

@ 

\section{Creating a Hermitian Matrix Tests}
\label{sec:creating-hermitian-matrix-tests}

Creating a Hermitian matrix is tested for default construction,
specifying initial element type and specifying initial contents. It is
an error to specify a complex value for the initial element.
<<Test: Make a Hermitian matrix>>=
(define-test make-hermitian-matrix
  <<Specify a default Hermitian matrix>>
  <<Specify the Hermitian matrix element type>>
  <<Specify the Hermitian matrix initial contents>>
  ;; Errors
  <<Hermitian matrix construction errors>>)

@ A Hermitian matrix is populated with zeroes by default.
<<Specify a default Hermitian matrix>>=
;; A default Hermitian matrix
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:hermitian-matrix)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:hermitian-matrix))
  (assert-rational-equal
   (make-array '(10 10) :initial-element 0)
   matrix))
@ Array specialization on complex values usually is only implemented
for floating point components. So specifying the element type is
tested for [[(complex single-float)]].
<<Specify the Hermitian matrix element type>>=
;; Specify the Hermitian matrix element type
(let* ((data '((#C(1.0  0.0) #C(1.0  2.0) #C(1.0 3.0))
               (#C(1.0 -2.0) #C(2.0  0.0) #C(2.0 3.0))
               (#C(1.0 -3.0) #C(2.0 -3.0) #C(3.0 0.0))))
       (matrix (linear-algebra:make-matrix
                3 3
                :matrix-type 'linear-algebra:hermitian-matrix
                :element-type '(complex single-float)
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:hermitian-matrix))
  (assert-eq (array-element-type
              (linear-algebra::contents matrix))
             (array-element-type
              (make-array '(3 3) :element-type '(complex single-float)
                          :initial-contents data)))
  (assert-float-equal
   (make-array '(3 3) :element-type '(complex single-float)
               :initial-contents data)
   matrix))
@ The initial contents can be initialized with a nested sequence or a
2D array. The sequence can be a nested list
<<Specify the Hermitian matrix initial contents>>=
;; Specify the Hermitian matrix contents - Nested list
(let* ((data '((#C(1  0) #C(1  2) #C(1  3) #C(1 4))
               (#C(1 -2) #C(2  0) #C(2  3) #C(2 4))
               (#C(1 -3) #C(2 -3) #C(3  0) #C(3 4))
               (#C(1 -4) #C(2 -4) #C(3 -4) #C(4 0))))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:hermitian-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:hermitian-matrix))
  (assert-rational-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ or a nested vector.
<<Specify the Hermitian matrix initial contents>>=
;; Specify the Hermitian matrix contents - Nested vector
(let* ((data #(#(#C(1  0) #C(1  2) #C(1  3) #C(1 4))
               #(#C(1 -2) #C(2  0) #C(2  3) #C(2 4))
               #(#C(1 -3) #C(2 -3) #C(3  0) #C(3 4))
               #(#C(1 -4) #C(2 -4) #C(3 -4) #C(4 0))))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:hermitian-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:hermitian-matrix))
  (assert-rational-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ Finally, the initial contents can be a 2D array.
<<Specify the Hermitian matrix initial contents>>=
;; Specify the Hermitian matrix contents - 2D array
(let* ((data (make-array '(4 4) :initial-contents
                         '((#C(1  0) #C(1  2) #C(1  3) #C(1 4))
                           (#C(1 -2) #C(2  0) #C(2  3) #C(2 4))
                           (#C(1 -3) #C(2 -3) #C(3  0) #C(3 4))
                           (#C(1 -4) #C(2 -4) #C(3 -4) #C(4 0)))))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:hermitian-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:hermitian-matrix))
  (assert-rational-equal data matrix))
@ It is an error to make a Hermitian matrix with a complex initial
element.
<<Hermitian matrix construction errors>>=
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:hermitian-matrix
               :initial-contents #C(1 2)))
@ The Hermitian matrix initialization methods inherit the before
method of a square matrix that verifies that the number of rows is
equal to the number of columns.
<<Hermitian matrix construction errors>>=
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:hermitian-matrix
               :initial-contents
               #3A(((#C(1 0) #C(1 2)) (#C(2 1) #C(2 2)))
                   ((#C(3 1) #C(3 2)) (#C(4 1) #C(4 2)))
                   ((#C(5 1) #C(5 2)) (#C(6 1) #C(6 2))))))
(assert-error 'error
              (linear-algebra:make-matrix
               3 4
               :matrix-type 'linear-algebra:hermitian-matrix
               :initial-contents
               (hermitian-array 0 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               4 3
               :matrix-type 'linear-algebra:hermitian-matrix
               :initial-contents
               (hermitian-array 0 4)))
@ A further stipulation on the intialization data for a Hermitian
matrix is that it must be Hermitian.
<<Hermitian matrix construction errors>>=
(assert-error 'error
              (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-contents
               (coordinate-array 0 0 5 5)))
@ As with arrays, it is an error to specify both the initial element
and the initial contents.
<<Hermitian matrix construction errors>>=
;; Specify initial element and initial contents
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:hermitian-matrix
               :initial-element 1.1
               :initial-contents
               (hermitian-array 0 4)))
@ 

\section{Test Hermitian Matrix Predicates}
\label{sec:test-hermitian-matrix-predicates}

The [[hermitian-matrix-p]] function should return true if passed a
hermitian matrix object.
<<Test: Hermitian matrix predicate>>=
;;; Test the hermitian matrix predicate
(define-test hermitian-matrix-predicate
  (assert-true
   (linear-algebra:hermitian-matrix-p
    (linear-algebra:make-matrix
     10 10 :matrix-type 'linear-algebra:hermitian-matrix
     :initial-contents (hermitian-array))))
  (assert-false
   (linear-algebra:hermitian-matrix-p (make-array '(10 10)))))

@ The other hermitian matrix predicate should return true for valid
indices.
<<Test: Hermitian matrix bounds predicate>>=
;;; Test the hermitian matrix bounds
(define-test hermitian-matrix-in-bounds-p
  (test-matrix-in-bounds-p 'linear-algebra:hermitian-matrix
                           (hermitian-array)))

@ 

\section{Test Hermitian Matrix Inspection}
\label{sec:test-hermitian-matrix-inspection}

All hermitian matrix inspection tests are generated from the matrix test
macros.
<<Test: Hermitian matrix element type>>=
;;; Test the hermitian matrix element type
(define-test hermitian-matrix-element-type
  (let ((numeric-types
         '(integer fixnum
           short-float single-float double-float long-float)))
    (dolist (ntype numeric-types)
      (assert-true
       (subtypep
        (linear-algebra:matrix-element-type
         (linear-algebra:make-matrix
          2 2 :matrix-type 'linear-algebra:hermitian-matrix
          :element-type `(complex ,ntype)
          :initial-contents
          (list (list (complex (coerce 1 ntype) (coerce  0 ntype))
                      (complex (coerce 1 ntype) (coerce  1 ntype)))
                (list (complex (coerce 1 ntype) (coerce -1 ntype))
                      (complex (coerce 1 ntype) (coerce  0 ntype))))))
        (upgraded-array-element-type `(complex ,ntype)))))))

@ The matrix dimensions are tested using a 10x10 hermitian matrix.
<<Test: Hermitian matrix dimensions>>=
;;; Test the hermitian matrix dimensions
(define-test hermitian-matrix-dimensions
  (assert-equal
   (list 10 10)
   (linear-algebra:matrix-dimensions
    (linear-algebra:make-matrix
     10 10 :matrix-type 'linear-algebra:hermitian-matrix
     :initial-contents (hermitian-array)))))

@ The matrix row dimension is tested for a value of 10.
<<Test: Hermitian matrix row dimension>>=
;;; Test the hermitian matrix row dimension
(define-test hermitian-matrix-row-dimension
  (assert-eq
   10
   (linear-algebra:matrix-row-dimension
    (linear-algebra:make-matrix
     10 10 :matrix-type 'linear-algebra:hermitian-matrix
     :initial-contents (hermitian-array)))))

@ Finally, the matrix column dimension is tested for a value of 10.
<<Test: Hermitian matrix column dimension>>=
;;; Test the hermitian matrix column dimension
(define-test hermitian-matrix-column-dimension
  (assert-eq
   10
   (linear-algebra:matrix-column-dimension
    (linear-algebra:make-matrix
     10 10 :matrix-type 'linear-algebra:hermitian-matrix
     :initial-contents (hermitian-array)))))

@ 

\section{Test Referencing Hermitian Matrices}
\label{sec:test-referencing-hermitian-matrices}

The four corners of the hermitian matrix and a random interior point
are tested for equality against the input data. Additionally, the
transpose elements are tested for equality.
<<Test: Hermitian matrix element reference>>=
;;; Reference hermitian matrix elements
(define-test hermitian-matrix-mref
  (let* ((initial-contents
          '((#C(1  0) #C(1  2) #C(1  3) #C(1  4) #C(1 5))
            (#C(1 -2) #C(2  0) #C(2  3) #C(2  4) #C(2 5))
            (#C(1 -3) #C(2 -3) #C(3  0) #C(3  4) #C(3 5))
            (#C(1 -4) #C(2 -4) #C(3 -4) #C(4  0) #C(4 5))
            (#C(1 -5) #C(2 -5) #C(3 -5) #C(4 -5) #C(5 0))))
         (rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random-interior-index columns)
                        (random-interior-index columns)))
                   ((/= i0 rowi) i0)))
         (data (make-array
                (list rows columns)
                :initial-contents
                initial-contents))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:hermitian-matrix
                  :initial-contents
                  initial-contents)))
    (assert-rational-equal
     (aref data 0 0)
     (linear-algebra:mref matrix 0 0))
    (assert-rational-equal
     (aref data 0 cend)
     (linear-algebra:mref matrix 0 cend))
    (assert-rational-equal
     (aref data rend 0)
     (linear-algebra:mref matrix rend 0))
    (assert-rational-equal
     (linear-algebra:mref matrix 0 cend)
     (conjugate
      (linear-algebra:mref matrix rend 0)))
    (assert-rational-equal
     (aref data rend cend)
     (linear-algebra:mref matrix rend cend))
    (assert-rational-equal
     (aref data rowi coli)
     (linear-algebra:mref matrix rowi coli))
    (assert-rational-equal
     (linear-algebra:mref matrix rowi coli)
     (conjugate
      (linear-algebra:mref matrix coli rowi)))))

@ Similarly, the four corners and a random interior point of a
hermitian matrix are set and then compared with the original value.
<<Test: Hermitian matrix element reference>>=
;;; Set hermitian matrix elements
(define-test hermitian-matrix-setf-mref
  (let* ((rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random-interior-index columns)
                        (random-interior-index columns)))
                   ((/= i0 rowi) i0)))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type 'linear-algebra:hermitian-matrix
                  :initial-contents
                  '((#C(1  0) #C(1  2) #C(1  3) #C(1  4) #C(1 5))
                    (#C(1 -2) #C(2  0) #C(2  3) #C(2  4) #C(2 5))
                    (#C(1 -3) #C(2 -3) #C(3  0) #C(3  4) #C(3 5))
                    (#C(1 -4) #C(2 -4) #C(3 -4) #C(4  0) #C(4 5))
                    (#C(1 -5) #C(2 -5) #C(3 -5) #C(4 -5) #C(5 0))))))
    (multiple-value-bind (val1 val2 val3 val4)
        (values #C(6 0) (complex-random #C(5 5))
                #C(7 0) (complex-random #C(5 5)))
      (setf (linear-algebra:mref matrix 0 0)       val1)
      (setf (linear-algebra:mref matrix 0 cend)    val2)
      (setf (linear-algebra:mref matrix rend cend) val3)
      (setf (linear-algebra:mref matrix rowi coli) val4)
      (assert-rational-equal val1 (linear-algebra:mref matrix 0 0))
      (assert-rational-equal val2 (linear-algebra:mref matrix 0 cend))
      (assert-rational-equal val2 (conjugate
                                   (linear-algebra:mref matrix rend 0)))
      (assert-rational-equal val3 (linear-algebra:mref matrix rend cend))
      (assert-rational-equal val4 (linear-algebra:mref matrix rowi coli))
      (assert-rational-equal val4 (conjugate
                                   (linear-algebra:mref matrix coli rowi))))))

@ 

\section{Test Copying Hermitian Matrices}
\label{sec:test-copying-hermitian-matrices}

Three tests are performed on [[copy-matrix]] for hermitian matrices.
The first test verifies that the matrix returned is not [[EQ]] to the
original matrix. The second test verifies that the contents are not
[[EQ]]. Finally, the elements are tested for equality.
<<Test: Copy a Hermitian matrix>>=
;;; Copy the Hermitian matrix
(define-test copy-hermitian-matrix
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type 'linear-algebra:hermitian-matrix
                 :initial-contents
                 (hermitian-array 0 5))))
    (assert-true
     (linear-algebra:hermitian-matrix-p
      (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq matrix (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq (linear-algebra::contents matrix)
         (linear-algebra::contents
          (linear-algebra:copy-matrix matrix))))
    (assert-rational-equal
     matrix (linear-algebra:copy-matrix matrix))))

@ 

\section{Testing Subsets of Hermitian Matrices}
\label{sec:testing-hermitian-matrix-subsets}

The subset of a Hermitian matrix is tested for 3 subsets and 6 errors.
<<Test: Subset of the Hermitian matrix>>=
;;; Test the submatrix of a Hermitian matrix
(define-test hermitian-submatrix
  (let ((matrix (linear-algebra:make-matrix
                 10 10
                 :matrix-type 'linear-algebra:hermitian-matrix
                 :initial-contents (hermitian-array)))
        (submat (linear-algebra:make-matrix
                 10 10
                 :matrix-type 'linear-algebra:dense-matrix
                 :initial-contents (hermitian-array))))
    <<Subsets of a Hermitian matrix>>
    <<Invalid subsets of a Hermitian matrix>>))

@ The first subset is the entire matrix. The second subset is
specified with a start row and column. The final subset is for a fully
specified range.
<<Subsets of a Hermitian matrix>>=
;; The entire matrix
(assert-rational-equal
 (hermitian-array)
 (linear-algebra:submatrix matrix 0 0))
;; Start row and column to the end
(assert-rational-equal
 (hermitian-array 3)
 (linear-algebra:submatrix matrix 3 3))
;; End row and column
(assert-rational-equal
 (hermitian-array 3 5)
 (linear-algebra:submatrix
  matrix 3 3 :row-end 5 :column-end 5))
;; Submatrix is a general matrix
(assert-true
 (typep (linear-algebra:submatrix matrix 1 2)
        'linear-algebra:dense-matrix))
(assert-rational-equal
 (linear-algebra:submatrix submat 1 2)
 (linear-algebra:submatrix matrix 1 2))
(assert-true
 (typep (linear-algebra:submatrix matrix 1 1 :row-end 5)
        'linear-algebra:dense-matrix))
(assert-rational-equal
 (linear-algebra:submatrix submat 1 1 :row-end 5)
 (linear-algebra:submatrix matrix 1 1 :row-end 5))
(assert-true
 (typep (linear-algebra:submatrix matrix 1 1 :column-end 8)
        'linear-algebra:dense-matrix))
(assert-rational-equal
 (linear-algebra:submatrix submat 1 1 :column-end 8)
 (linear-algebra:submatrix matrix 1 1 :column-end 8))
@ The first 4 errors result from specifying the start row, start
column, end row or end column in excess of the dimensions. The last 2
errors result from the start row exceeding the end row or the start
column exceeding the end column.
<<Invalid subsets of a Hermitian matrix>>=
;; Start row exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 11 5))
;; Start column exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 11))
;; End row exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 5 :row-end 11))
;; End column exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 5 :column-end 11))
;; Start row exceeds end row
(assert-error
 'error (linear-algebra:submatrix matrix 7 7 :row-end 6))
;; Start column exceeds end column
(assert-error
 'error (linear-algebra:submatrix matrix 7 7 :column-end 6))
@

A submatrix of a Hermitian matrix is settable with restrictions.
Because a Hermitian matrix must be initialized with contents, the
[[setf-submatrix]] macro is locally overridden.
<<Test: Subset of the Hermitian matrix>>=
;;; Set the submatrix of a Hermitian matrix
(define-test setf-hermitian-submatrix
  (macrolet ((setf-submatrix (size submatrix-form data-form)
               (let ((matrix (second submatrix-form)))
                 `(let ((,matrix (unit-hermitian-matrix ,size)))
                   (setf ,submatrix-form ,data-form)
                   ,matrix))))
    <<Set the upper left submatrix of the Hermitian matrix>>
    <<Set the lower right submatrix of the Hermitian matrix>>
    <<Set the middle submatrix of the Hermitian matrix>>
    <<Set the off-diagonal submatrix of the Hermitian matrix>>)
  <<Verify that a non-Hermitian matrix is an error>>)

@ The first submatrix for testing is the upper left submatrix. The
result of this test should be a 5x5 Hermitian matrix, initially all
$(1,1)$, with the upper left 3x3 submatrix set to Hermitian contents.
<<Set the upper left submatrix of the Hermitian matrix>>=
;; Upper left submatrix
(let ((array-ul
       (make-array
        '(5 5) :initial-contents
        '((#C(1  0) #C(2  1) #C(3  1) #C(1  1) #C(1 1))
          (#C(2 -1) #C(2  0) #C(3  2) #C(1  1) #C(1 1))
          (#C(3 -1) #C(3 -2) #C(3  0) #C(1  1) #C(1 1))
          (#C(1 -1) #C(1 -1) #C(1 -1) #C(1  0) #C(1 1))
          (#C(1 -1) #C(1 -1) #C(1 -1) #C(1 -1) #C(1 0))))))
  (assert-rational-equal
   array-ul
   (setf-submatrix 5
                   (linear-algebra:submatrix matrix 0 0)
                   (hermitian-matrix 0 3)))
  (assert-rational-equal
   array-ul
   (setf-submatrix 5
                   (linear-algebra:submatrix
                    matrix 0 0 :row-end 3 :column-end 3)
                   (hermitian-matrix))))
@ The next submatrix is the lower right submatrix. The result of this
test is also a 5x5 matrix, initially all $(1,1)$, with the lower right
3x3 submatrix set to Hermitian values.
<<Set the lower right submatrix of the Hermitian matrix>>=
;; Lower right submatrix
(assert-rational-equal
 (make-array
  '(5 5) :initial-contents
  '((#C(1  0) #C(1  1) #C(1  1) #C(1  1) #C(1 1))
    (#C(1 -1) #C(1  0) #C(1  1) #C(1  1) #C(1 1))
    (#C(1 -1) #C(1 -1) #C(1  0) #C(2  1) #C(3 1))
    (#C(1 -1) #C(1 -1) #C(2 -1) #C(2  0) #C(3 2))
    (#C(1 -1) #C(1 -1) #C(3 -1) #C(3 -2) #C(3 0))))
 (setf-submatrix 5
                 (linear-algebra:submatrix matrix 2 2)
                 (hermitian-matrix)))
@ The third set of tests is for the middle of the matrix. As before,
the result is a 5x5 matrix initially all $(1,1)$. But in this case,
the middle 3x3 submatrix is set to Hermitian values.
<<Set the middle submatrix of the Hermitian matrix>>=
;; Middle submatrix
(let ((array-mid
       (make-array
        '(5 5) :initial-contents
        '((#C(1  0) #C(1  1) #C(1  1) #C(1  1) #C(1 1))
          (#C(1 -1) #C(2  0) #C(3  2) #C(4  2) #C(1 1))
          (#C(1 -1) #C(3 -2) #C(3  0) #C(4  3) #C(1 1))
          (#C(1 -1) #C(4 -2) #C(4 -3) #C(4  0) #C(1 1))
          (#C(1 -1) #C(1 -1) #C(1 -1) #C(1 -1) #C(1 0))))))
  (assert-rational-equal
   array-mid
   (setf-submatrix 5
                   (linear-algebra:submatrix matrix 1 1)
                   (hermitian-matrix 1 4)))
  (assert-rational-equal
   array-mid
   (setf-submatrix 5
                   (linear-algebra:submatrix
                    matrix 1 1 :row-end 4 :column-end 4)
                   (hermitian-matrix 1))))
@ The fourth set of tests cover setting off-diagonal submatrices.
<<Set the off-diagonal submatrix of the Hermitian matrix>>=
;; Off diagonal submatrix
(let ((array-off
       (make-array
        '(5 5) :initial-contents
        '((#C(1  0) #C(1  1) #C(1  1) #C(1  1) #C(1 2))
          (#C(1 -1) #C(1  0) #C(1  1) #C(2  1) #C(2 2))
          (#C(1 -1) #C(1 -1) #C(1  0) #C(1  1) #C(1 1))
          (#C(1 -1) #C(2 -1) #C(1 -1) #C(1  0) #C(1 1))
          (#C(1 -2) #C(2 -2) #C(1 -1) #C(1 -1) #C(1 0)))))
      (submatrix (linear-algebra:make-matrix
                  3 3 :initial-contents
                  '((#C(1 1) #C(1 2) #C(1 3))
                    (#C(2 1) #C(2 2) #C(2 3))
                    (#C(3 1) #C(3 2) #C(3 3))))))
  (assert-rational-equal
   array-off
   (setf-submatrix
    5 (linear-algebra:submatrix matrix 0 3)
    (linear-algebra:submatrix
     submatrix 0 0 :row-end 2 :column-end 2)))
  (assert-rational-equal
   array-off
   (setf-submatrix
    5 (linear-algebra:submatrix matrix 0 3 :row-end 2)
    submatrix)))
(let ((array-off
       (make-array
        '(5 5) :initial-contents
        '((#C(1  0) #C(1  1) #C(1  1) #C(1  1) #C(2 1))
          (#C(1 -1) #C(1  0) #C(1  1) #C(1  2) #C(2 2))
          (#C(1 -1) #C(1 -1) #C(1  0) #C(1  1) #C(1 1))
          (#C(1 -1) #C(1 -2) #C(1 -1) #C(1  0) #C(1 1))
          (#C(2 -1) #C(2 -2) #C(1 -1) #C(1 -1) #C(1 0)))))
      (submatrix (linear-algebra:make-matrix
                  3 3 :initial-contents
                  '((#C(1 -1) #C(1 -2) #C(1 -3))
                    (#C(2 -1) #C(2 -2) #C(2 -3))
                    (#C(3 -1) #C(3 -2) #C(3 -3))))))
  (assert-rational-equal
   array-off
   (setf-submatrix 5
                   (linear-algebra:submatrix matrix 3 0 :column-end 2)
                   submatrix))
  (assert-rational-equal
   array-off
   (setf-submatrix 5
                   (linear-algebra:submatrix matrix 3 0)
                   (linear-algebra:submatrix submatrix 0 0 :column-end 2))))
@ Finally, it is verified that an error is generated when the range
and data result in a non-Hermitian matrix.
<<Verify that a non-Hermitian matrix is an error>>=
;; Non-Hermitian subsets
(assert-error
 'error
 (setf (linear-algebra:submatrix
        (unit-hermitian-matrix 10) 0 1)
       (unit-matrix 5 3)))
@

The final function in the matrix interface is the [[replace-matrix]]
function. For a Hermitian matrix, it is tested for the same basic
behavior as [[(setf submatrix)]].
<<Test: Destructively replace a subset of the Hermitian matrix>>=
;;; Replace all or part of a Hermitian matrix
(define-test hermitian-matrix-replace
  <<Replace the entire Hermitian matrix>>
  <<Replace the upper left submatrix of the Hermitian matrix>>
  <<Replace the lower right submatrix of the Hermitian matrix>>
  <<Replace the middle submatrix of the Hermitian matrix>>
  <<Replace the off-diagonal submatrix of the Hermitian matrix>>
  <<Verify that a non-Hermitian replacement is an error>>)

@ The first test is a single test that replaces every element of the
first matrix with the second.
<<Replace the entire Hermitian matrix>>=
;; Replace the entire matrix
(assert-rational-equal
 (hermitian-matrix)
 (linear-algebra:replace-matrix
  (unit-hermitian-matrix 10)
  (hermitian-matrix)))
@ The second group of tests replaces the upper left submatrix of the
Hermitian matrix. The test is repeated to test applicable keyword
arguments.
<<Replace the upper left submatrix of the Hermitian matrix>>=
;; Upper left submatrix
(let ((array-ul
       (make-array
        '(5 5) :initial-contents
        '((#C(1  0) #C(2  1) #C(3  1) #C(1  1) #C(1 1))
          (#C(2 -1) #C(2  0) #C(3  2) #C(1  1) #C(1 1))
          (#C(3 -1) #C(3 -2) #C(3  0) #C(1  1) #C(1 1))
          (#C(1 -1) #C(1 -1) #C(1 -1) #C(1  0) #C(1 1))
          (#C(1 -1) #C(1 -1) #C(1 -1) #C(1 -1) #C(1 0))))))
  (assert-rational-equal
   array-ul
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix 0 3)))
  (assert-rational-equal
   array-ul
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix)
    :row1-end 3 :column1-end 3))
  (assert-rational-equal
   array-ul
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix)
    :row2-end 3 :column1-end 3))
  (assert-rational-equal
   array-ul
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix)
    :row1-end 3 :column2-end 3))
  (assert-rational-equal
   array-ul
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix)
    :row2-end 3 :column2-end 3)))
@ The third group of tests replaces the lower right submatrix of the
Hermitian matrix. The test is repeated to test applicable keyword
arguments.
<<Replace the lower right submatrix of the Hermitian matrix>>=
;; Lower right submatrix
(assert-rational-equal
 (make-array
  '(5 5) :initial-contents
  '((#C(1  0) #C(1  1) #C(1  1) #C(1  1) #C(1 1))
    (#C(1 -1) #C(1  0) #C(1  1) #C(1  1) #C(1 1))
    (#C(1 -1) #C(1 -1) #C(1  0) #C(2  1) #C(3 1))
    (#C(1 -1) #C(1 -1) #C(2 -1) #C(2  0) #C(3 2))
    (#C(1 -1) #C(1 -1) #C(3 -1) #C(3 -2) #C(3 0))))
 (linear-algebra:replace-matrix
  (unit-hermitian-matrix 5)
  (hermitian-matrix)
  :row1 2 :column1 2))
@ Next, the middle submatrix is replaced. As before, the test is
repeated for various combinations of applicable keywords.
<<Replace the middle submatrix of the Hermitian matrix>>=
;; Middle submatrix
(let ((array-mid
       (make-array
        '(5 5) :initial-contents
        '((#C(1  0) #C(1  1) #C(1  1) #C(1  1) #C(1 1))
          (#C(1 -1) #C(2  0) #C(3  2) #C(4  2) #C(1 1))
          (#C(1 -1) #C(3 -2) #C(3  0) #C(4  3) #C(1 1))
          (#C(1 -1) #C(4 -2) #C(4 -3) #C(4  0) #C(1 1))
          (#C(1 -1) #C(1 -1) #C(1 -1) #C(1 -1) #C(1 0))))))
  (assert-rational-equal
   array-mid
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix 1 4)
    :row1 1 :column1 1))
  (assert-rational-equal
   array-mid
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix 1 4)
    :row1 1 :column1 1
    :row1-end 4 :column1-end 4))
  (assert-rational-equal
   array-mid
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix 1)
    :row1 1 :column1 1
    :row2-end 3 :column1-end 4))
  (assert-rational-equal
   array-mid
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix 1)
    :row1 1 :column1 1
    :row1-end 4 :column2-end 3))
  (assert-rational-equal
   array-mid
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5)
    (hermitian-matrix 1)
    :row1 1 :column1 1
    :row2-end 3 :column2-end 3)))
@ The fifth group of tests replaces a submatrix that does not
intersect the diagonal of the Hermitian matrix.
<<Replace the off-diagonal submatrix of the Hermitian matrix>>=
;; Off diagonal submatrix
(let ((array-off
       (make-array
        '(5 5) :initial-contents
        '((#C(1  0) #C(1  1) #C(1  1) #C(1  1) #C(1 2))
          (#C(1 -1) #C(1  0) #C(1  1) #C(2  1) #C(2 2))
          (#C(1 -1) #C(1 -1) #C(1  0) #C(1  1) #C(1 1))
          (#C(1 -1) #C(2 -1) #C(1 -1) #C(1  0) #C(1 1))
          (#C(1 -2) #C(2 -2) #C(1 -1) #C(1 -1) #C(1 0)))))
      (submatrix1 (linear-algebra:make-matrix
                   2 2 :initial-contents
                   '((#C(1 1) #C(1 2))
                     (#C(2 1) #C(2 2)))))
      (submatrix2 (linear-algebra:make-matrix
                   4 4 :initial-contents
                   '((#C(1 1) #C(1 2) #C(1 3) #C(1 4))
                     (#C(2 1) #C(2 2) #C(2 3) #C(2 4))
                     (#C(3 1) #C(3 2) #C(3 3) #C(3 4))
                     (#C(4 1) #C(4 2) #C(4 3) #C(4 4))))))
  (assert-rational-equal
   array-off
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5) submatrix1
    :row1 0 :column1 3))
  (assert-rational-equal
   array-off
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5) submatrix2
    :row1 0 :column1 3 :row1-end 2))
  (assert-rational-equal
   array-off
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5) submatrix2
    :row1 0 :column1 3 :row2-end 2)))
(let ((array-off
       (make-array
        '(5 5) :initial-contents
        '((#C(1  0) #C(1  1) #C(1  1) #C(1  1) #C(1 2))
          (#C(1 -1) #C(1  0) #C(1  1) #C(2  1) #C(2 2))
          (#C(1 -1) #C(1 -1) #C(1  0) #C(1  1) #C(1 1))
          (#C(1 -1) #C(2 -1) #C(1 -1) #C(1  0) #C(1 1))
          (#C(1 -2) #C(2 -2) #C(1 -1) #C(1 -1) #C(1 0)))))
      (submatrix (linear-algebra:make-matrix
                  3 3 :initial-contents
                  '((#C(1 1) #C(1 2) #C(1 3))
                    (#C(2 1) #C(2 2) #C(2 3))
                    (#C(3 1) #C(3 2) #C(3 3))))))
  (assert-rational-equal
   array-off
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5) submatrix
    :column1 3 :row1-end 2))
  (assert-rational-equal
   array-off
   (linear-algebra:replace-matrix
    (unit-hermitian-matrix 5) submatrix
    :column1 3 :row2-end 2)))
@ Finally, a test is performed to verify that a replacement that would
result in a non-Hermitian matrix generates an error.
<<Verify that a non-Hermitian replacement is an error>>=
;; Non-Hermitian subsets
(assert-error
 'error
 (linear-algebra:replace-matrix
  (unit-hermitian-matrix 5)
  (unit-matrix 5 3)
  :column1 1))
@ 

The [[test-matrix-validated-range]] macro is not applicable to
Hermitian matrices, so the tests are explicitly written.
<<Test: Hermitian matrix validated range>>=
;;; Validate a range for a hermitian matrix.
(define-test hermitian-matrix-validated-range
  (let ((matrix (unit-hermitian-matrix 10))
        (row1 (random 10))
        (row2 (random 10))
        (col1 (random 10))
        (col2 (random 10)))
    (assert-equal
     (list row1 col1 10 10)
     (linear-algebra:matrix-validated-range matrix row1 col1))
    (assert-equal
     (list (min row1 row2) col1 (max row1 row2) 10)
     (linear-algebra:matrix-validated-range
      matrix (min row1 row2) col1 (max row1 row2)))
    (assert-equal
     (list row1 (min col1 col2) 10 (max col1 col2))
     (linear-algebra:matrix-validated-range
      matrix row1 (min col1 col2) nil (max col1 col2)))
    (assert-equal
     (list (min row1 row2) (min col1 col2)
           (max row1 row2) (max col1 col2))
     (linear-algebra:matrix-validated-range
      matrix
      (min row1 row2) (min col1 col2)
      (max row1 row2) (max col1 col2)))
    (assert-error
     'error
     (linear-algebra:matrix-validated-range matrix 11 col1))
    (assert-error
     'error
     (linear-algebra:matrix-validated-range matrix row1 11))
    (assert-error
     'error
     (linear-algebra:matrix-validated-range
      matrix 9 col1 1))
    (assert-error
     'error
     (linear-algebra:matrix-validated-range
      matrix row1 9 10 1))
    (assert-error
     'error
     (linear-algebra:matrix-validated-range
      matrix
      9 9 1 1))))

@ 

\chapter{Symmetric Matrix}
\label{chap:symmetric-matrix}

<<symmetric-matrix.lisp>>=
<<In linear algebra unit tests>>
<<Function: Make a symmetric matrix>>
<<Test: Make a symmetric matrix>>
<<Test: Symmetric matrix predicate>>
<<Test: Symmetric matrix bounds predicate>>
<<Test: Symmetric matrix element type>>
<<Test: Symmetric matrix dimensions>>
<<Test: Symmetric matrix row dimension>>
<<Test: Symmetric matrix column dimension>>
<<Test: Symmetric matrix element reference>>
<<Test: Copy the symmetric matrix>>
<<Test: Subset of the symmetric matrix>>
<<Test: Destructively replace a subset of the symmetric matrix>>
<<Test: Symmetric matrix validated range>>
@ The symmetric matrix tests depend on the linear algebra test package
and the matrix test macros.
<<Symmetric matrix dependencies>>=
(:file "symmetric-matrix"
       :depends-on ("defpackage" "matrix"))
@ A function that creates a symmetric matrix is defined as a
convenience for the [[(setf submatrix)]] and [[replace-matrix]] unit
tests.
<<Function: Make a symmetric matrix>>=
(defun symmetric-matrix (&optional (start 0) (end 10))
  (linear-algebra:make-matrix
   (- end start) (- end start)
   :matrix-type 'linear-algebra:symmetric-matrix
   :initial-contents (symmetric-array start end)))

@ 

\section{Creating a Symmetric Matrix Tests}
\label{sec:creating-symmetric-matrix-tests}

For symmetric matrices, [[make-matrix]] is tested for default
initialization, specifying the element type, specifying the initial
element, specifying the initial contents and three input errors. The
first error test verifies that unequal rows and columns generate an
error. The second error verifies that an error is generated if the
symmetric matrix is initialized with asymmetric data. The final error
test verifies that an error is generated when both the initial element
and initial contents are specified.
<<Test: Make a symmetric matrix>>=
(define-test make-symmetric-matrix
  <<Make a default symmetric matrix>>
  <<Specify the symmetric matrix element type>>
  <<Specify the symmetric matrix initial element>>
  <<Specify the symmetric matrix initial contents>>
  <<Symmetric matrix construction errors>>)

@ A symmetric matrix with none of the other keywords specified should be
initialized with zero.
<<Make a default symmetric matrix>>=
;; A default symmetric matrix
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:symmetric-matrix)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:symmetric-matrix))
  (assert-rational-equal
   (make-array '(10 10) :initial-element 0)
   matrix))
@ Specifying the element type is verified for [[SINGLE-FLOAT]], but
further testing should be implemented.
<<Specify the symmetric matrix element type>>=
;; Specify the symmetric matrix element type
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:symmetric-matrix
               :element-type 'single-float)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:symmetric-matrix))
  (assert-eq (array-element-type
              (linear-algebra::contents matrix))
             (array-element-type
              (make-array '(10 10) :element-type 'single-float)))
  (assert-float-equal
   (make-array '(10 10) :initial-element 0.0
               :element-type 'single-float)
   matrix))
@ If a value other than zero is required, is specified with
[[:INITIAL-ELEMENT]].
<<Specify the symmetric matrix initial element>>=
;; Specify the symmetric matrix initial element
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-element 1.0)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:symmetric-matrix))
  (assert-float-equal
   (make-array '(10 10) :initial-element 1.0)
   matrix))
@ The initial contents can be initialized with a nested sequence or a
2D array. The sequence can be a nested list
<<Specify the symmetric matrix initial contents>>=
;; Specify the symmetric matrix contents - Nested list
(let* ((data '((1.1 1.2 1.3 1.4)
               (1.2 2.2 2.3 2.4)
               (1.3 2.3 3.3 3.4)
               (1.4 2.4 3.4 4.4))) 
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:symmetric-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:symmetric-matrix))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ or a nested vector.
<<Specify the symmetric matrix initial contents>>=
;; Specify the symmetric matrix contents - Nested vector
(let* ((data #(#(1.1 1.2 1.3 1.4)
               #(1.2 2.2 2.3 2.4)
               #(1.3 2.3 3.3 3.4)
               #(1.4 2.4 3.4 4.4)))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:symmetric-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:symmetric-matrix))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ Finally, the initial contents can be a 2D array.
<<Specify the symmetric matrix initial contents>>=
;; Specify the symmetric matrix contents - 2D array
(let* ((data (make-array '(4 4) :initial-contents
                         '((1.1 1.2 1.3 1.4)
                           (1.2 2.2 2.3 2.4)
                           (1.3 2.3 3.3 3.4)
                           (1.4 2.4 3.4 4.4))))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:symmetric-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:symmetric-matrix))
  (assert-float-equal data matrix))
@ The symmetric matrix initialization methods inherit the before
method of a symmetric matrix that verifies that the number of rows is
equal to the number of columns.
<<Symmetric matrix construction errors>>=
;; Erroneous 2D array input data
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-contents
               #3A(((1.1 1.2) (2.1 2.2))
                   ((3.1 3.2) (4.1 4.2))
                   ((5.1 5.2) (6.1 6.2)))))
(assert-error 'error
              (linear-algebra:make-matrix
               3 4
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-contents
               (symmetric-array 0 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               4 3
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-contents
               (symmetric-array 0 4)))
@ Extra tests of the element type are required for the symmetric
matrix since it does not rely on [[MAKE-ARRAY]] for initial contents
in nested sequences.
<<Symmetric matrix construction errors>>=
(assert-error 'error
              (linear-algebra:make-matrix
               3 3 :element-type 'single-float
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-contents
               '((1.0 2.0 3.0) (4 5 6) (7 8 9))))
(assert-error 'error
              (linear-algebra:make-matrix
               3 3 :element-type 'single-float
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-contents
               #(#(1.0 2.0 3.0) #(4 5 6) #(7 8 9))))
(assert-error 'error
              (linear-algebra:make-matrix
               3 3 :element-type 'single-float
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-contents
               #2A((1.0 2.0 3.0) (4 5 6) (7 8 9))))
@ A further stipulation on the intialization data for a symmetric
matrix is that it must be symmetric.
<<Symmetric matrix construction errors>>=
(assert-error 'error
              (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-contents
               (coordinate-array 0 0 5 5)))
@ As with arrays, it is an error to specify both the initial element
and the initial contents.
<<Symmetric matrix construction errors>>=
;; Specify initial element and initial contents
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:symmetric-matrix
               :initial-element 1.1
               :initial-contents
               (symmetric-array 0 4)))
@ 

\section{Test Symmetric Matrix Predicates}
\label{sec:test-symmetric-matrix-predicates}

The [[symmetric-matrix-p]] function should return true if passed a
symmetric matrix object.
<<Test: Symmetric matrix predicate>>=
;;; Test the symmetric matrix predicate
(define-test symmetric-matrix-predicate
  (assert-true
   (linear-algebra:symmetric-matrix-p
    (linear-algebra:make-matrix
     10 10 :matrix-type 'linear-algebra:symmetric-matrix)))
  (assert-false
   (linear-algebra:symmetric-matrix-p (make-array '(10 10)))))

@ The other symmetric matrix predicate should return true for valid
indices.
<<Test: Symmetric matrix bounds predicate>>=
;;; Test the symmetric matrix bounds
(define-test symmetric-matrix-in-bounds-p
  (test-matrix-in-bounds-p 'linear-algebra:symmetric-matrix))

@ 

\section{Test Symmetric Matrix Inspection}
\label{sec:test-symmetric-matrix-inspection}

All symmetric matrix inspection tests are generated from the matrix test
macros.
<<Test: Symmetric matrix element type>>=
;;; Test the symmetric matrix element type
(define-test symmetric-matrix-element-type
  (test-matrix-element-type 'linear-algebra:symmetric-matrix t nil))

@ The matrix dimensions are tested using a 9x9 symmetric matrix.
<<Test: Symmetric matrix dimensions>>=
;;; Test the symmetric matrix dimensions
(define-test symmetric-matrix-dimensions
  (test-matrix-dimensions 'linear-algebra:symmetric-matrix 9 9))

@ The matrix row dimension is tested for a value of 9.
<<Test: Symmetric matrix row dimension>>=
;;; Test the symmetric matrix row dimension
(define-test symmetric-matrix-row-dimension
  (test-matrix-row-dimension 'linear-algebra:symmetric-matrix 9 9))

@ Finally, the matrix column dimension is tested for a value of 9.
<<Test: Symmetric matrix column dimension>>=
;;; Test the symmetric matrix column dimension
(define-test symmetric-matrix-column-dimension
  (test-matrix-column-dimension 'linear-algebra:symmetric-matrix 9 9))

@ 

\section{Test Referencing Symmetric Matrices}
\label{sec:test-referencing-symmetric-matrices}

The four corners of the symmetric matrix and a random interior point
are tested for equality against the input data. Additionally, the
transpose elements are tested for equality.
<<Test: Symmetric matrix element reference>>=
;;; Reference symmetric matrix elements
(define-test symmetric-matrix-mref
  (let* ((initial-contents
          '((1.1 1.2 1.3 1.4 1.5)
            (1.2 2.2 2.3 2.4 2.5)
            (1.3 2.3 3.3 3.4 3.5)
            (1.4 2.4 3.4 4.4 4.5)
            (1.5 2.5 3.5 4.5 5.5)))
         (rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random-interior-index columns)
                        (random-interior-index columns)))
                   ((/= i0 rowi) i0)))
         (data (make-array
                (list rows columns)
                :initial-contents
                initial-contents))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:symmetric-matrix
                  :initial-contents
                  initial-contents)))
    (assert-float-equal
     (aref data 0 0)
     (linear-algebra:mref matrix 0 0))
    (assert-float-equal
     (aref data 0 cend)
     (linear-algebra:mref matrix 0 cend))
    (assert-float-equal
     (aref data rend 0)
     (linear-algebra:mref matrix rend 0))
    (assert-float-equal
     (linear-algebra:mref matrix 0 cend)
     (linear-algebra:mref matrix rend 0))
    (assert-float-equal
     (aref data rend cend)
     (linear-algebra:mref matrix rend cend))
    (assert-float-equal
     (aref data rowi coli)
     (linear-algebra:mref matrix rowi coli))
    (assert-float-equal
     (linear-algebra:mref matrix rowi coli)
     (linear-algebra:mref matrix coli rowi))))

@ Similarly, the four corners and a random interior point of a
symmetric matrix are set and then compared with the original value.
<<Test: Symmetric matrix element reference>>=
;;; Set symmetric matrix elements
(define-test symmetric-matrix-setf-mref
  (let* ((rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random-interior-index columns)
                        (random-interior-index columns)))
                   ((/= i0 rowi) i0)))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type 'linear-algebra:symmetric-matrix
                  :initial-contents
                  '((1.1 1.2 1.3 1.4 1.5)
                    (1.2 2.2 2.3 2.4 2.5)
                    (1.3 2.3 3.3 3.4 3.5)
                    (1.4 2.4 3.4 4.4 4.5)
                    (1.5 2.5 3.5 4.5 5.5)))))
    (destructuring-bind (val1 val2 val3 val4)
        (make-random-list 4 1.0)
      (setf (linear-algebra:mref matrix 0 0)       val1)
      (setf (linear-algebra:mref matrix 0 cend)    val2)
      (setf (linear-algebra:mref matrix rend cend) val3)
      (setf (linear-algebra:mref matrix rowi coli) val4)
      (assert-float-equal val1 (linear-algebra:mref matrix 0 0))
      (assert-float-equal val2 (linear-algebra:mref matrix 0 cend))
      (assert-float-equal val2 (linear-algebra:mref matrix rend 0))
      (assert-float-equal val3 (linear-algebra:mref matrix rend cend))
      (assert-float-equal val4 (linear-algebra:mref matrix rowi coli))
      (assert-float-equal val4 (linear-algebra:mref matrix coli rowi)))))

@ 

\section{Test Copying Symmetric Matrices}
\label{sec:test-copying-symmetric-matrices}

Three tests are performed on [[copy-matrix]] for symmetric matrices.
The first test verifies that the matrix returned is not [[EQ]] to the
original matrix. The second test verifies that the contents are not
[[EQ]]. Finally, the elements are tested for equality.
<<Test: Copy the symmetric matrix>>=
;;; Copy the symmetric matrix
(define-test copy-symmetric-matrix
  (let ((matrix (linear-algebra:make-matrix
                 5 5
                 :matrix-type 'linear-algebra:symmetric-matrix
                 :initial-contents
                 (symmetric-array 0 5))))
    (assert-true
     (linear-algebra:symmetric-matrix-p
      (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq matrix (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq (linear-algebra::contents matrix)
         (linear-algebra::contents
          (linear-algebra:copy-matrix matrix))))
    (assert-float-equal
     matrix (linear-algebra:copy-matrix matrix))))

@ 

\section{Testing Subsets of Symmetric Matrices}
\label{sec:testing-symmetric-matrix-subsets}

The subset of a symmetric matrix is tested for 3 subsets and 6 errors.
<<Test: Subset of the symmetric matrix>>=
;;; Test the submatrix of a symmetric matrix
(define-test symmetric-submatrix
  (let ((matrix (linear-algebra:make-matrix
                 10 10
                 :matrix-type 'linear-algebra:symmetric-matrix
                 :initial-contents (symmetric-array)))
        (submat (linear-algebra:make-matrix
                 10 10
                 :matrix-type 'linear-algebra:dense-matrix
                 :initial-contents (symmetric-array))))
    <<Subsets of a symmetric matrix>>
    <<Invalid subsets of a symmetric matrix>>))

@ The first subset is the entire matrix. The second subset is
specified with a start row and column. The final subset is for a fully
specified range.
<<Subsets of a symmetric matrix>>=
;; The entire matrix
(assert-float-equal
 (symmetric-array)
 (linear-algebra:submatrix matrix 0 0))
;; Start row and column to the end
(assert-float-equal
 (symmetric-array 3)
 (linear-algebra:submatrix matrix 3 3))
;; End row and column
(assert-float-equal
 (symmetric-array 3 5)
 (linear-algebra:submatrix
  matrix 3 3 :row-end 5 :column-end 5))
;; Submatrix is a general matrix
(assert-true
 (typep (linear-algebra:submatrix matrix 1 2)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 1 2)
 (linear-algebra:submatrix matrix 1 2))
(assert-true
 (typep (linear-algebra:submatrix matrix 1 1 :row-end 5)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 1 1 :row-end 5)
 (linear-algebra:submatrix matrix 1 1 :row-end 5))
(assert-true
 (typep (linear-algebra:submatrix matrix 1 1 :column-end 8)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 1 1 :column-end 8)
 (linear-algebra:submatrix matrix 1 1 :column-end 8))
@ The first 4 errors result from specifying the start row, start
column, end row or end column in excess of the dimensions. The last 2
errors result from the start row exceeding the end row or the start
column exceeding the end column.
<<Invalid subsets of a symmetric matrix>>=
;; Start row exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 11 5))
;; Start column exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 11))
;; End row exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 5 :row-end 11))
;; End column exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 5 :column-end 11))
;; Start row exceeds end row
(assert-error
 'error (linear-algebra:submatrix matrix 7 7 :row-end 6))
;; Start column exceeds end column
(assert-error
 'error (linear-algebra:submatrix matrix 7 7 :column-end 6))
@

A submatrix of a symmetric matrix is settable with restrictions.
<<Test: Subset of the symmetric matrix>>=
;;; Set the submatrix of a symmetric matrix
(define-test setf-symmetric-submatrix
  <<Set the upper left submatrix of the symmetric matrix>>
  <<Set the lower right submatrix of the symmetric matrix>>
  <<Set the middle submatrix of the symmetric matrix>>
  <<Set the off-diagonal submatrix of the symmetric matrix>>
  <<Verify that an asymmetric matrix is an error>>)

@ The first submatrix for testing is the upper left submatrix. The
result of this test should be a 5x5 symmetric matrix, initially all
zeroes, with the upper left 2x2 submatrix set to symmetric contents.
<<Set the upper left submatrix of the symmetric matrix>>=
;; Upper left submatrix
(let ((array-ul (make-array
                 '(5 5) :initial-contents
                 '((0.0 1.0 2.0 0.0 0.0)
                   (1.0 1.1 2.1 0.0 0.0)
                   (2.0 2.1 2.2 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:symmetric-matrix
    (linear-algebra:submatrix matrix 0 0)
    (symmetric-matrix 0 3)))
  (assert-float-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:symmetric-matrix
    (linear-algebra:submatrix matrix 0 0 :row-end 3 :column-end 3)
    (symmetric-matrix))))
@ The next submatrix is the lower right submatrix. The result of this
test is also a 5x5 matrix, initially all zeroes, with the lower right
3x3 submatrix set to symmetric values.
<<Set the lower right submatrix of the symmetric matrix>>=
;; Lower right submatrix
(assert-float-equal
 (make-array
  '(5 5) :initial-contents
  '((0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 0.0 1.0 2.0)
    (0.0 0.0 1.0 1.1 2.1)
    (0.0 0.0 2.0 2.1 2.2)))
 (setf-submatrix
  5 5 'linear-algebra:symmetric-matrix
  (linear-algebra:submatrix matrix 2 2)
  (symmetric-matrix)))
@ The third set of tests is for the middle of the matrix. As before,
the result is a 5x5 matrix initially all zeroes. But in this case, the
middle 3x3 submatrix is set to symmetric values.
<<Set the middle submatrix of the symmetric matrix>>=
;; Middle submatrix
(let ((array-mid (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 1.1 2.1 3.1 0.0)
                    (0.0 2.1 2.2 3.2 0.0)
                    (0.0 3.1 3.2 3.3 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:symmetric-matrix
    (linear-algebra:submatrix matrix 1 1)
    (symmetric-matrix 1 4)))
  (assert-float-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:symmetric-matrix
    (linear-algebra:submatrix matrix 1 1 :row-end 4 :column-end 4)
    (symmetric-matrix 1))))
@ The fourth set of tests cover using any type of matrix for the
substitution.
<<Set the off-diagonal submatrix of the symmetric matrix>>=
;; Off diagonal submatrix
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 1.0 2.0)
                    (0.0 0.0 1.0 1.1 2.1)
                    (0.0 1.0 2.0 2.1 2.2)
                    (1.0 1.1 2.1 0.0 0.0)
                    (2.0 2.1 2.2 0.0 0.0)))))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:symmetric-matrix
    (linear-algebra:submatrix matrix 0 2)
    (symmetric-matrix 0 3)))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:symmetric-matrix
    (linear-algebra:submatrix matrix 0 2 :row-end 3)
    (symmetric-matrix))))
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 1.0 2.0)
                    (0.0 0.0 1.0 1.1 2.1)
                    (0.0 1.0 1.1 0.0 0.0)
                    (0.0 2.0 2.1 0.0 0.0)))))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:symmetric-matrix
    (linear-algebra:submatrix matrix 1 2)
    (linear-algebra:submatrix (symmetric-matrix 0 3)
                              0 0 :row-end 2)))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:symmetric-matrix
    (linear-algebra:submatrix matrix 1 2 :row-end 3)
    (symmetric-matrix))))
@ Finally, it is verified that an error is generated when the range
and data result in an asymmetric matrix.
<<Verify that an asymmetric matrix is an error>>=
;; Asymmetric subsets
(assert-error
 'error
 (setf (linear-algebra:submatrix
        (zero-matrix 5 5 :matrix-type
                     'linear-algebra:symmetric-matrix) 0 1)
       (unit-matrix 5 3)))
@

The final function in the matrix interface is the [[replace-matrix]]
function. For a symmetric matrix, it is tested for the same basic
behavior as [[(setf submatrix)]].
<<Test: Destructively replace a subset of the symmetric matrix>>=
;;; Replace all or part of a symmetric matrix
(define-test symmetric-matrix-replace
  <<Replace the entire symmetric matrix>>
  <<Replace the upper left submatrix of the symmetric matrix>>
  <<Replace the lower right submatrix of the symmetric matrix>>
  <<Replace the middle submatrix of the symmetric matrix>>
  <<Replace the off-diagonal submatrix of the symmetric matrix>>
  <<Verify that a replacement that violates symmetry is an error>>)

@ The first test is a single test that replaces every element of the
first matrix with the second.
<<Replace the entire symmetric matrix>>=
;; Replace the entire matrix
(assert-float-equal
 (symmetric-matrix)
 (linear-algebra:replace-matrix
  (zero-matrix 10 10 :matrix-type 'linear-algebra:symmetric-matrix)
  (symmetric-matrix)))
@ The second group of tests replaces the upper left submatrix of the
symmetric matrix. The test is repeated to test applicable keyword
arguments.
<<Replace the upper left submatrix of the symmetric matrix>>=
;; Upper left submatrix
(let ((array-ul (make-array
                 '(5 5) :initial-contents
                 '((0.0 1.0 2.0 0.0 0.0)
                   (1.0 1.1 2.1 0.0 0.0)
                   (2.0 2.1 2.2 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix 0 3)))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1-end 3 :column1-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row2-end 3 :column1-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1-end 3 :column2-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row2-end 3 :column2-end 3)))
@ The third group of tests replaces the lower right submatrix of the
symmetric matrix. The test is repeated to test applicable keyword
arguments.
<<Replace the lower right submatrix of the symmetric matrix>>=
;; Lower right submatrix
(assert-float-equal
 (make-array
  '(5 5) :initial-contents
  '((0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 0.0 1.0 2.0)
    (0.0 0.0 1.0 1.1 2.1)
    (0.0 0.0 2.0 2.1 2.2)))
 (linear-algebra:replace-matrix
  (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
  (symmetric-matrix)
  :row1 2 :column1 2))
@ Next, the middle submatrix is replaced. As before, the test is
repeated for various combinations of applicable keywords.
<<Replace the middle submatrix of the symmetric matrix>>=
;; Middle submatrix
(let ((array-mid (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 1.0 2.0 0.0)
                    (0.0 1.0 1.1 2.1 0.0)
                    (0.0 2.0 2.1 2.2 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix 0 3)
    :row1 1 :column1 1))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1 1 :column1 1
    :row1-end 4 :column1-end 4))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1 1 :column1 1
    :row2-end 3 :column1-end 4))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1 1 :column1 1
    :row1-end 4 :column2-end 3))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1 1 :column1 1
    :row2-end 3 :column2-end 3)))
@ The fifth group of tests replaces a submatrix that does not
intersect the diagonal of the symmetric matrix.
<<Replace the off-diagonal submatrix of the symmetric matrix>>=
;; Off diagonal submatrix
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 1.0 2.0)
                    (0.0 0.0 1.0 1.1 2.1)
                    (0.0 1.0 2.0 2.1 2.2)
                    (1.0 1.1 2.1 0.0 0.0)
                    (2.0 2.1 2.2 0.0 0.0)))))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix 0 3)
    :row1 0 :column1 2))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1 0 :column1 2
    :row1-end 3))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1 0 :column1 2
    :row2-end 3)))
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 1.0 2.0)
                    (0.0 0.0 1.0 1.1 2.1)
                    (0.0 1.0 1.1 0.0 0.0)
                    (0.0 2.0 2.1 0.0 0.0)))))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix 0 3)
    :row1 1 :column1 2 :row2-end 2))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
    (symmetric-matrix)
    :row1 1 :column1 2 :row1-end 3)))
@ Finally, a test is performed to verify that a replacement that would
violate the symmetry of the matrix generates an error.
<<Verify that a replacement that violates symmetry is an error>>=
;; Asymmetric subsets
(assert-error
 'error
 (linear-algebra:replace-matrix
  (zero-matrix 5 5 :matrix-type 'linear-algebra:symmetric-matrix)
  (unit-matrix 5 3)
  :column1 1))
@ 

The final group of tests is generated by the macro
[[test-matrix-validated-range]] for the symmetric matrix object.
<<Test: Symmetric matrix validated range>>=
;;; Validate a range for a symmetric matrix.
(define-test symmetric-matrix-validated-range
  (test-matrix-validated-range
   'linear-algebra:symmetric-matrix 10 10))

@ 

\chapter{Triangular Matrices}
\label{chap:triangular-matrices}

<<triangular-matrix.lisp>>=
<<In linear algebra unit tests>>
<<Function: Create a triangular matrix>>
<<Test: Make a triangular matrix>>
<<Test: Triangular matrix predicate>>
<<Test: Triangular matrix bounds predicate>>
<<Test: Triangular matrix element type>>
<<Test: Triangular matrix dimensions>>
<<Test: Triangular matrix row dimension>>
<<Test: Triangular matrix column dimension>>
<<Test: Triangular matrix element reference>>
<<Test: Copy the triangular matrix>>
<<Test: Subset of the triangular matrix>>
<<Test: Destructively replace a subset of the triangular matrix>>
<<Test: Triangular matrix validated range>>
@ The triangular matrix tests depend on the linear algebra test package
and the matrix test macros.
<<Triangular matrix dependencies>>=
(:file "triangular-matrix"
       :depends-on ("defpackage" "matrix"))
@ A function that creates a triangular matrix is defined as a
convenience for the [[(setf submatrix)]] and [[replace-matrix]] unit
tests.
<<Function: Create a triangular matrix>>=
(defun upper-triangular-matrix (&optional (start 0) (end 10))
  (linear-algebra:make-matrix
   (- end start) (- end start)
   :matrix-type 'linear-algebra:upper-triangular-matrix
   :element-type 'single-float
   :initial-contents (upper-triangular-array start end)))

(defun lower-triangular-matrix (&optional (start 0) (end 10))
  (linear-algebra:make-matrix
   (- end start) (- end start)
   :matrix-type 'linear-algebra:lower-triangular-matrix
   :element-type 'single-float
   :initial-contents (lower-triangular-array start end)))

@ 

\section{Creating a Triangular Matrix Tests}
\label{sec:creating-triangular-matrix-tests}

For triangular matrices, [[make-matrix]] is tested for default
initialization, specifying the element type, specifying the initial
element, specifying the initial contents and three input errors. The
first error test verifies that unequal rows and columns generate an
error. The second error verifies that an error is generated if the
triangular matrix is initialized with non-triangular data. The final
error test verifies that an error is generated when both the initial
element and initial contents are specified.
<<Test: Make a triangular matrix>>=
;;; Upper triangular matrix construction tests
(define-test make-upper-triangular-matrix
  <<Make a default upper triangular matrix>>
  <<Specify the upper triangular matrix element type>>
  <<Specify the upper triangular matrix initial element>>
  <<Specify the upper triangular matrix initial contents>>
  <<Upper triangular matrix construction errors>>)

;;; Lower triangular matrix construction tests
(define-test make-lower-triangular-matrix
  <<Make a default lower triangular matrix>>
  <<Specify the lower triangular matrix element type>>
  <<Specify the lower triangular matrix initial element>>
  <<Specify the lower triangular matrix initial contents>>
  <<Lower triangular matrix construction errors>>)

@ A triangular matrix with none of the other keywords specified should
be initialized with zero. 
<<Make a default upper triangular matrix>>=
;; A default upper triangular matrix
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:upper-triangular-matrix)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:upper-triangular-matrix))
  (assert-rational-equal
   (make-array '(10 10) :initial-element 0)
   matrix))
@
<<Make a default lower triangular matrix>>=
;; A default lower triangular matrix
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:lower-triangular-matrix)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:lower-triangular-matrix))
  (assert-rational-equal
   (make-array '(10 10) :initial-element 0)
   matrix))
@ Specifying the element type is verified for [[SINGLE-FLOAT]], but
further testing should be implemented.
<<Specify the upper triangular matrix element type>>=
;; Specify the upper triangular matrix element type
(let* ((data '((1.1 1.2 1.3 1.4)
               (0.0 2.2 2.3 2.4)
               (0.0 0.0 3.3 3.4)
               (0.0 0.0 0.0 4.4))) 
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:upper-triangular-matrix
                :element-type 'single-float
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:upper-triangular-matrix))
  (assert-eq (array-element-type
              (linear-algebra::contents matrix))
             (array-element-type
              (make-array '(4 4) :element-type 'single-float)))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@
<<Specify the lower triangular matrix element type>>=
;; Specify the lower triangular matrix element type
(let* ((data '((1.1 0.0 0.0 0.0)
               (1.2 2.2 0.0 0.0)
               (1.3 2.3 3.3 0.0)
               (1.4 2.4 3.4 4.4))) 
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:lower-triangular-matrix
                :element-type 'single-float
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:lower-triangular-matrix))
  (assert-eq (array-element-type
              (linear-algebra::contents matrix))
             (array-element-type
              (make-array '(4 4) :element-type 'single-float)))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ If a value other than zero is required, is specified with
[[:initial-element]].
<<Specify the upper triangular matrix initial element>>=
;; Specify the upper triangular matrix initial element
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:upper-triangular-matrix
               :initial-element 1.0)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:upper-triangular-matrix))
  (assert-float-equal
   (upper-triangular-array)
   matrix))
@
<<Specify the lower triangular matrix initial element>>=
;; Specify the lower triangular matrix initial element
(let ((matrix (linear-algebra:make-matrix
               10 10
               :matrix-type 'linear-algebra:lower-triangular-matrix
               :initial-element 1.0)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:lower-triangular-matrix))
  (assert-float-equal
   (lower-triangular-array)
   matrix))
@ 
The initial contents can be initialized with a nested sequence or a
2D array. The sequence can be a nested list
<<Specify the upper triangular matrix initial contents>>=
;; Specify the upper triangular matrix contents - Nested list
(let* ((data '((1.1 1.2 1.3 1.4)
               (0.0 2.2 2.3 2.4)
               (0.0 0.0 3.3 3.4)
               (0.0 0.0 0.0 4.4))) 
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:upper-triangular-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:upper-triangular-matrix))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@
<<Specify the lower triangular matrix initial contents>>=
;; Specify the lower triangular matrix contents - Nested list
(let* ((data '((1.1 0.0 0.0 0.0)
               (1.2 2.2 0.0 0.0)
               (1.3 2.3 3.3 0.0)
               (1.4 2.4 3.4 4.4))) 
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:lower-triangular-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:lower-triangular-matrix))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ 
or a nested vector.
<<Specify the upper triangular matrix initial contents>>=
;; Specify the upper-triangular matrix contents - Nested vector
(let* ((data #(#(1.1 1.2 1.3 1.4)
               #(0.0 2.2 2.3 2.4)
               #(0.0 0.0 3.3 3.4)
               #(0.0 0.0 0.0 4.4)))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:upper-triangular-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:upper-triangular-matrix))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@
<<Specify the lower triangular matrix initial contents>>=
;; Specify the lower-triangular matrix contents - Nested vector
(let* ((data #(#(1.1 0.0 0.0 0.0)
               #(1.2 2.2 0.0 0.0)
               #(1.3 2.3 3.3 0.0)
               #(1.4 2.4 3.4 4.4)))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:lower-triangular-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:lower-triangular-matrix))
  (assert-float-equal
   (make-array '(4 4) :initial-contents data)
   matrix))
@ 
Finally, the initial contents can be a 2D array.
<<Specify the upper triangular matrix initial contents>>=
;; Specify the upper triangular matrix contents - 2D array
(let* ((data (make-array '(4 4) :initial-contents
                         '((1.1 1.2 1.3 1.4)
                           (0.0 2.2 2.3 2.4)
                           (0.0 0.0 3.3 3.4)
                           (0.0 0.0 0.0 4.4))))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:upper-triangular-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:upper-triangular-matrix))
  (assert-float-equal data matrix))
@
<<Specify the lower triangular matrix initial contents>>=
;; Specify the lower triangular matrix contents - 2D array
(let* ((data (make-array '(4 4) :initial-contents
                         '((1.1 0.0 0.0 0.0)
                           (1.2 2.2 0.0 0.0)
                           (1.3 2.3 3.3 0.0)
                           (1.4 2.4 3.4 4.4))))
       (matrix (linear-algebra:make-matrix
                4 4
                :matrix-type 'linear-algebra:lower-triangular-matrix
                :initial-contents data)))
  (assert-true (linear-algebra:matrixp matrix))
  (assert-true (typep matrix 'linear-algebra:lower-triangular-matrix))
  (assert-float-equal data matrix))
@ 
The triangular matrix initialization methods inherit the before
method of a triangular matrix that verifies that the number of rows is
equal to the number of columns.
<<Upper triangular matrix construction errors>>=
;; Erroneous 2D array input data
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:upper-triangular-matrix
               :initial-contents
               #3A(((1.1 1.2) (2.1 2.2))
                   ((3.1 3.2) (4.1 4.2))
                   ((5.1 5.2) (6.1 6.2)))))
(assert-error 'error
              (linear-algebra:make-matrix
               3 4
               :matrix-type 'linear-algebra:upper-triangular-matrix
               :initial-contents
               (upper-triangular-array 0 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               4 3
               :matrix-type 'linear-algebra:upper-triangular-matrix
               :initial-contents
               (upper-triangular-array 0 4)))
@
<<Lower triangular matrix construction errors>>=
;; Erroneous 2D array input data
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:lower-triangular-matrix
               :initial-contents
               #3A(((1.1 1.2) (2.1 2.2))
                   ((3.1 3.2) (4.1 4.2))
                   ((5.1 5.2) (6.1 6.2)))))
(assert-error 'error
              (linear-algebra:make-matrix
               3 4
               :matrix-type 'linear-algebra:lower-triangular-matrix
               :initial-contents
               (lower-triangular-array 0 4)))
(assert-error 'error
              (linear-algebra:make-matrix
               4 3
               :matrix-type 'linear-algebra:lower-triangular-matrix
               :initial-contents
               (lower-triangular-array 0 4)))
@ 
A further stipulation on the intialization data for a triangular
matrix is that it must be triangular.
<<Upper triangular matrix construction errors>>=
(assert-error 'error
              (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:upper-triangular-matrix
               :initial-contents
               (coordinate-array 0 0 5 5)))
@
<<Lower triangular matrix construction errors>>=
(assert-error 'error
              (linear-algebra:make-matrix
               5 5
               :matrix-type 'linear-algebra:lower-triangular-matrix
               :initial-contents
               (coordinate-array 0 0 5 5)))
@ 
As with arrays, it is an error to specify both the initial element
and the initial contents.
<<Upper triangular matrix construction errors>>=
;; Specify initial element and initial contents
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:upper-triangular-matrix
               :initial-element 1.1
               :initial-contents
               (upper-triangular-array 0 4)))
@ 
<<Lower triangular matrix construction errors>>=
;; Specify initial element and initial contents
(assert-error 'error
              (linear-algebra:make-matrix
               4 4
               :matrix-type 'linear-algebra:lower-triangular-matrix
               :initial-element 1.1
               :initial-contents
               (lower-triangular-array 0 4)))
@ 

\section{Test Triangular Matrix Predicates}
\label{sec:test-triangular-matrix-predicates}

The [[upper-triangular-matrix-p]] function should return true if
passed a triangular matrix object.
<<Test: Triangular matrix predicate>>=
;;; Test the upper triangular matrix predicate
(define-test upper-triangular-matrix-predicate
  (assert-true
   (linear-algebra:upper-triangular-matrix-p
    (linear-algebra:make-matrix
     10 10 :matrix-type 'linear-algebra:upper-triangular-matrix)))
  (assert-false
   (linear-algebra:upper-triangular-matrix-p (make-array '(10 10)))))

;;; Test the lower triangular matrix predicate
(define-test lower-triangular-matrix-predicate
  (assert-true
   (linear-algebra:lower-triangular-matrix-p
    (linear-algebra:make-matrix
     10 10 :matrix-type 'linear-algebra:lower-triangular-matrix)))
  (assert-false
   (linear-algebra:lower-triangular-matrix-p (make-array '(10 10)))))

@ The other triangular matrix predicate should return true for valid
indices.
<<Test: Triangular matrix bounds predicate>>=
;;; Test the upper triangular matrix bounds
(define-test upper-triangular-matrix-in-bounds-p
  (test-matrix-in-bounds-p
   'linear-algebra:upper-triangular-matrix))

;;; Test the lower triangular matrix bounds
(define-test lower-triangular-matrix-in-bounds-p
  (test-matrix-in-bounds-p
   'linear-algebra:lower-triangular-matrix))

@ 

\section{Test Triangular Matrix Inspection}
\label{sec:test-triangular-matrix-inspection}

All triangular matrix inspection tests are generated from the matrix test
macros.
<<Test: Triangular matrix element type>>=
;;; Test the upper triangular matrix element type
(define-test upper-triangular-matrix-element-type
  (test-matrix-element-type
   'linear-algebra:upper-triangular-matrix))

;;; Test the lower triangular matrix element type
(define-test lower-triangular-matrix-element-type
  (test-matrix-element-type
   'linear-algebra:lower-triangular-matrix))

@ The matrix dimensions are tested using a 9x9 triangular matrix.
<<Test: Triangular matrix dimensions>>=
;;; Test the upper triangular matrix dimensions
(define-test upper-triangular-matrix-dimensions
  (test-matrix-dimensions
   'linear-algebra:upper-triangular-matrix 9 9))

;;; Test the lower triangular matrix dimensions
(define-test lower-triangular-matrix-dimensions
  (test-matrix-dimensions
   'linear-algebra:lower-triangular-matrix 9 9))

@ The matrix row dimension is tested for a value of 9.
<<Test: Triangular matrix row dimension>>=
;;; Test the upper triangular matrix row dimension
(define-test upper-triangular-matrix-row-dimension
  (test-matrix-row-dimension
   'linear-algebra:upper-triangular-matrix 9 9))

;;; Test the lower triangular matrix row dimension
(define-test lower-triangular-matrix-row-dimension
  (test-matrix-row-dimension
   'linear-algebra:lower-triangular-matrix 9 9))

@ Finally, the matrix column dimension is tested for a value of 9.
<<Test: Triangular matrix column dimension>>=
;;; Test the upper triangular matrix column dimension
(define-test upper-triangular-matrix-column-dimension
  (test-matrix-column-dimension
   'linear-algebra:upper-triangular-matrix 9 9))

;;; Test the lower triangular matrix column dimension
(define-test lower-triangular-matrix-column-dimension
  (test-matrix-column-dimension
   'linear-algebra:lower-triangular-matrix 9 9))

@ 

\section{Test Referencing Triangular Matrices}
\label{sec:test-referencing-triangular-matrices}

The 3 corners of the triangular matrix and a random interior point are
tested for equality against the input data. For the upper triangular
matrix tests, the random column is constrained to an index greater
than the random row. This enables verifying that a random element in
the lower triangle is equal to zero.
<<Test: Triangular matrix element reference>>=
;;; Reference upper triangular matrix elements
(define-test upper-triangular-matrix-mref
  (let* ((initial-contents
          '((1.1 1.2 1.3 1.4 1.5)
            (0.0 2.2 2.3 2.4 2.5)
            (0.0 0.0 3.3 3.4 3.5)
            (0.0 0.0 0.0 4.4 4.5)
            (0.0 0.0 0.0 0.0 5.5)))
         (rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random columns)
                        (random columns)))
                   ((> i0 rowi) i0)))
         (data (make-array
                (list rows columns)
                :initial-contents
                initial-contents))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:upper-triangular-matrix
                  :initial-contents
                  initial-contents)))
    (assert-float-equal
     (aref data 0 0)
     (linear-algebra:mref matrix 0 0))
    (assert-float-equal
     (aref data 0 cend)
     (linear-algebra:mref matrix 0 cend))
    (assert-float-equal
     (aref data rend 0)
     (linear-algebra:mref matrix rend 0))
    (assert-float-equal
     (aref data rend cend)
     (linear-algebra:mref matrix rend cend))
    (assert-float-equal
     (aref data rowi coli)
     (linear-algebra:mref matrix rowi coli))
    (assert-float-equal
     0.0
     (linear-algebra:mref matrix coli rowi))))

@ Likewise, for the lower triangular matrix tests, the random column
is constrained to an index less than the random row. The transpose of
the random index in the upper triangle is tested for equality with
zero.
<<Test: Triangular matrix element reference>>=
;;; Reference lower triangular matrix elements
(define-test lower-triangular-matrix-mref
  (let* ((initial-contents
          '((1.1 0.0 0.0 0.0 0.0)
            (1.2 2.2 0.0 0.0 0.0)
            (1.3 2.3 3.3 0.0 0.0)
            (1.4 2.4 3.4 4.4 0.0)
            (1.5 2.5 3.5 4.5 5.5)))
         (rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random columns)
                        (random columns)))
                   ((< i0 rowi) i0)))
         (data (make-array
                (list rows columns)
                :initial-contents
                initial-contents))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:lower-triangular-matrix
                  :initial-contents
                  initial-contents)))
    (assert-float-equal
     (aref data 0 0)
     (linear-algebra:mref matrix 0 0))
    (assert-float-equal
     (aref data 0 cend)
     (linear-algebra:mref matrix 0 cend))
    (assert-float-equal
     (aref data rend 0)
     (linear-algebra:mref matrix rend 0))
    (assert-float-equal
     (aref data rend cend)
     (linear-algebra:mref matrix rend cend))
    (assert-float-equal
     (aref data rowi coli)
     (linear-algebra:mref matrix rowi coli))
    (assert-float-equal
     0.0
     (linear-algebra:mref matrix coli rowi))))

@ 

Similarly, the four corners and a random interior point of a
triangular matrix are set and then compared with the original value.
An additional test is performed to verify that setting an element on
the zero side of the diagonal generates an error.  In the case of an
upper triangular matrix, the lower left corner and the transpose index
of the random element are tested for zero.
<<Test: Triangular matrix element reference>>=
;;; Set upper triangular matrix elements
(define-test upper-triangular-matrix-setf-mref
  (let* ((rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random columns)
                        (random columns)))
                   ((> i0 rowi) i0)))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:upper-triangular-matrix
                  :initial-contents
                  '((1.1 1.2 1.3 1.4 1.5)
                    (0.0 2.2 2.3 2.4 2.5)
                    (0.0 0.0 3.3 3.4 3.5)
                    (0.0 0.0 0.0 4.4 4.5)
                    (0.0 0.0 0.0 0.0 5.5)))))
    (destructuring-bind (val1 val2 val3 val4)
        (make-random-list 4 1.0)
      (setf (linear-algebra:mref matrix 0 0)       val1)
      (setf (linear-algebra:mref matrix 0 cend)    val2)
      (setf (linear-algebra:mref matrix rend cend) val3)
      (setf (linear-algebra:mref matrix rowi coli) val4)
      (assert-float-equal val1 (linear-algebra:mref matrix 0 0))
      (assert-float-equal val2 (linear-algebra:mref matrix 0 cend))
      (assert-float-equal 0.0  (linear-algebra:mref matrix rend 0))
      (assert-float-equal val3 (linear-algebra:mref matrix rend cend))
      (assert-float-equal val4 (linear-algebra:mref matrix rowi coli))
      (assert-float-equal 0.0  (linear-algebra:mref matrix coli rowi))
      (assert-error
       'error
       (setf (linear-algebra:mref matrix coli rowi) 1.0)))))

@ The upper right corner and transpose index of the random element are
tested for equality with zero for lower triangular matrices.
<<Test: Triangular matrix element reference>>=
;;; Set lower triangular matrix elements
(define-test lower-triangular-matrix-setf-mref
  (let* ((rows 5) (columns 5)
         (rend (1- rows)) (cend (1- columns))
         (rowi (random-interior-index rows))
         (coli (do ((i0 (random columns)
                        (random columns)))
                   ((< i0 rowi) i0)))
         (matrix (linear-algebra:make-matrix
                  rows columns
                  :matrix-type
                  'linear-algebra:lower-triangular-matrix
                  :initial-contents
                  '((1.1 0.0 0.0 0.0 0.0)
                    (1.2 2.2 0.0 0.0 0.0)
                    (1.3 2.3 3.3 0.0 0.0)
                    (1.4 2.4 3.4 4.4 0.0)
                    (1.5 2.5 3.5 4.5 5.5)))))
    (destructuring-bind (val1 val2 val3 val4)
        (make-random-list 4 1.0)
      (setf (linear-algebra:mref matrix 0 0)       val1)
      (setf (linear-algebra:mref matrix rend 0)    val2)
      (setf (linear-algebra:mref matrix rend cend) val3)
      (setf (linear-algebra:mref matrix rowi coli) val4)
      (assert-float-equal val1 (linear-algebra:mref matrix 0 0))
      (assert-float-equal 0.0  (linear-algebra:mref matrix 0 cend))
      (assert-float-equal val2 (linear-algebra:mref matrix rend 0))
      (assert-float-equal val3 (linear-algebra:mref matrix rend cend))
      (assert-float-equal val4 (linear-algebra:mref matrix rowi coli))
      (assert-float-equal 0.0  (linear-algebra:mref matrix coli rowi))
      (assert-error
       'error
       (setf (linear-algebra:mref matrix coli rowi) 1.0)))))

@ 

\section{Test Copying Triangular Matrices}
\label{sec:test-copying-triangular-matrices}

Three tests are performed on [[copy-matrix]] for triangular matrices.
The first test verifies that the matrix returned is not [[EQ]] to the
original matrix. The second test verifies that the contents are not
[[EQ]]. Finally, the elements are tested for equality.
<<Test: Copy the triangular matrix>>=
;;; Copy the upper triangular matrix
(define-test copy-upper-triangular-matrix
  (let ((matrix (linear-algebra:make-matrix
                 5 5 :element-type 'single-float
                 :matrix-type
                 'linear-algebra:upper-triangular-matrix
                 :initial-contents
                 (upper-triangular-array 0 5))))
    (assert-true
     (linear-algebra:upper-triangular-matrix-p
      (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq matrix (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq (linear-algebra::contents matrix)
         (linear-algebra::contents
          (linear-algebra:copy-matrix matrix))))
    (assert-float-equal
     matrix (linear-algebra:copy-matrix matrix))))

;;; Copy the lower triangular matrix
(define-test copy-lower-triangular-matrix
  (let ((matrix (linear-algebra:make-matrix
                 5 5 :element-type 'single-float
                 :matrix-type
                 'linear-algebra:lower-triangular-matrix
                 :initial-contents
                 (lower-triangular-array 0 5))))
    (assert-true
     (linear-algebra:lower-triangular-matrix-p
      (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq matrix (linear-algebra:copy-matrix matrix)))
    (assert-false
     (eq (linear-algebra::contents matrix)
         (linear-algebra::contents
          (linear-algebra:copy-matrix matrix))))
    (assert-float-equal
     matrix (linear-algebra:copy-matrix matrix))))

@ 

\section{Testing Subsets of Triangular Matrices}
\label{sec:testing-triangular-matrix-subsets}

The subset of a triangular matrix is tested for 3 subsets and 6 errors.
<<Test: Subset of the triangular matrix>>=
;;; Test the submatrix of an upper triangular matrix
(define-test upper-triangular-submatrix
  (let ((matrix (linear-algebra:make-matrix
                 10 10
                 :matrix-type 'linear-algebra:upper-triangular-matrix
                 :initial-contents (upper-triangular-array)))
        (submat (linear-algebra:make-matrix
                 10 10
                 :matrix-type 'linear-algebra:dense-matrix
                 :initial-contents (upper-triangular-array))))
    <<Subsets of an upper triangular matrix>>
    <<Invalid subsets of an upper triangular matrix>>))

;;; Test the submatrix of an lower triangular matrix
(define-test lower-triangular-submatrix
  (let ((matrix (linear-algebra:make-matrix
                 10 10
                 :matrix-type 'linear-algebra:lower-triangular-matrix
                 :initial-contents (lower-triangular-array)))
        (submat (linear-algebra:make-matrix
                 10 10
                 :matrix-type 'linear-algebra:dense-matrix
                 :initial-contents (lower-triangular-array))))
    <<Subsets of a lower triangular matrix>>
    <<Invalid subsets of a lower triangular matrix>>))

@ The first subset is the entire matrix. The second subset is
specified with a start row and column. The final subset is for a fully
specified range.
<<Subsets of an upper triangular matrix>>=
;; The entire matrix
(assert-float-equal
 (upper-triangular-array)
 (linear-algebra:submatrix matrix 0 0))
;; Start row and column to the end
(assert-float-equal
 (upper-triangular-array 3)
 (linear-algebra:submatrix matrix 3 3))
;; End row and column
(assert-float-equal
 (upper-triangular-array 3 5)
 (linear-algebra:submatrix
  matrix 3 3 :row-end 5 :column-end 5))
;; Submatrix is a dense matrix
(assert-true
 (typep (linear-algebra:submatrix matrix 1 2)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 1 2)
 (linear-algebra:submatrix matrix 1 2)
 (array-error
  (linear-algebra::contents
   (linear-algebra:submatrix submat 1 2))
  (linear-algebra::contents
   (linear-algebra:submatrix matrix 1 2))))
(assert-true
 (typep (linear-algebra:submatrix matrix 1 1 :row-end 5)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 1 1 :row-end 5)
 (linear-algebra:submatrix matrix 1 1 :row-end 5))
(assert-true
 (typep (linear-algebra:submatrix matrix 1 1 :column-end 8)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 1 1 :column-end 8)
 (linear-algebra:submatrix matrix 1 1 :column-end 8))
@
<<Subsets of a lower triangular matrix>>=
;; The entire matrix
(assert-float-equal
 (lower-triangular-array)
 (linear-algebra:submatrix matrix 0 0))
;; Start row and column to the end
(assert-float-equal
 (lower-triangular-array 3)
 (linear-algebra:submatrix matrix 3 3))
;; End row and column
(assert-float-equal
 (lower-triangular-array 3 5)
 (linear-algebra:submatrix
  matrix 3 3 :row-end 5 :column-end 5))
;; Submatrix is a dense matrix
(assert-true
 (typep (linear-algebra:submatrix matrix 2 1)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 2 1)
 (linear-algebra:submatrix matrix 2 1)
 (array-error
  (linear-algebra::contents
   (linear-algebra:submatrix submat 2 1))
  (linear-algebra::contents
   (linear-algebra:submatrix matrix 2 1))))
(assert-true
 (typep (linear-algebra:submatrix matrix 1 1 :row-end 5)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 1 1 :row-end 5)
 (linear-algebra:submatrix matrix 1 1 :row-end 5))
(assert-true
 (typep (linear-algebra:submatrix matrix 1 1 :column-end 8)
        'linear-algebra:dense-matrix))
(assert-float-equal
 (linear-algebra:submatrix submat 1 1 :column-end 8)
 (linear-algebra:submatrix matrix 1 1 :column-end 8))
@ The first 4 errors result from specifying the start row, start
column, end row or end column in excess of the dimensions. The last 2
errors result from the start row exceeding the end row or the start
column exceeding the end column.
<<Invalid subsets of an upper triangular matrix>>=
;; Start row exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 11 5))
;; Start column exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 11))
;; End row exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 5 :row-end 11))
;; End column exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 5 :column-end 11))
;; Start row exceeds end row
(assert-error
 'error (linear-algebra:submatrix matrix 7 7 :row-end 6))
;; Start column exceeds end column
(assert-error
 'error (linear-algebra:submatrix matrix 7 7 :column-end 6))
@
<<Invalid subsets of a lower triangular matrix>>=
;; Start row exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 11 5))
;; Start column exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 11))
;; End row exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 5 :row-end 11))
;; End column exceeds dimensions
(assert-error
 'error (linear-algebra:submatrix matrix 5 5 :column-end 11))
;; Start row exceeds end row
(assert-error
 'error (linear-algebra:submatrix matrix 7 7 :row-end 6))
;; Start column exceeds end column
(assert-error
 'error (linear-algebra:submatrix matrix 7 7 :column-end 6))
@ 

A submatrix of a triangular matrix is settable with restrictions.
<<Test: Subset of the triangular matrix>>=
;;; Set the submatrix of an upper triangular matrix
(define-test setf-upper-triangular-submatrix
  <<Set the upper left submatrix of the upper triangular matrix>>
  <<Set the lower right submatrix of the upper triangular matrix>>
  <<Set the middle submatrix of the upper triangular matrix>>
  <<Set the off-diagonal submatrix of the upper triangular matrix>>
  <<Verify that a non upper triangular matrix is an error>>)

;;; Set the submatrix of a lower triangular matrix
(define-test setf-lower-triangular-submatrix
  <<Set the upper left submatrix of the lower triangular matrix>>
  <<Set the lower right submatrix of the lower triangular matrix>>
  <<Set the middle submatrix of the lower triangular matrix>>
  <<Set the off-diagonal submatrix of the lower triangular matrix>>
  <<Verify that a non lower triangular matrix is an error>>)

@ The first submatrix for testing is the upper left submatrix. The
result of this test should be a 5x5 triangular matrix, initially all
zeroes, with the upper left 2x2 submatrix set to triangular contents.
<<Set the upper left submatrix of the upper triangular matrix>>=
;; Upper left submatrix
(let ((array-ul (make-array
                 '(5 5) :initial-contents
                 '((1.0 1.0 1.0 0.0 0.0)
                   (0.0 1.0 1.0 0.0 0.0)
                   (0.0 0.0 1.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:upper-triangular-matrix
    (linear-algebra:submatrix matrix 0 0)
    (upper-triangular-matrix 0 3)))
  (assert-float-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:upper-triangular-matrix
    (linear-algebra:submatrix matrix 0 0 :row-end 3 :column-end 3)
    (upper-triangular-matrix 0 10))))
@
<<Set the upper left submatrix of the lower triangular matrix>>=
;; Upper left submatrix
(let ((array-ul (make-array
                 '(5 5) :initial-contents
                 '((1.0 0.0 0.0 0.0 0.0)
                   (1.0 1.0 0.0 0.0 0.0)
                   (1.0 1.0 1.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:lower-triangular-matrix
    (linear-algebra:submatrix matrix 0 0)
    (lower-triangular-matrix 0 3)))
  (assert-float-equal
   array-ul
   (setf-submatrix
    5 5 'linear-algebra:lower-triangular-matrix
    (linear-algebra:submatrix matrix 0 0 :row-end 3 :column-end 3)
    (lower-triangular-matrix 0 10))))
@ The next submatrix is the lower right submatrix. The result of this
test is also a 5x5 matrix, initially all zeroes, with the lower right
3x3 submatrix set to triangular values.
<<Set the lower right submatrix of the upper triangular matrix>>=
;; Lower right submatrix
(assert-float-equal
 (make-array
  '(5 5) :initial-contents
  '((0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 1.0 1.0 1.0)
    (0.0 0.0 0.0 1.0 1.0)
    (0.0 0.0 0.0 0.0 1.0)))
 (setf-submatrix
  5 5 'linear-algebra:upper-triangular-matrix
  (linear-algebra:submatrix matrix 2 2)
  (upper-triangular-matrix)))
@
<<Set the lower right submatrix of the lower triangular matrix>>=
;; Lower right submatrix
(assert-float-equal
 (make-array
  '(5 5) :initial-contents
  '((0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 1.0 0.0 0.0)
    (0.0 0.0 1.0 1.0 0.0)
    (0.0 0.0 1.0 1.0 1.0)))
 (setf-submatrix
  5 5 'linear-algebra:lower-triangular-matrix
  (linear-algebra:submatrix matrix 2 2)
  (lower-triangular-matrix)))
@ The third set of tests is for the middle of the matrix. As before,
the result is a 5x5 matrix initially all zeroes. But in this case, the
middle 3x3 submatrix is set to triangular values.
<<Set the middle submatrix of the upper triangular matrix>>=
;; Middle submatrix
(let ((array-mid (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 1.0 1.0 1.0 0.0)
                    (0.0 0.0 1.0 1.0 0.0)
                    (0.0 0.0 0.0 1.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:upper-triangular-matrix
    (linear-algebra:submatrix matrix 1 1)
    (upper-triangular-matrix 1 4)))
  (assert-float-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:upper-triangular-matrix
    (linear-algebra:submatrix matrix 1 1 :row-end 4 :column-end 4)
    (upper-triangular-matrix 1))))
@
<<Set the middle submatrix of the lower triangular matrix>>=
;; Middle submatrix
(let ((array-mid (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 1.0 0.0 0.0 0.0)
                    (0.0 1.0 1.0 0.0 0.0)
                    (0.0 1.0 1.0 1.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:lower-triangular-matrix
    (linear-algebra:submatrix matrix 1 1)
    (lower-triangular-matrix 1 4)))
  (assert-float-equal
   array-mid
   (setf-submatrix
    5 5 'linear-algebra:lower-triangular-matrix
    (linear-algebra:submatrix matrix 1 1 :row-end 4 :column-end 4)
    (lower-triangular-matrix 1))))
@ The fourth set of tests cover using any type of matrix for the
substitution.
<<Set the off-diagonal submatrix of the upper triangular matrix>>=
;; Above diagonal submatrix
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 1.0 1.0 1.0)
                    (0.0 0.0 0.0 1.0 1.0)
                    (0.0 0.0 0.0 0.0 1.0)
                    (0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:upper-triangular-matrix
    (linear-algebra:submatrix matrix 0 2)
    (upper-triangular-matrix 0 3)))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:upper-triangular-matrix
    (linear-algebra:submatrix matrix 0 2 :row-end 3)
    (upper-triangular-matrix))))
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 1.0 1.0 1.0)
                    (0.0 0.0 1.0 1.0 1.0)
                    (0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:upper-triangular-matrix
    (linear-algebra:submatrix matrix 1 2)
    (linear-algebra:submatrix (unit-matrix 3 3)
                              0 0 :row-end 2)))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:upper-triangular-matrix
    (linear-algebra:submatrix matrix 1 2 :row-end 3)
    (unit-matrix 3 3))))
@
<<Set the off-diagonal submatrix of the lower triangular matrix>>=
;; Below diagonal submatrix
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)
                    (1.0 0.0 0.0 0.0 0.0)
                    (1.0 1.0 0.0 0.0 0.0)
                    (1.0 1.0 1.0 0.0 0.0)))))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:lower-triangular-matrix
    (linear-algebra:submatrix matrix 2 0)
    (lower-triangular-matrix 0 3)))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:lower-triangular-matrix
    (linear-algebra:submatrix matrix 2 0 :column-end 3)
    (lower-triangular-matrix))))
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)
                    (0.0 1.0 1.0 0.0 0.0)
                    (0.0 1.0 1.0 0.0 0.0)
                    (0.0 1.0 1.0 0.0 0.0)))))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:lower-triangular-matrix
    (linear-algebra:submatrix matrix 2 1)
    (linear-algebra:submatrix (unit-matrix 3 3)
                              0 0 :column-end 2)))
  (assert-float-equal
   array-off
   (setf-submatrix
    5 5 'linear-algebra:lower-triangular-matrix
    (linear-algebra:submatrix matrix 2 1 :column-end 3)
    (unit-matrix 3 3))))
@ Finally, it is verified that an error is generated when the range
and data result in an atriangular matrix.
<<Verify that a non upper triangular matrix is an error>>=
;; Non upper-triangular subsets
(assert-error
 'error
 (setf (linear-algebra:submatrix
        (zero-matrix 5 5 :matrix-type
                     'linear-algebra:upper-triangular-matrix) 0 1)
       (unit-matrix 5 3)))
@
<<Verify that a non lower triangular matrix is an error>>=
;; Non lower-triangular subsets
(assert-error
 'error
 (setf (linear-algebra:submatrix
        (zero-matrix 5 5 :matrix-type
                     'linear-algebra:lower-triangular-matrix) 1 0)
       (unit-matrix 3 5)))
@ 

The final function in the matrix interface is the [[replace-matrix]]
function. For a Triangular matrix, it is tested for the same basic
behavior as [[(setf submatrix)]].
<<Test: Destructively replace a subset of the triangular matrix>>=
;;; Replace all or part of an upper triangular matrix
(define-test upper-triangular-matrix-replace
  <<Replace the entire upper triangular matrix>>
  <<Replace the upper left submatrix of the upper triangular matrix>>
  <<Replace the lower right submatrix of the upper triangular matrix>>
  <<Replace the middle submatrix of the upper triangular matrix>>
  <<Replace the off-diagonal submatrix of the upper triangular matrix>>
  <<Verify that a replacement that is non upper triangular is an error>>)

;;; Replace all or part of a lower triangular matrix
(define-test lower-triangular-matrix-replace
  <<Replace the entire lower triangular matrix>>
  <<Replace the upper left submatrix of the lower triangular matrix>>
  <<Replace the lower right submatrix of the lower triangular matrix>>
  <<Replace the middle submatrix of the lower triangular matrix>>
  <<Replace the off-diagonal submatrix of the lower triangular matrix>>
  <<Verify that a replacement that is non lower triangular is an error>>)

@ The first test is a single test that replaces every element of the
first matrix with the second.
<<Replace the entire upper triangular matrix>>=
;; Replace the entire matrix
(assert-float-equal
 (upper-triangular-matrix)
 (linear-algebra:replace-matrix
  (zero-matrix 10 10 :matrix-type 'linear-algebra:upper-triangular-matrix)
  (upper-triangular-matrix)))
@
<<Replace the entire lower triangular matrix>>=
;; Replace the entire matrix
(assert-float-equal
 (lower-triangular-matrix)
 (linear-algebra:replace-matrix
  (zero-matrix 10 10 :matrix-type 'linear-algebra:lower-triangular-matrix)
  (lower-triangular-matrix)))
@ The second group of tests replaces the upper left submatrix of the
Triangular matrix. The test is repeated to test applicable keyword
arguments.
<<Replace the upper left submatrix of the upper triangular matrix>>=
;; Upper left submatrix
(let ((array-ul (make-array
                 '(5 5) :initial-contents
                 '((1.0 1.0 1.0 0.0 0.0)
                   (0.0 1.0 1.0 0.0 0.0)
                   (0.0 0.0 1.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix 0 3)))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row1-end 3 :column1-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row2-end 3 :column1-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row1-end 3 :column2-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row2-end 3 :column2-end 3)))
@
<<Replace the upper left submatrix of the lower triangular matrix>>=
;; Upper left submatrix
(let ((array-ul (make-array
                 '(5 5) :initial-contents
                 '((1.0 0.0 0.0 0.0 0.0)
                   (1.0 1.0 0.0 0.0 0.0)
                   (1.0 1.0 1.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)
                   (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix 0 3)))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row1-end 3 :column1-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row2-end 3 :column1-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row1-end 3 :column2-end 3))
  (assert-float-equal
   array-ul
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row2-end 3 :column2-end 3)))
@ The third group of tests replaces the lower right submatrix of the
Triangular matrix. The test is repeated to test applicable keyword
arguments.
<<Replace the lower right submatrix of the upper triangular matrix>>=
;; Lower right submatrix
(assert-float-equal
 (make-array
  '(5 5) :initial-contents
  '((0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 1.0 1.0 1.0)
    (0.0 0.0 0.0 1.0 1.0)
    (0.0 0.0 0.0 0.0 1.0)))
 (linear-algebra:replace-matrix
  (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
  (upper-triangular-matrix)
  :row1 2 :column1 2))
@
<<Replace the lower right submatrix of the lower triangular matrix>>=
;; Lower right submatrix
(assert-float-equal
 (make-array
  '(5 5) :initial-contents
  '((0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 0.0 0.0 0.0)
    (0.0 0.0 1.0 0.0 0.0)
    (0.0 0.0 1.0 1.0 0.0)
    (0.0 0.0 1.0 1.0 1.0)))
 (linear-algebra:replace-matrix
  (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
  (lower-triangular-matrix)
  :row1 2 :column1 2))
@ Next, the middle submatrix is replaced. As before, the test is
repeated for various combinations of applicable keywords.
<<Replace the middle submatrix of the upper triangular matrix>>=
;; Middle submatrix
(let ((array-mid (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 1.0 1.0 1.0 0.0)
                    (0.0 0.0 1.0 1.0 0.0)
                    (0.0 0.0 0.0 1.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix 0 3)
    :row1 1 :column1 1))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row1 1 :column1 1
    :row1-end 4 :column1-end 4))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row1 1 :column1 1
    :row2-end 3 :column1-end 4))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row1 1 :column1 1
    :row1-end 4 :column2-end 3))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row1 1 :column1 1
    :row2-end 3 :column2-end 3)))
@
<<Replace the middle submatrix of the lower triangular matrix>>=
;; Middle submatrix
(let ((array-mid (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 1.0 0.0 0.0 0.0)
                    (0.0 1.0 1.0 0.0 0.0)
                    (0.0 1.0 1.0 1.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix 0 3)
    :row1 1 :column1 1))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row1 1 :column1 1
    :row1-end 4 :column1-end 4))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row1 1 :column1 1
    :row2-end 3 :column1-end 4))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row1 1 :column1 1
    :row1-end 4 :column2-end 3))
  (assert-float-equal
   array-mid
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row1 1 :column1 1
    :row2-end 3 :column2-end 3)))
@ The fifth group of tests replaces a submatrix that does not
intersect the diagonal of the Triangular matrix.
<<Replace the off-diagonal submatrix of the upper triangular matrix>>=
;; Above diagonal submatrix
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 1.0 1.0 1.0)
                    (0.0 0.0 0.0 1.0 1.0)
                    (0.0 0.0 0.0 0.0 1.0)
                    (0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix 0 3)
    :row1 0 :column1 2))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row1 0 :column1 2
    :row1-end 3))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (upper-triangular-matrix)
    :row1 0 :column1 2
    :row2-end 3)))
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 1.0 1.0 1.0)
                    (0.0 0.0 1.0 1.0 1.0)
                    (0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)))))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (unit-matrix 3 3)
    :row1 1 :column1 2 :row2-end 2))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
    (unit-matrix 10 10)
    :row1 1 :column1 2 :row1-end 3)))
@
<<Replace the off-diagonal submatrix of the lower triangular matrix>>=
;; Below diagonal submatrix
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)
                    (1.0 0.0 0.0 0.0 0.0)
                    (1.0 1.0 0.0 0.0 0.0)
                    (1.0 1.0 1.0 0.0 0.0)))))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix 0 3)
    :row1 2 :column1 0))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row1 2 :column1 0
    :column1-end 3))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (lower-triangular-matrix)
    :row1 2 :column1 0
    :column2-end 3)))
(let ((array-off (make-array
                  '(5 5) :initial-contents
                  '((0.0 0.0 0.0 0.0 0.0)
                    (0.0 0.0 0.0 0.0 0.0)
                    (0.0 1.0 1.0 0.0 0.0)
                    (0.0 1.0 1.0 0.0 0.0)
                    (0.0 1.0 1.0 0.0 0.0)))))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (unit-matrix 3 3)
    :row1 2 :column1 1 :column2-end 2))
  (assert-float-equal
   array-off
   (linear-algebra:replace-matrix
    (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
    (unit-matrix 10 10)
    :row1 2 :column1 1 :column1-end 3)))
@ Finally, a test is performed to verify that a replacement that would
violate the symmetry of the matrix generates an error.
<<Verify that a replacement that is non upper triangular is an error>>=
;; Non upper triangular subsets
(assert-error
 'error
 (linear-algebra:replace-matrix
  (zero-matrix 5 5 :matrix-type 'linear-algebra:upper-triangular-matrix)
  (unit-matrix 5 3)
  :column1 1))
@
<<Verify that a replacement that is non lower triangular is an error>>=
;; Non lower triangular subsets
(assert-error
 'error
 (linear-algebra:replace-matrix
  (zero-matrix 5 5 :matrix-type 'linear-algebra:lower-triangular-matrix)
  (unit-matrix 5 3)
  :row1 1))
@ 

The final group of tests is generated by the macro
[[test-matrix-validated-range]] for the triangular matrix object.
<<Test: Triangular matrix validated range>>=
;;; Validate a range for an upper triangular matrix.
(define-test upper-triangular-matrix-validated-range
  (test-matrix-validated-range
   'linear-algebra:upper-triangular-matrix 10 10))

;;; Validate a range for an lower triangular matrix.
(define-test lower-triangular-matrix-validated-range
  (test-matrix-validated-range
   'linear-algebra:lower-triangular-matrix 10 10))

@ 

\chapter{Auxiliary Routine Tests}
\label{chap:auxiliary}

The BLAS library relies on many auxiliary routines that are not
presented in the public interface. When it is not obvious where to
categorize those routines, they are collected in an auxiliary routines
file.
<<auxiliary.lisp>>=
<<In linear algebra unit tests>>
<<Test: lapy2>>
<<Test: lapy3>>
<<Test: scaled-binary-op>>
<<Test: common-class-of>>
<<Test: complex-equal>>
<<Test: number-equal>>
@ The auxiliary tests depend on the definition of the linear algebra
test package.
<<Auxiliary dependencies>>=
(:file "auxiliary"
       :depends-on ("defpackage"))
@

\section{Square Root of the Sum of 2 or 3 Squares}
\label{sec:lapy}

The [[lapy2]] function returns the square root of the sum of the
squares of the absolute values of 2 numbers.
<<Test: lapy2>>=
;;; sqrt |x|^2 + |y|^2
(define-test lapy2
  ;; Real values
  (dolist (args (cartesian-product '(-3.0 3.0) '(-4.0 4.0)))
    (assert-float-equal 5.0 (apply #'linear-algebra::lapy2 args)))
  ;; Complex values
  (let ((args1 (mapcar
		(lambda (x) (apply #'complex x))
		(cartesian-product '(-1.1 1.1) '(-2.2 2.2))))
	(args2 (mapcar
		(lambda (x) (apply #'complex x))
		(cartesian-product '(-3.3 3.3) '(-4.4 4.4)))))
    (dolist (args (cartesian-product args1 args2))
      (assert-float-equal 6.024948 (apply #'linear-algebra::lapy2 args)))))

@ Similarly, [[lapy3]] returns the square root of the sum of the
squares of the absolute values of 3 numbers.
<<Test: lapy3>>=
;;; sqrt |x|^2 + |y|^2 + |z|^2
(define-test lapy3
  ;; Real values
  (dolist (args (nary-product '(-2.0 2.0) '(-3.0 3.0) '(-4.0 4.0)))
    (assert-float-equal 5.3851647 (apply #'linear-algebra::lapy3 args)))
  ;; Complex values
  (let ((args1 (mapcar
		(lambda (x) (apply #'complex x))
		(cartesian-product '(-1.1 1.1) '(-2.2 2.2))))
	(args2 (mapcar
		(lambda (x) (apply #'complex x))
		(cartesian-product '(-3.3 3.3) '(-4.4 4.4))))
	(args3 (mapcar
		(lambda (x) (apply #'complex x))
		(cartesian-product '(-5.5 5.5) '(-6.6 6.6)))))
    (dolist (args (nary-product args1 args2 args3))
      (assert-float-equal 10.49333 (apply #'linear-algebra::lapy3 args)))))

@

\section{Binary Operation with Scaled Argument Tests}
\label{sec:scaled-binary-op}

The simplest way to test [[scaled-binary-op]] is to pass the returned
operation to [[FUNCALL]] with numeric arguments and test the
result. This is implemented for variations of scaled addition of
positive floats but should be expanded to include subtraction as well
as negative values.
<<Test: scaled-binary-op>>=
(define-test scaled-binary-op
  (assert-float-equal
   5.0 (funcall (linear-algebra::scaled-binary-op #'+ nil nil) 2.0 3.0))
  (assert-float-equal
   7.0 (funcall (linear-algebra::scaled-binary-op #'+ 2.0 nil) 2.0 3.0))
  (assert-float-equal
   8.0 (funcall (linear-algebra::scaled-binary-op #'+ nil 2.0) 2.0 3.0))
  (assert-float-equal
   10.0 (funcall (linear-algebra::scaled-binary-op #'+ 2.0 2.0) 2.0 3.0)))

@ 

\section{Common Class of Two Objects}
\label{sec:common-class-of}

An array, vector and list object are used to test the function
[[common-class-of]] using a total of 6 tests. The first 4 tests verify
that the correct common class of the two objects is returned. The
fifth test verifies that the default class is returned. The final test
verifies that an error is generated is there is no common class and a
default class has not been specified.
<<Test: common-class-of>>=
(define-test common-class-of
  (let ((object-a (make-array '(3 3) :adjustable t))
        (object-v (make-array 3 :adjustable t))
        (object-l (make-list 3))
        (class-a (find-class 'array))
        (class-v (find-class 'vector))
        (class-t (find-class t)))
    (assert-eq class-a (linear-algebra::common-class-of object-a object-a))
    (assert-eq class-a (linear-algebra::common-class-of object-a object-v))
    (assert-eq class-a (linear-algebra::common-class-of object-v object-a))
    (assert-eq class-v (linear-algebra::common-class-of object-v object-v))
    (assert-eq class-t (linear-algebra::common-class-of object-v object-l t))
    (assert-error 'error (linear-algebra::common-class-of object-v object-l))))

@

\section{Numeric Equality Tests}
\label{sec:numeric-equality}

Two numeric equality tests are defined to wrap [[float-equal]]. The
[[complex-equal]] function returns true if the complex values are
equal. Complex values with float components if the relative error norm
is less than some epsilon. An error is thrown if neither of the values
are complex.
<<Test: complex-equal>>=
(define-test complex-equal
  ;; complex float
  (assert-true (linear-algebra::complex-equal #C(1.0 2.0) #C(1.0 2.0)))
  (assert-true (linear-algebra::complex-equal 1.0 #C(1.0 0.0)))
  (assert-true (linear-algebra::complex-equal #C(1.0 0.0) 1.0))
  (assert-false (linear-algebra::complex-equal #C(1.0 2.0) #C(2.0 1.0)))
  (assert-false (linear-algebra::complex-equal 1.0 #C(0.0 1.0)))
  (assert-false (linear-algebra::complex-equal #C(0.0 1.0) 1.0))
  ;; complex integer
  (assert-true (linear-algebra::complex-equal #C(1 2) #C(1 2)))
  ;; Error
  (assert-error 'error (linear-algebra::complex-equal 1.0 1.0))
  (assert-error 'error (linear-algebra::complex-equal 1 1)))

@ The [[number-equal]] function is valid for comparing any 2 numbers. 
<<Test: number-equal>>=
(define-test number-equal
  ;; float
  (assert-true (linear-algebra::number-equal 2.2 2.2))
  (assert-true (linear-algebra::number-equal 2 2.0))
  (assert-true (linear-algebra::number-equal 2.0 2))
  (assert-false (linear-algebra::number-equal 2 2.2))
  ;; rational
  (assert-true (linear-algebra::number-equal 1/3 1/3))
  (assert-true (linear-algebra::number-equal 3 3))
  (assert-false (linear-algebra::number-equal 1/3 3))
  ;; complex float
  (assert-true (linear-algebra::number-equal #C(1.1 2.2) #C(1.1 2.2)))
  (assert-true (linear-algebra::number-equal #C(1.0 2.0) #C(1 2)))
  (assert-true (linear-algebra::number-equal #C(1 2) #C(1.0 2.0)))
  (assert-false (linear-algebra::number-equal #C(1.1 2.2) #C(2.2 1.1)))
  ;; complex rational
  (assert-true (linear-algebra::number-equal #C(1 2) #C(1 2)))
  (assert-true (linear-algebra::number-equal #C(1/2 1/2) #C(1/2 1/2)))
  (assert-false (linear-algebra::number-equal #C(1 2) #C(1/2 1/2)))
  ;; error
  (assert-error 'error (linear-algebra::number-equal 1 t))
  (assert-error 'error (linear-algebra::number-equal t 1))
  (assert-error 'error (linear-algebra::number-equal t t)))

@

% Bibliography
\bibliography{bibliography}
\bibliographystyle{plain}

\appendix

\chapter{ Package and System Definition}
\label{chap:system-and-package}

The package and system definition are presented in this section. The
system is defined using the ASDF utility.

\section{Linear Algebra Test Package}
\label{sec:linear-algebra-test-package}

In addition to defining the package, several convenience functions and
equality predicates are defined. Unit testing is not performed on
these functions. Basically, these functions must be viewed as axioms.
Some of the routines have utility outside of the linear algebra unit
tests.
<<defpackage.lisp>>=
;;;; Unit Tests for Linear Algebra in Common Lisp

(common-lisp:defpackage #:linear-algebra-test
  (:use #:common-lisp
        #:lisp-unit))

(common-lisp:in-package #:linear-algebra-test)

;;; Convenience functions
<<Function: Random interior index>>
<<Function: Zero matrix>>
<<Function: Unit matrix>>
<<Function: Identity array>>
<<Function: Coordinate array>>
<<Function: Symmetric array>>
<<Function: Hermitian array>>
<<Function: Upper triangular array>>
<<Function: Lower triangular array>>
<<Function: Random permutation vector>>
<<Function: Random permutation array>>
<<Function: Cartesian product>>
<<Function: N-ary Cartesian product>>
;;; Data vector equality
<<Method: Sequence and data vector equality>>
<<Method: Data vector equality>>
;;; Dense matrix equality
<<Method: Nested list and dense matrix equality>>
<<Method: Nested vector and dense matrix equality>>
<<Method: 2D array and dense matrix equality>>
<<Method: Dense matrix equality>>
@

\note{These functions should probably be organized in separate files
  rather than lumped in with the package definition.}

\subsection{Convenience Functions}
\label{sec:convenience-functions}

The testing often picks random interior points of vectors or matrices.
Initially, these points were naively generated directly with the
[[RANDOM]] function. In the course of testing, it was observed that
tests that had previously passed would randomly fail with no changes
having been performed to the code. It was realized that the tests were
failing because the randomly generated indices were not interior. The
following convenience function guarantees that the random index is
interior.
<<Function: Random interior index>>=
(defun random-interior-index (size)
  "Return an interior index that is guaranteed not to be an end
point."
  (check-type size fixnum)
  (cond
    ((= 3 size) 1)
    ((< 3 size)
     (let ((end (1- size)))
       (do ((index (random end) (random end)))
           ((< 0 index end) index))))
    (t (error "Invalid size : ~D." size))))

@

Several convenience functions are provided for generating dense
matrices.  The first function is called with 2 arguments specifying
the number of rows and columns returning a dense zero matrix.
<<Function: Zero matrix>>=
(defun zero-matrix (rows columns &key
                    (matrix-type 'linear-algebra:dense-matrix))
  "Return a ROWSxCOLUMNS zero matrix."
  (linear-algebra:make-matrix
   rows columns
   :matrix-type matrix-type
   :initial-element 0))

@ Similarly, the second function is called with 2 arguments specifying
the number of rows and columns returning a dense unit matrix.
<<Function: Unit matrix>>=
(defun unit-matrix (rows columns &key
                    (matrix-type 'linear-algebra:dense-matrix))
  "Return a ROWSxCOLUMNS unit matrix."
  (linear-algebra:make-matrix
   rows columns
   :matrix-type matrix-type
   :initial-element 1))

@ The first array function returns an identity array of size.
<<Function: Identity array>>=
(defun identity-array (size)
  (let ((the-array (make-array (list size size)
                               :initial-element 0.0)))
    (dotimes (i0 size the-array)
      (setf (aref the-array i0 i0) 1.0))))

@ When testing the [[submatrix]] and [[replace-matrix]] functions, it
is helpful to be able to quickly identify the coordinates of an
element. The [[coordinate-list]] function generates a 10x10 matrix
where the row coordinate is in the ones position and the column
coordinate is in the tenths position of the element.
<<Function: Coordinate array>>=
(defun coordinate-array (&optional
                         (row 0)      (column 0)
                         (row-end 10) (column-end 10))
  "Return an array with the elements denoting the coordinate."
  (cond
    ((not (<= 0 row row-end 10))
     (error "Invalid range of rows (~D:~D)." row row-end))
    ((not (<= 0 column column-end 10))
     (error "Invalid range of columns (~D:~D)." column column-end))
    (t
     (let* ((rows (- row-end row))
            (columns (- column-end column))
            (the-array (make-array (list rows columns))))
       (dotimes (i0 rows the-array)
         (dotimes (i1 columns)
           (setf (aref the-array i0 i1)
                 (+ row i0 (/ (+ column i1) 10.0)))))))))

@ A variation of the [[coordinate-array]] function is implemented to
aid testing of symmetric matrices. It is virtually identical to
[[coordinate-array]] except that the resulting array is symmetric.
<<Function: Symmetric array>>=
(defun symmetric-array (&optional (start 0) (end 10))
  "Return a symmetric array with the element denoting the coordinate."
  (if (<= 0 start end 10)
      (let* ((size (- end start))
             (the-array (make-array (list size size)))
             (val nil))
        (dotimes (i0 size the-array)
          (setf (aref the-array i0 i0)
                (+ start i0 (/ (+ start i0) 10.0)))
          (dotimes (i1 i0)
            (setf val (+ start i0 (/ (+ start i1) 10.0))
                  (aref the-array i0 i1) val
                  (aref the-array i1 i0) val))))
      (error "Invalid range (~D:~D)." start end)))

@ A variation of the [[symmetric-array]] function is implemented to
aid in testing of Hermitian matrices.
<<Function: Hermitian array>>=
(defun hermitian-array (&optional (start 0) (end 10))
  "Return a Hermitian array with the element denoting the coordinate."
  (if (<= 0 start end 10)
      (let* ((size (- end start))
             (the-array (make-array (list size size))))
        (dotimes (i0 size the-array)
          (setf (aref the-array i0 i0)
                (complex (+ 1 start i0) 0))
          (dotimes (i1 i0)
            (setf (aref the-array i0 i1)
                  (complex (+ 1 start i0) (- -1 start i1)))
            (setf (aref the-array i1 i0)
                  (complex (+ 1 start i0) (+ 1 start i1))))))
      (error "Invalid range (~D:~D)." start end)))

@ There are 2 functions for generating triangular arrays. An array
populated with 1.0's above diagonal is generated with
[[upper-triangular-array]].
<<Function: Upper triangular array>>=
(defun upper-triangular-array (&optional (start 0) (end 10))
  "Return a 10x10 list with the element denoting the coordinate."
  (if (<= 0 start end 10)
      (let* ((size (- end start))
             (the-array (make-array (list size size)
                                    :element-type 'single-float
                                    :initial-element 0.0)))
        (dotimes (i1 size the-array)
          (setf (aref the-array i1 i1) 1.0)
          (dotimes (i0 i1)
            (setf (aref the-array i0 i1) 1.0))))
      (error "Invalid range (~D:~D)." start end)))

@ And similarly below the diagonal with [[lower-triangular-array]].
<<Function: Lower triangular array>>=
(defun lower-triangular-array (&optional (start 0) (end 10))
  "Return a 10x10 list with the element denoting the coordinate."
  (if (<= 0 start end 10)
      (let* ((size (- end start))
             (the-array (make-array (list size size)
                                    :element-type 'single-float
                                    :initial-element 0.0)))
        (dotimes (i0 size the-array)
          (setf (aref the-array i0 i0) 1.0)
          (dotimes (i1 i0)
            (setf (aref the-array i0 i1) 1.0))))
      (error "Invalid range (~D:~D)." start end)))

@

Two functions are provided to generate random permutations. A
permutation can be expressed in 2 formats, a vector and an array. The
first function returns a random permutation vector.
<<Function: Random permutation vector>>=
(defun random-permutation-vector (size &optional (counter -1))
  "Return a random permutation vector of SIZE."
  (let ((permutation (map-into (make-array size) (lambda () (incf counter)))))
    (do ((index 0 (1+ index))
         (swap (random size) (random size)))
        ((>= index size) permutation)
      (rotatef (svref permutation index) (svref permutation swap)))))

@ The second function expands the vector into an array.
<<Function: Random permutation array>>=
(defun random-permutation-array (size)
  "Return a random permutation matrix of SIZE."
  (let ((permutation (random-permutation-vector size))
        (the-array (make-array (list size size) :initial-element 0)))
    (dotimes (row size the-array)
      (setf (aref the-array row (svref permutation row)) 1))))

@ 

The Cartesian product of two sets $X$ and $Y$ is the set of all
possible ordered pairs whose first component is a member of $X$ and
whose second component is a member of $Y$.
\begin{equation}
  \label{eq:cartesian-product}
  X \times Y = \{ (x,y) | x \in X \mbox{ and } y \in Y \}
\end{equation}
<<Function: Cartesian product>>=
(defun cartesian-product (list1 list2)
  "Return a list of the Cartesian product of two lists."
  (mapcan (lambda (x) (mapcar (lambda (y) (list x y)) list2)) list1))

@ The Cartesian product can be generalized to $n$ sets.
\begin{equation}
  \label{eq:nary-product}
  X_1 \times \cdots \times X_n = \{(x_1,\ldots,x_n) | x_1 \in X_1
  \mbox{ and } \cdots \mbox{ and } x_n \in X_n \}
\end{equation}
<<Function: N-ary Cartesian product>>=
(defun nary-product (list1 list2 &rest more-lists)
  "Return a list of the n-ary Cartesian product of the lists."
  (if (null more-lists)
      (cartesian-product list1 list2)
      (mapcan
       (lambda (x)
	 (mapcar (lambda (y) (push x y))
		 (apply #'nary-product list2
			(car more-lists) (rest more-lists))))
       list1)))

@ 

\subsection{Data Vector Equality}
\label{sec:data-vector-equality}

[[rational-equal]] and [[float-equal]] are specialized for data
vectors to facilitate testing. Both methods wrap the [[lisp-unit]]
functions that perform element-wise tests for equality on sequences.
The first equality methods are specialized on a [[SEQUENCE]] and
[[data-vector]].
<<Method: Sequence and data vector equality>>=
(defmethod rational-equal ((result1 sequence)
                           (result2 linear-algebra:data-vector))
  (rational-equal
   result1 (linear-algebra::contents result2)))

(defmethod float-equal ((result1 sequence)
                        (result2 linear-algebra:data-vector)
                        &optional (epsilon lisp-unit:*epsilon*))
  (float-equal
   result1 (linear-algebra::contents result2) epsilon))

@ The second equality methods are specialized on 2 data vectors.
<<Method: Data vector equality>>=
(defmethod rational-equal ((result1 linear-algebra:data-vector)
                           (result2 linear-algebra:data-vector))
  (rational-equal (linear-algebra::contents result1)
                  (linear-algebra::contents result2)))

(defmethod float-equal ((result1 linear-algebra:data-vector)
                        (result2 linear-algebra:data-vector)
                        &optional (epsilon lisp-unit:*epsilon*))
  (float-equal (linear-algebra::contents result1)
               (linear-algebra::contents result2)
               epsilon))

@ 

\subsection{Dense Matrix Equality}
\label{sec:dense-matrix-equality}

Four methods of [[numerical-equal]] are specialized to support dense
matrix testing. The first method is specialized for comparison of a
dense matrix with a nested list.
<<Method: Nested list and dense matrix equality>>=
(defmethod rational-equal ((result1 list)
                           (result2 linear-algebra:dense-matrix))
  (let* ((contents (linear-algebra::contents result2))
         (rows (array-dimension contents 0))
         (columns (array-dimension contents 1))
         (data-row nil))
    (when (= rows (length result1))
      (dotimes (i0 rows t)
        (if (= columns
               (length (setf data-row (nth i0 result1))))
            (dotimes (i1 columns)
              (unless (rational-equal (elt data-row i1)
                                      (aref contents i0 i1))
                (return-from rational-equal)))
            (return-from rational-equal))))))

(defmethod float-equal ((result1 list)
                        (result2 linear-algebra:dense-matrix)
                        &optional (epsilon lisp-unit:*epsilon*))
  (let* ((contents (linear-algebra::contents result2))
         (rows (array-dimension contents 0))
         (columns (array-dimension contents 1))
         (data-row nil))
    (when (= rows (length result1))
      (dotimes (i0 rows t)
        (if (= columns
               (length (setf data-row (nth i0 result1))))
            (dotimes (i1 columns)
              (unless (float-equal (elt data-row i1)
                                   (aref contents i0 i1)
                                   epsilon)
                (return-from float-equal)))
            (return-from float-equal))))))

@ The second method is specialized for comparison of a dense matrix
with a nested vector.
<<Method: Nested vector and dense matrix equality>>=
(defmethod rational-equal ((result1 vector)
                           (result2 linear-algebra:dense-matrix))
  (let* ((contents (linear-algebra::contents result2))
         (rows (array-dimension contents 0))
         (columns (array-dimension contents 1))
         (data-row nil))
    (when (= rows (length result1))
      (dotimes (i0 rows t)
        (if (= columns (length
                        (setf data-row (svref result1 i0))))
            (dotimes (i1 columns)
              (unless (rational-equal (elt data-row i1)
                                      (aref contents i0 i1))
                (return-from rational-equal)))
            (return-from rational-equal))))))

(defmethod float-equal ((result1 vector)
                        (result2 linear-algebra:dense-matrix)
                        &optional (epsilon lisp-unit:*epsilon*))
  (let* ((contents (linear-algebra::contents result2))
         (rows (array-dimension contents 0))
         (columns (array-dimension contents 1))
         (data-row nil))
    (when (= rows (length result1))
      (dotimes (i0 rows t)
        (if (= columns (length
                        (setf data-row (svref result1 i0))))
            (dotimes (i1 columns)
              (unless (float-equal (elt data-row i1)
                                   (aref contents i0 i1)
                                   epsilon)
                (return-from float-equal)))
            (return-from float-equal))))))

@ The third method is specialized for comparison of a dense matrix and
a 2D array.
<<Method: 2D array and dense matrix equality>>=
(defmethod rational-equal ((result1 array)
                           (result2 linear-algebra:dense-matrix))
  (rational-equal result1 (linear-algebra::contents result2)))

(defmethod float-equal ((result1 array)
                        (result2 linear-algebra:dense-matrix)
                        &optional (epsilon lisp-unit:*epsilon*))
  (float-equal
   result1 (linear-algebra::contents result2) epsilon))

@ Finally, the method is specialized for comparison of 2 dense
matrices.
<<Method: Dense matrix equality>>=
(defmethod rational-equal ((result1 linear-algebra:dense-matrix)
                           (result2 linear-algebra:dense-matrix))
  (rational-equal (linear-algebra::contents result1)
                  (linear-algebra::contents result2)))

(defmethod float-equal ((result1 linear-algebra:dense-matrix)
                        (result2 linear-algebra:dense-matrix)
                        &optional (epsilon lisp-unit:*epsilon*))
  (float-equal (linear-algebra::contents result1)
               (linear-algebra::contents result2)
               epsilon))

@ 

\section{Linear Algebra Test ASDF}
\label{sec:linear-algebra-test-asdf}

Numerical linear algebra unit testing is distributed under the BSD
copyright.
<<BSD Copyright>>=
#|

 Linear Algebra in Common Lisp Unit Tests

 Copyright (c) 2010, Thomas M. Hermann
 All rights reserved.

 Redistribution and  use  in  source  and  binary  forms, with or without
 modification, are permitted  provided  that the following conditions are
 met:

   o  Redistributions of  source  code  must  retain  the above copyright
      notice, this list of conditions and the following disclaimer.
   o  Redistributions in binary  form  must reproduce the above copyright
      notice, this list of  conditions  and  the  following disclaimer in
      the  documentation  and/or   other   materials  provided  with  the
      distribution.
   o  The names of the contributors may not be used to endorse or promote
      products derived from this software without  specific prior written
      permission.

 THIS SOFTWARE IS  PROVIDED  BY  THE  COPYRIGHT  HOLDERS AND CONTRIBUTORS
 "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES, INCLUDING,  BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR  CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED TO,
 PROCUREMENT OF  SUBSTITUTE  GOODS  OR  SERVICES;  LOSS  OF USE, DATA, OR
 PROFITS; OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER  IN  CONTRACT,  STRICT  LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR  OTHERWISE)  ARISING  IN  ANY  WAY  OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

|#

@ 

<<linear-algebra-test.asd>>=
;;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp -*-
<<BSD Copyright>>
;;;  ASDF system definition for linear algebra unit tests
(common-lisp:defpackage #:linear-algebra-test-system
  (:use #:common-lisp #:asdf))

(common-lisp:in-package #:linear-algebra-test-system)

(defsystem :linear-algebra-test
  :description "Unit Tests for Linear Algebra in Common Lisp"
  :version "Draft"
  :author "Thomas M. Hermann <tmh.public@gmail.com>"
  :license "BSD"
  :components
  ((:module linear-algebra-test
            :components
            ((:file "defpackage")
             <<Vector test dependencies>>
             <<Data vector test dependencies>>
             <<Matrix dependencies>>
             <<Identity matrix dependencies>>
             <<Permutation matrix dependencies>>
             <<Dense matrix dependencies>>
             <<Square matrix dependencies>>
             <<Hermitian matrix dependencies>>
             <<Symmetric matrix dependencies>>
             <<Triangular matrix dependencies>>
             <<Auxiliary dependencies>>)))
  :depends-on ("lisp-unit" "linear-algebra"))

@

\end{document}
