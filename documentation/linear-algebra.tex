% ===> this file was generated automatically by noweave --- better not edit it
\documentclass{report}%

\pdfinfo{
  /Title (Numerical Linear Algebra in ANSI Common Lisp)
  /Author (Thomas M. Hermann)
  /CreationDate (D:20080328190108-05'00)
  /ModDate (D:20100402125500-05'00)
  /Subject (Linear Algebra)
  /Keywords (Linear Algebra) }

\usepackage{noweb}%
\usepackage{amssymb,amsmath}%
\usepackage[pdftex]{xcolor,graphicx}%
\usepackage{cite}%
\usepackage{nomencl}%
\usepackage{algorithm}%
\usepackage{algorithmic}%

\noweboptions{smallcode}%

\newcommand{\abs}[1]{\lvert#1\rvert}%
\newcommand{\norm}[1]{\lVert#1\rVert}%

\newcommand{\result}{\mbox{result}}%
\newcommand{\typespec}[1]{\textbf{#1}\hfill Type Specifier\\}%
\newcommand{\function}[1]{\textbf{#1} \hfill Function\\}%
\newcommand{\macro}[1]{\textbf{#1} \hfill Macro\\}%
\newcommand{\note}[1]{
  \setlength{\fboxsep}{5pt}
  \medskip\noindent\ignorespaces
  \begin{center}
  \fbox{\parbox{0.9\textwidth}{\textbf{Note: }#1}}
  \end{center}
  \par\medskip
  \setlength{\fboxsep}{3pt}
}%

\title{Numerical Linear Algebra in ANSI Common Lisp}%

\author{Thomas M. Hermann}%

\makeglossary%

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

%\printglossary%

\chapter{Introduction}
\label{chap:introduction}

Numerical linear algebra is a fundamental component of scientific and
engineering computing. Though a wide range of solutions are obtained
using numerical linear algebra, the most common are for systems of
linear equations, least squares, eigenvalues and singular value
decomposition.\cite{linear-algebra} A Fortran~77 library of standard
routines for these solutions, LAPACK\cite{lapack}, was initially
released in 1992 and has been in continual developement since then.
The majority of the routines in the LAPACK library are expressed in
terms of the Basic Linear Algebra Subroutines
(BLAS)\cite{blas:1,blas:2,blas:3}. An effort to update the BLAS
library was started in November of 1995 with the first meeting of the
BLAS Technical Forum\cite{blast-update}. This effort culminated with
the release of the Basic Linear Algebra Subprograms Technical(BLAST)
Forum Standard\cite{blast-report}. The objective of this project is to
generate linear algebra routines in native ANSI Common Lisp leveraging
the knowledge captured in the BLAST Forum Standard.

\nomenclature{BLAS}{Basic Linear Algebra Subprograms.}

\section{Motivation}
\label{sec:motivation}

\emph{The motivation section is only a sketch. Emphasized text simply
  notes what needs to be discussed.}

A numerical linear algebra library with a standard application
programming interface(API) facilitates development of numerical
software through code reuse and portability. Furthermore, a standard
API enables the development of high performance libraries customized
for a specific platform. The adoption by the scientific and
engineering community of the LAPACK and BLAS libraries demonstrated
the value of these attributes\cite{blast-update}. A native Common Lisp
numerical linear algebra library would facilitate the development of
scientific and engineering software in Common Lisp.

\emph{Performance paragraph} Lisp has the reputation of lacking
sufficient floating point performance\cite{cl-float} for use in
scientific and engineering applications. There is no technical basis
for this reputation. To the contrary, examples of Lisp implementations
geared towards numerical computations are provided in Steele and
Gabriel\cite{lisp-evolution}. An early critique\cite{cl-critique} of
Common Lisp does note several issues that impact numeric performance.
Some of these issues have been addressed by compilers such as
CMUCL\cite{CMUCL} and by advances in hardware.\textbf{Expand this
  discussion.}

\emph{FFI paragraph} To the GNU Scientific library: GSLL and NLISP.
BLAS and LAPACK are through MatLisp. The BLAS and LAPACK libraries
were written in Fortran~77. The BLAST Forum
Standard\cite{blast-report} provides specifications for Fortran~95,
Fortran~77 and C versions of the library. FFI generally results in the
best performance. While the objective of this project is development
of a native CL linear algebra library, the library API could be used
as an abstraction layer for an FFI to other languages. Then, code
written to the interface would use the best available implementation.

\emph{F2CL paragraph. Maxima gets LAPACK through F2CL.}

\emph{Symbolic mathematics paragraph. MACSYMA references and current
  Maxima.}

\emph{Wrapup paragraph} Gain experience with Common Lisp. Not
constrained by the limitations of other programming languages. Able to
design the library to leverage the strengths of Common Lisp.
Performance difference less significant than development time.
Availability and use of a numerical linear algebra library in Common
Lisp would spur improvements in compilers that would improve
performance.  Focusing on developing the API, will address performance
in future releases.

\nomenclature{API}{Application Programming Interface.}
\nomenclature{ANSI}{American National Standards Institute.}
\nomenclature{FFI}{Foreign Function Interface.}

\section{Design and Implementation}
\label{sec:design}

The first release of this library is focused on correctness,
completeness and interface design. Performance was not a consideration
in the initial design. Performance will be addressed in future
releases. Mixed argument operations are not explicitly handled, the
standard behavior of Common Lisp is used.

The correctness is established by implementing algorithms that are
documented to be correct. The algoritms are implemented from the
BLAS\cite{blas:1,blas:2,blas:3}, BLAST\cite{blast-report},
LAPACK\cite{lapack}, Demmel\cite{linear-algebra}, LAPACK working notes
and other references. The correctness of the implementation is then
verified through the unit testing.

Performance issues will be addressed when the interface is frozen and
the unit testing is in place to verify the correctness of the
algorithms. Performance improvements should be conducted using a
2-step process. First, the algorithm of the poorly performing routine
should be audited. Improvements to the algorithm that have no or
little data type considerations will be implemented in this step.

Finally, when the algorithms have been sufficiently audited and
improved, data type considerations should be addressed. The default
for the library should be to rely on the underlying Common Lisp
implementation to handle the types appropriately. A mechanism for
specifying the floating point type should be implemented, though. This
mechanism should be comprised of a special variable, for example
{\Tt{}LINEAR-ALGEBRA:*PRECISION*\nwendquote}, that can be set to {\Tt{}SINGLE-FLOAT\nwendquote} or
{\Tt{}DOUBLE-FLOAT\nwendquote}. Next, a set of macros should be implemented that
indicate the type throughout the code based on the value of
{\Tt{}*PRECISION*\nwendquote}. Constants such as {\Tt{}LINEAR-ALGEBRA:*ZERO*\nwendquote} and
{\Tt{}LINEAR-ALGEBRA:*ONE*\nwendquote} should be defined that are the appropriate
type based on {\Tt{}*PRECISION*\nwendquote}. These constants should be used
throughout the code to aid type inference.

All routines are defined in the ``Linear Algebra'' package.
\nwfilename{noweb/linear-algebra.noweb}\nwbegincode{1}\moddef{In linear algebra package}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}BSD Copyright\RA{}
(common-lisp:in-package :linear-algebra)

\nwendcode{}\nwbegindocs{2}\nwdocspar

\section{Open Topics}
\label{sec:open-topics}

\begin{itemize}
\item Banded matrices
\item Sparse matrices
\item Tensor objects and routines
\item Type specific routines
\item Exception handling(underflow, overflow, etc.)
\item IEEE 754 hardware exception handling
\item SMP capabilities
\item Distributed capabilities, possibly MPI.
\end{itemize}

Performance improvements
\begin{itemize}
\item uni-processor performance.
\item Vectorization.
\item SMP performance.
\item Distributed performance, possibly MPI.
\item Native code generation.
\end{itemize}

A tensor object needs to be designed and integrated into the library.
This may require a modification of the interface.

The performance releases will also try to improve the native code
generation for targeted platforms. The targeted performance platforms
are SBCL, CCL, and Lispworks\emph{Add CMUCL?}. After performance
benchmarks have been developed, an evaluation of Scieneer Common Lisp
will be performed.The code will also be tested on clisp and ecl. When
the interface is established, versions of the library relying on FFI
to Fortran routines may also be implemented.

Minimal error checking is performed in the current implementation.
When the interface is established, an error condition system will be
implemented that improves the error reporting for the user.

Exception handling is generally not implemented. The default exception
handling should rely on Common Lisp exception facilities. The ability
to utilize IEEE~754 hardware exception handling should be provided as
well.

\chapter{Fundamental Operations}
\label{chap:fundamental-operations}

Operations in LAPACK are expressed to the greatest extent possible in
terms of BLAS operations. Expressing the linear algebra operations in
terms of core operations reduces errors and allows optimizations
implemented in the core operations to be propogated to the
higher-level operations. The fundamental linear algebra operations
summarized in Table~\ref{tab:fundamental-ops} are based on a review of
the BLAS Technical Forum documentation\cite{blast-report}. These
operations provide the fundamental building blocks necessary for
higher level linear algebra operations.
\nwenddocs{}\nwbegincode{3}\moddef{fundamental-ops.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Generic function: Scaled sum of squares\RA{}
\LA{}Generic function: Scaled sum of powers of p\RA{}
\LA{}Generic function: Vector and matrix norms\RA{}
\LA{}Generic function: Transpose of a vector or matrix\RA{}
\LA{}Generic function: Destructive transpose of a vector or matrix\RA{}
\LA{}Generic function: Permutation of a vector or matrix\RA{}
\LA{}Generic function: Destructive permutation of a vector or matrix\RA{}
\LA{}Generic function: Scale the vector or matrix\RA{}
\LA{}Generic function: Destructively scale the vector or matrix\RA{}
\LA{}Generic function: Vector or matrix binary addition\RA{}
\LA{}Generic function: Destructive vector or matrix binary addition\RA{}
\LA{}Generic function: Vector or matrix binary subtraction\RA{}
\LA{}Generic function: Destructive vector or matrix binary subtraction\RA{}
\LA{}Generic function: Vector or matrix product\RA{}
\nwendcode{}\nwbegindocs{4}The fundamental operations depend on the linear algebra package
definition.
\nwenddocs{}\nwbegincode{5}\moddef{Fundamental operation dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "fundamental-ops"
       :depends-on ("defpackage"))
\nwendcode{}\nwbegindocs{6}\nwdocspar
\begin{table}
  \centering
  \caption{Fundamental linear algebra operations.}
  \begin{tabular}{p{0.2\textwidth}p{0.75\textwidth}}
    \hline
    Operation      & Description\\
    \hline
    {\Tt{}sumsq\nwendquote}      & Return the scaling parameter and sum of the
                     squares. \\ 
    {\Tt{}sump\nwendquote}       & Return the scaling parameter and sum of the P
                     powers. \\ 
    {\Tt{}norm\nwendquote}       & Vector and matrix norms.\\
    {\Tt{}transpose\nwendquote}  & Transpose the vector or matrix.\\
    {\Tt{}ntranspose\nwendquote} & Destructive transpose of the vector or matrix.\\
    {\Tt{}permute\nwendquote}    & Permute the vector or matrix.\\
    {\Tt{}npermute\nwendquote}   & Destructively permute the vector or matrix.\\
    {\Tt{}scale\nwendquote}      & Scale each element of the vector or matrix.\\
    {\Tt{}nscale\nwendquote}     & Destructively scale each element of the vector
                     or matrix.\\
    {\Tt{}add\nwendquote}        & Vector or matrix binary addition.\\
    {\Tt{}nadd\nwendquote}       & Destructive vector or matrix binary addition.\\
    {\Tt{}subtract\nwendquote}   & Vector or matrix binary subtraction.\\
    {\Tt{}nsubtract\nwendquote}  & Destructive vector or matrix binary subtraction.\\
    {\Tt{}product\nwendquote}    & Vector-vector, matrix-vector and matrix-matrix
                     product.\\
    \hline
  \end{tabular}
  \label{tab:fundamental-ops}
\end{table}

\note{The current implementation of the fundamental operations for
  data vectors, dense matrices and the respective subclasses rely on
  the internal representation of the data. It may be useful to
  implement these fundamental operations in terms of the data
  operations. For new classes, only the data operations for a class
  would need to be implemented. Then, as performance requirements
  dictated, class specific implementations of the fundamental
  operations could be generated. A flaw in this approach is that it
  may not be possible to determine the proper type of the new matrix
  returned, for example, from {\Tt{}add\nwendquote}.}

\section{Scaled Vector and Matrix Sums}
\label{sec:scaled-vector-and-matrix-sums}

Scaled vector and matrix sums are primarily required to support vector
and matrix norms. {\Tt{}sumsq\nwendquote} returns 2 values, the scaling parameter
and the sum of the squares. The function iterates through the elements
of the vector or matrix updating {\Tt{}scale\nwendquote} and {\Tt{}sumsq\nwendquote} so that they
satisfy Equation~\ref{eq:sumsq}.
\begin{subequations}
  \label{eq:result-sumsq}
  \begin{align}
    (scale, sumsq) & \leftarrow \sum_i x_i^2
    \label{eq:vector-result-sumsq} \\
    (scale, sumsq) & \leftarrow \sum_i \sum_j A_{ij}^2
    \label{eq:matrix-result-sumsq}
  \end{align}
\end{subequations}
such that
\begin{subequations}
  \label{eq:sumsq}
  \begin{align}
    scale^2 \times sumsq & = \sum_i x_i^2
    \label{eq:vector-sumsq} \\
    scale^2 \times sumsq & = \sum_i \sum_j A_{ij}^2
    \label{eq:matrix-sumsq}
  \end{align}
\end{subequations}
where $scale \leftarrow \max ( scale,\abs{x}_i )$ for vectors and
$scale \leftarrow \max ( scale, \abs{A}_{ij} )$ for matrices.
\nwenddocs{}\nwbegincode{7}\moddef{Generic function: Scaled sum of squares}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric sumsq (vector-or-matrix &key scale sumsq)
  (:documentation
   "Return the scaling parameter and the sum of the squares."))

\nwendcode{}\nwbegindocs{8}Similarly, {\Tt{}sump\nwendquote} returns 2 values, the scaling parameter and the
sum of the P powers of the absolute values of the vector or matrix.
The function iterates through the vector or matrix updating the
scaling parameter and the sum so that they satisfy
Equation~\ref{eq:sump}.
\begin{subequations}
  \label{eq:result-sump}
  \begin{align}
    (scale, sump) & \leftarrow \sum_i x_i^p
    \label{eq:vector-result-sump} \\
    (scale, sump) & \leftarrow \sum_i \sum_j A_{ij}^p
    \label{eq:matrix-result-sump} \\
  \end{align}
\end{subequations}
such that
\begin{subequations}
  \label{eq:sump}
  \begin{align}
    scale^p \times sump & = \sum_i x_i^p
    \label{eq:vector-sump} \\
    scale^p \times sump & = \sum_i \sum_j A_{ij}^p
    \label{eq:matrix-sump}
  \end{align}
\end{subequations}
where $scale \leftarrow \max ( scale,\abs{x}_i )$ for vectors and
$scale \leftarrow \max ( scale, \abs{A}_{ij} )$ for matrices.
\nwenddocs{}\nwbegincode{9}\moddef{Generic function: Scaled sum of powers of p}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric sump (vector-or-matrix p &key scale sump)
  (:documentation
   "Return the scaling parameter and the sum of the P powers."))

\nwendcode{}\nwbegindocs{10}{\Tt{}sumsq\nwendquote} and {\Tt{}sump\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{11}\moddef{Fundamental operation exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:sumsq :sump
\nwendcode{}\nwbegindocs{12}\nwdocspar

\note{The keyword arguments for {\Tt{}SUMSQ\nwendquote} and {\Tt{}SUMP\nwendquote} are present to
  mirror the argument list of {\Tt{}LASSQ\nwendquote} and friends subroutines in
  LAPACK. It appears that these are present to facilitate using
  {\Tt{}LASSQ\nwendquote} with arrays. If this can be verified, these keywords
  should be removed from the lambda list.}

\section{Vector and Matrix Norms}
\label{sec:vecotr-and-matrix-norms}

The {\Tt{}norm\nwendquote} function returns the norm of the vector or matrix
according to the measure. There is one required argument, either a
vector or a matrix, and one keyword argument, the measure of the norm.
\begin{subequations}
  \label{eq:norm}
  \begin{align}
    \result & \leftarrow \norm{x}_p \label{eq:vector-norm} \\
    \result & \leftarrow \norm{A}_p \label{eq:matrix-norm} 
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{13}\moddef{Generic function: Vector and matrix norms}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric norm (vector-or-matrix &key measure)
  (:documentation
   "Return the norm according to measure."))

\nwendcode{}\nwbegindocs{14}{\Tt{}norm\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{15}\moddef{Fundamental operation exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:norm
\nwendcode{}\nwbegindocs{16}\nwdocspar

Three specific vector norms, equation~\eqref{eq:vector-norm}, are
implemented, listed in Table~\ref{tab:vector-norms}. The default norm
is the taxicab, or one, norm. It is the sum of the absolute values of
the vector elements. The next norm is the Euclidean, or two, norm. It
is the square root of the sum of the squares of the vector elements.
The last specific norm is the infinity norm. It is simply the maximum
of the absolute values of the vector elements. All other measures are
handled by the general P-norm.
\begin{table}
  \centering
  \caption{Vector norms.}
  \begin{tabular}{ll@{=}c}
    \hline
    Vector Norm & \multicolumn{2}{c}{}  \\
    \hline
    Taxicab   & $\norm{x}_1$ & $\sum_i \abs{x_i}$ \\
    Euclidean & $\norm{x}_2$ &
                $\Bigl( \sum_i \abs{x_i}^2 \Bigr)^{1/2}$ \\
    P-norm    & $\norm{x}_p$ &
                $\Bigl( \sum_i \abs{x_i}^p \Bigr)^{1/p}$ \\
    Infinity  & $\norm{x}_\infty$ & $\max_i \abs{x_i}$ \\
    \hline
  \end{tabular}
  \label{tab:vector-norms}
\end{table}

Four specific matrix norms, equation~\eqref{eq:matrix-norm}, are
implemented, listed in Table~\ref{tab:matrix-norms}. The default norm
is the 1 norm. It is the maximum of the sums of the matrix columns.
The second norm is the max norm that is the maximum of the absolute
values of the elements.  Next is the Frobenius norm that is the matrix
equivalent of the vector Euclidean norm. Finally, the infinity norm of
a matrix is the maximum of the sums of the matrix rows.
\begin{table}
  \centering
  \caption{Matrix norms.}
  \begin{tabular}{ll@{=}c}
    \hline
    Matrix Norm & \multicolumn{2}{c}{} \\
    \hline
    1-norm    & $\norm{A}_1$ & $\max_j \sum_i \abs{a_{ij}}$ \\
    Max       & $\norm{A}_{max}$ & $\max\Bigl\{\abs{a_{ij}}\Bigr\}$ \\
    Frobenius & $\norm{A}_F$ &
                $\Bigl( \sum_{ij} \abs{a_{ij}}^2 \Bigr)^{1/2}$ \\
    Infinity  & $\norm{A}_\infty$ & $\max_i \sum_j \abs{a_{ij}}$ \\
    \hline
  \end{tabular}
  \label{tab:matrix-norms}
\end{table}

\section{Vector and Matrix Transpose}
\label{sec:vector-and-matrix-transpose}

The {\Tt{}transpose\nwendquote} function returns the transpose or conjugate
transpose of a vector or matrix. It has one required argument that is
either the vector or matrix. There is a {\Tt{}conjugate\nwendquote} keyword that is
only applicable to complex valued vectors or matrices.  Setting
{\Tt{}conjugate\nwendquote} to true returns the conjugate transpose. The
{\Tt{}conjugate\nwendquote} keyword has no effect on real valued vectors or
matrices.A new vector or matrix is returned from {\Tt{}transpose\nwendquote}.
\begin{subequations}
  \label{eq:transpose}
  \begin{align}
    \result & \leftarrow x^T \label{eq:vector-transpose} \\
    \result & \leftarrow x^* \label{eq:vector-conjugate-transpose} \\
    \result & \leftarrow A^T \label{eq:matrix-transpose} \\
    \result & \leftarrow A^* \label{eq:matrix-conjugate-transpose}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{17}\moddef{Generic function: Transpose of a vector or matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric transpose (vector-or-matrix &key conjugate)
  (:documentation
   "Transpose the vector or matrix."))

\nwendcode{}\nwbegindocs{18}The destructive transpose, {\Tt{}ntranspose\nwendquote}, updates the vector or
matrix.
\begin{subequations}
  \label{eq:destructive-transpose}
  \begin{align}
    x & \leftarrow x^T \label{eq:vector-ntranspose} \\
    x & \leftarrow x^* \label{eq:vector-conjugate-ntranspose} \\
    A & \leftarrow A^T \label{eq:matrix-ntranspose} \\
    A & \leftarrow A^* \label{eq:matrix-conjugate-ntranspose}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{19}\moddef{Generic function: Destructive transpose of a vector or matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric ntranspose (vector-or-matrix &key conjugate)
  (:documentation
   "Destructively transpose the vector or matrix."))

\nwendcode{}\nwbegindocs{20}{\Tt{}transpose\nwendquote} and {\Tt{}ntranspose\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{21}\moddef{Fundamental operation exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:transpose :ntranspose
\nwendcode{}\nwbegindocs{22}\nwdocspar

\section{Vector and Matrix Permutation}
\label{sec:vector-and-matrix-permutation}

The {\Tt{}permute\nwendquote} function applies a permutation matrix to a vector or
matrix and accepts 2 arguments. The permutation can be applied to
either the rows or the columns depending on the order of the
arguments. If the first argument is the permutation matrix and the
second argument the vector or matrix, the rows are permuted. If the
first argument is the vector or matrix and the second argument is the
permutation matrix, the columns are permuted. A new vector or matrix
is returned from this function.
\begin{subequations}
  \label{eq:permutation}
  \begin{align}
    \result & \leftarrow Px \label{eq:column-vector-permutation} \\
    \result & \leftarrow xP \label{eq:row-vector-permutation} \\
    \result & \leftarrow PA \label{eq:matrix-row-permutation} \\
    \result & \leftarrow AP \label{eq:matrix-column-permutation}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{23}\moddef{Generic function: Permutation of a vector or matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric permute (vector-or-matrix vector-or-matrix)
  (:documentation
   "Permute the vector or matrix."))

\nwendcode{}\nwbegindocs{24}{\Tt{}npermute\nwendquote} destructively permutes the vector or matrix.
\begin{subequations}
  \label{eq:destructive-permutation}
  \begin{align}
    x & \leftarrow Px \label{eq:column-vector-npermutation} \\
    x & \leftarrow xP \label{eq:row-vector-npermutation} \\
    A & \leftarrow PA \label{eq:matrix-row-npermutation} \\
    A & \leftarrow AP \label{eq:matrix-column-npermutation}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{25}\moddef{Generic function: Destructive permutation of a vector or matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric npermute (vector-or-matrix vector-or-matrix)
  (:documentation
   "Destructively permute the vector or matrix."))

\nwendcode{}\nwbegindocs{26}{\Tt{}permute\nwendquote} and {\Tt{}npermute\nwendquote} are an exported symbols.
\nwenddocs{}\nwbegincode{27}\moddef{Fundamental operation exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:permute :npermute
\nwendcode{}\nwbegindocs{28}\nwdocspar

\section{Vector and Matrix Scaling}
\label{sec:vector-and-matrix-scaling}

The {\Tt{}scale\nwendquote} function scales each element of the vector or matrix by
a scalar. Two arguments are required, the scalar multiple and the
vector or matrix to be scaled. A new vector or matrix is returned from
this function.
\begin{subequations}
  \label{eq:scale}
  \begin{align}
    \result & \leftarrow scalar \times x \label{eq:vector-scale} \\
    \result & \leftarrow scalar \times A \label{eq:matrix-scale}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{29}\moddef{Generic function: Scale the vector or matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric scale (scalar vector-or-matrix)
  (:documentation
   "Scale each element by the scalar."))

\nwendcode{}\nwbegindocs{30}The destructive version, {\Tt{}nscale\nwendquote}, updates the vector or matrix.
\begin{subequations}
  \label{eq:destructive-scale}
  \begin{align}
    x & \leftarrow scalar \times x \label{eq:vector-nscale} \\
    A & \leftarrow scalar \times A \label{eq:matrix-nscale}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{31}\moddef{Generic function: Destructively scale the vector or matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric nscale (scalar vector-or-matrix)
  (:documentation
   "Destructively scale each element by the scalar."))

\nwendcode{}\nwbegindocs{32}{\Tt{}scale\nwendquote} and {\Tt{}nscale\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{33}\moddef{Fundamental operation exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:scale :nscale
\nwendcode{}\nwbegindocs{34}\nwdocspar

\section{Vector and Matrix Addition}
\label{sec:vector-and-matrix-addition}

The {\Tt{}add\nwendquote} function returns the addition of 2 vectors or matrices,
optionally scaled.  Two arguments are required, the 2 vectors or
matrices to perform addition on. The scalar values are specified using
keywords. A new vector or matrix is returned from {\Tt{}add\nwendquote}.
\begin{subequations}
  \label{eq:addition}
  \begin{align}
    \result & \leftarrow scalar1 \times x_1 + scalar2 \times x_2
    \label{eq:vector-addition} \\
    \result & \leftarrow scalar1 \times A_1 + scalar2 \times A_2
    \label{eq:matrix-addition}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{35}\moddef{Generic function: Vector or matrix binary addition}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric add (vector-or-matrix-1 vector-or-matrix-2
                 &key scalar1 scalar2)
  (:documentation
   "Vector or matrix binary addition."))

\nwendcode{}\nwbegindocs{36}The destructive version, {\Tt{}nadd\nwendquote}, updates the first vector or
matrix.
\begin{subequations}
  \label{eq:destructive-addition}
  \begin{align}
    x_1 & \leftarrow scalar1 \times x_1 + scalar2 \times x_2
    \label{eq:vector-naddition} \\
    A_1 & \leftarrow scalar1 \times A_1 + scalar2 \times A_2
    \label{eq:matrix-naddition}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{37}\moddef{Generic function: Destructive vector or matrix binary addition}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric nadd (vector-or-matrix-1 vector-or-matrix-2
                  &key scalar1 scalar2)
  (:documentation
   "Destructive vector or matrix addition."))

\nwendcode{}\nwbegindocs{38}{\Tt{}add\nwendquote} and {\Tt{}nadd\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{39}\moddef{Fundamental operation exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:add :nadd
\nwendcode{}\nwbegindocs{40}\nwdocspar

\section{Vector and Matrix Subtraction}
\label{sec:vector-and-matrix-subtraction}

The {\Tt{}subtract\nwendquote} function returns the subtraction of a vector or
matrix from a vector or matrix, respectively. Two arguments are
required, the 2 vectors or matrices to operate on. The vectors or
matrices are optionally scaled by scalars specified with keywords. The
subtraction is performed by subtracting the elements of the second
argument from the elements of the first argument. A new vector or
matrix is returned from {\Tt{}subtract\nwendquote}.
\begin{subequations}
  \label{eq:subtraction}
  \begin{align}
    \result & \leftarrow scalar1 \times x_1 - scalar2 \times x_2
    \label{eq:vector-subtraction} \\
    \result & \leftarrow scalar1 \times A_1 - scalar2 \times A_2
    \label{eq:matrix-subtraction}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{41}\moddef{Generic function: Vector or matrix binary subtraction}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric subtract (vector-or-matrix-1 vector-or-matrix-2
                      &key scalar1 scalar2)
  (:documentation
   "Vector or matrix binary subtraction."))

\nwendcode{}\nwbegindocs{42}The destructive version, {\Tt{}nsubtract\nwendquote}, updates the first vector or
matrix.
\begin{subequations}
  \label{eq:destructive-subtraction}
  \begin{align}
    x_1 & \leftarrow scalar1 \times x_1 - scalar2 \times x_2
    \label{eq:vector-nsubtraction} \\
    A_1 & \leftarrow scalar1 \times A_1 - scalar2 \times A_2
    \label{eq:matrix-nsubtraction}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{43}\moddef{Generic function: Destructive vector or matrix binary subtraction}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric nsubtract (vector-or-matrix-1 vector-or-matrix2
                       &key scalar1 scalar2)
  (:documentation
   "Destructive vector or matrix subtraction."))

\nwendcode{}\nwbegindocs{44}{\Tt{}subtract\nwendquote} and {\Tt{}nsubtract\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{45}\moddef{Fundamental operation exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:subtract :nsubtract
\nwendcode{}\nwbegindocs{46}\nwdocspar

\note{The subtraction function is in a sense redundant to the addition
  function. This could be resolved in a couple ways. The first way
  would be to only provide the addition function and perform
  subtraction by passing a negative value for the second scalar. The
  second way would be to abstract binary combination out to a general
  function that is wrapped by {\Tt{}addition\nwendquote} and {\Tt{}subtraction\nwendquote}.}

\section{Vector and Matrix Product}
\label{sec:vector-and-matrix-product}

{\Tt{}product\nwendquote} is the interface to the vector dot product, matrix-vector
product and matrix-matrix product operations. There are 2 required
arguments and 2 keyword arguments, {\Tt{}scalar\nwendquote} and {\Tt{}conjugate\nwendquote}.
Matrix-vector product implementations require a matrix and a vector
argument. If the matrix is pre-multiplied by the vector, the first
argument must be a row vector and the second argument a matrix.
Otherwise, the first argument is a matrix and the second argument is a
column vector. A new vector is returned from matrix-vector products.
A new matrix is returned from matrix-matrix products.
\begin{subequations}
  \label{eq:product}
  \begin{align}
    \result & \leftarrow scalar \times x^T y
            = scalar \times \sum_i x_i y_i
              \label{eq:vector-vector} \\
    \result & \leftarrow scalar \times x^* y
            = scalar \times \sum_i \bar{a}_i y_i
              \label{eq:conjugate-vector-vector} \\
    \result & \leftarrow scalar \times x^T A
            = scalar \times \sum_i x_i A_{ij}
              \label{eq:vector-matrix} \\
    \result & \leftarrow scalar \times x^* A
            = scalar \times \sum_i \bar{x}_i A_{ij}
              \label{eq:conjugate-vector-vector} \\
    \result & \leftarrow scalar \times A x
            = scalar \times \sum_j A_{ij} x_j
              \label{eq:matrix-vector} \\
    \result & \leftarrow scalar \times A B
            = scalar \times \sum_k A_{ik} B_{kj}
              \label{eq:matrix-matrix}
  \end{align}
\end{subequations}
\nwenddocs{}\nwbegincode{47}\moddef{Generic function: Vector or matrix product}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric product (vector-or-matrix-1 vector-or-matrix-2 &key scalar)
  (:documentation
   "Return the vector-vector, matrix-vector or matrix-matrix product."))

\nwendcode{}\nwbegindocs{48}{\Tt{}product\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{49}\moddef{Fundamental operation exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:product
\nwendcode{}\nwbegindocs{50}\nwdocspar

\note{Need to add the conjugate keyword to the lambda list.}

\note{The BLAS xxMV routines and GEMM routine have optional transpose
  arguments. In the case of matrix-vector products, it is presumed
  that the transpose argument indicates whether it is a vector-matrix
  or matrix-vector product. In this library, this is handled using
  generic dispatch. For example, it is valid to only pre-multiply a
  matrix by a row vector. In the case of the GEMM routine, the
  transpose arguments account for matrix-matrix product with
  non-square matrices. This is automatically handled in this library.
  Consequently, there is no need for a transpose keyword that is
  analogous to BLAS optional argument. The presumption for this will
  be verified once the entire library is implemented. If this
  presumption is wrong, a transpose keyword will be added.}

\chapter{Vectors}
\label{chap:vectors}

A linear algebra vector object is defined in this chapter using the
Common Lisp Object System(CLOS). It is the superclass for all linear
algebra vectors. In the next chapter, a specific implementation, the
data vector, is defined with 2 subclasses for row and column vectors.
\nwenddocs{}\nwbegincode{51}\moddef{vector.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Class: Vector superclass\RA{}
\LA{}Vector interface operations\RA{}
\LA{}Vector iteration operations\RA{}
\LA{}Vector transformations\RA{}
\nwendcode{}\nwbegindocs{52}Definition of vectors depends on the linear algebra package and
fundamental operations.
\nwenddocs{}\nwbegincode{53}\moddef{Vector dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "vector"
       :depends-on ("defpackage"
                    "fundamental-ops"))
\nwendcode{}\nwbegindocs{54}\nwdocspar

All vector objects are a subclass of the {\Tt{}vector-object\nwendquote} superclass.
No presumptions are made about the internal storage of the vector
data, therefore, this superclass has no slots.
\nwenddocs{}\nwbegincode{55}\moddef{Class: Vector superclass}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Linear algebra vector superclass
(defclass vector-object ()
  ()
  (:documentation
   "Linear algebra vector superclass."))

\nwendcode{}\nwbegindocs{56}{\Tt{}vector-object\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{57}\moddef{Vector exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:vector-object
\nwendcode{}\nwbegindocs{58}\nwdocspar

\note{The vector object is an appealing place for 2 slots. The first
  slot is a boolean named {\Tt{}immutable\nwendquote} and would allow the user to
  mark a vector as immutable. While not strictly being immutable, as
  this is not possible in CL, the immutable slot would restrict the
  interface to operations that don't modify the contents of the
  vector. Hopefully, this would aid with adding concurrency to the
  operations. The second slot would be {\Tt{}data-type\nwendquote} or some
  equivalent name with a class allocation. There would be an
  associated function that would allow the user to set the floating
  point precision. This slot would serve 2 functions.  First, it would
  set the floating point precision for all newly constructed
  vectors. Second, if the function for setting the type was called
  with existing vector instances, it would modify the contents of all
  existing instances to correspond to the specified floating point
  precision. This concept needs to be better developed.}

\nomenclature{CLOS}{Common Lisp Object System.}

\section{Vector Interface Operations}
\label{sec:vector-interface-operations}

The vector interface operations are presented in this section. They
are designed to facilitate integrating new types of vectors into the
linear algebra package with minimal knowledge of the package
internals. The design is modeled after the array and sequence
interface and is intended to also be consistent with the linear
algebra matrix interface.
\nwenddocs{}\nwbegincode{59}\moddef{Vector interface operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Vector interface operations
\LA{}Generic function: Initialize a vector with data\RA{}
\LA{}Function: Make a vector\RA{}
\LA{}Function: Vector predicate\RA{}
\LA{}Generic function: Vector bounds predicate\RA{}
\LA{}Generic function: Vector element type\RA{}
\LA{}Generic function: Vector length\RA{}
\LA{}Generic function: Vector element reference\RA{}
\LA{}Generic function: Copy a vector\RA{}
\LA{}Generic function: Subset of a vector\RA{}
\LA{}Generic function: Destructively replace the subset of a vector\RA{}
\nwendcode{}\nwbegindocs{60}\nwdocspar
\begin{table}
  \centering
  \caption{Vector interface operations.}
  \begin{tabular}{p{0.35\textwidth}p{0.6\textwidth}}
    \hline
    Operation & Description \\
    \hline
    {\Tt{}make-vector\nwendquote}         & Create a new vector. \\
    {\Tt{}vector-object-p\nwendquote}     & Test for a vector object. \\
    {\Tt{}vector-in-bounds-p\nwendquote}  & Verify the index is in the vector.  \\
    {\Tt{}vector-element-type\nwendquote} & Return the type of the vector elements. \\
    {\Tt{}vector-length\nwendquote}       & Return the length of the vector. \\
    {\Tt{}vref\nwendquote}           & Reference a vector element, settable. \\
    {\Tt{}copy-vector\nwendquote}    & Perform a deep copy of the vector. \\
    {\Tt{}subvector\nwendquote}      & Return a subvector of a vector, settable. \\
    {\Tt{}replace-vector\nwendquote} & Destructively replace elements of a vector
                         with elements from another. \\
    \hline
  \end{tabular}
  \label{tab:vector-interface}
\end{table}

\subsection{Creating Vectors}
\label{sec:creating-vectors}

The function {\Tt{}make-vector\nwendquote} returns a new vector of the indicated
size. The interface is modeled on {\Tt{}MAKE-ARRAY\nwendquote}. The only required
argument is the size of the vector. Four keywords are accepted,
{\Tt{}element-type\nwendquote}, {\Tt{}vector-type\nwendquote}, {\Tt{}initial-element\nwendquote} and
{\Tt{}initial-contents\nwendquote}. The default type of vector is {\Tt{}column-vector\nwendquote}.
Either the {\Tt{}initial-element\nwendquote} or the {\Tt{}initial-contents\nwendquote} may be
specified, but not both. If neither are specified, the elements of the
vector are initialized to zero.
\nwenddocs{}\nwbegincode{61}\moddef{Function: Make a vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun make-vector (size &key
                    (element-type t)
                    (vector-type 'column-vector)
                    (initial-element nil initial-element-p)
                    (initial-contents nil initial-contents-p))
  "Create a 1D numeric array to represent a numeric vector."
  (let ((new-vector (make-instance vector-type)))
    (cond
      ((and initial-element-p initial-contents-p)
       (error "Cannot specify both :INITIAL-ELEMENT and :INITIAL-CONTENTS."))
      (initial-contents-p
       (initialize-vector new-vector initial-contents size element-type))
      (initial-element-p
       (initialize-vector new-vector initial-element size element-type))
      (t
       (initialize-vector
        new-vector (coerce 0 element-type) size element-type)))))

\nwendcode{}\nwbegindocs{62}The {\Tt{}make-vector\nwendquote} function relies on the generic function
{\Tt{}initialize-vector\nwendquote} to initialize the instance of the vector. This
enables the addition of new vector types without modification to the
make-vector function. The {\Tt{}initialize-vector\nwendquote} function should be
specialized on the type of the vector and the data.
\nwenddocs{}\nwbegincode{63}\moddef{Generic function: Initialize a vector with data}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric initialize-vector (vector data size &optional element-type)
  (:documentation
   "Initialize the vector with data."))

\nwendcode{}\nwbegindocs{64}{\Tt{}make-vector\nwendquote} and {\Tt{}initialize-vector\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{65}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:make-vector :initialize-vector
\nwendcode{}\nwbegindocs{66}\nwdocspar

\subsection{Vector Predicates}
\label{sec:vector-predicates}

Two linear algebra vector predicates are defined. {\Tt{}vector-object-p\nwendquote}
accepts a single argument and returns true if is is a
{\Tt{}vector-object\nwendquote}.
\nwenddocs{}\nwbegincode{67}\moddef{Function: Vector predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun vector-object-p (object)
  "Return true if the object is a vector-object."
  (typep object 'vector-object))

\nwendcode{}\nwbegindocs{68}{\Tt{}vector-in-bounds-p\nwendquote} accepts 2 arguments, a vector and an index.
It returns true if the index does not exceed the bounds of the vector.
\nwenddocs{}\nwbegincode{69}\moddef{Generic function: Vector bounds predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric vector-in-bounds-p (vector index)
  (:documentation
   "Return true if index does not exceed the dimensions of vector."))

\nwendcode{}\nwbegindocs{70}{\Tt{}vector-object-p\nwendquote} and {\Tt{}vector-in-bounds-p\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{71}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:vector-object-p :vector-in-bounds-p
\nwendcode{}\nwbegindocs{72}\nwdocspar

\subsection{Inspecting Vectors}
\label{sec:inspecting-vectors}

The {\Tt{}vector-element-type\nwendquote} function returns the specific type of the
vector elements. It accepts one argument.
\nwenddocs{}\nwbegincode{73}\moddef{Generic function: Vector element type}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric vector-element-type (vector)
  (:documentation
   "Return the element type of vector."))

\nwendcode{}\nwbegindocs{74}The length of a vector is obtained with {\Tt{}vector-length\nwendquote}. It
accepts one argument, the vector, and returns an integer, the length.
\nwenddocs{}\nwbegincode{75}\moddef{Generic function: Vector length}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric vector-length (vector)
  (:documentation
   "Return the length of the vector."))

\nwendcode{}\nwbegindocs{76}{\Tt{}vector-element-type\nwendquote} and {\Tt{}vector-length\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{77}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:vector-element-type :vector-length
\nwendcode{}\nwbegindocs{78}\nwdocspar

\subsection{Referencing Vectors}
\label{sec:referencing-vectors}

The {\Tt{}vref\nwendquote} function returns the element of the vector at the index.
It is analogous to {\Tt{}aref\nwendquote}.
\nwenddocs{}\nwbegincode{79}\moddef{Generic function: Vector element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric vref (vector index)
  (:documentation
   "Return the element of vector at index."))

\nwendcode{}\nwbegindocs{80}{\Tt{}vref\nwendquote} is settable.
\nwenddocs{}\nwbegincode{81}\moddef{Generic function: Vector element reference}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric (setf vref) (data vector index)
  (:documentation
   "Set the element of vector at index to data."))

\nwendcode{}\nwbegindocs{82}{\Tt{}vref\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{83}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:vref
\nwendcode{}\nwbegindocs{84}\nwdocspar

\subsection{Copying Vectors}
\label{sec:copying-vectors}

A new instance of a vector is obtained from {\Tt{}copy-vector\nwendquote}. This
function performs a deep copy of the vector argument.
\nwenddocs{}\nwbegincode{85}\moddef{Generic function: Copy a vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric copy-vector (vector)
  (:documentation
   "Return a copy of the vector."))

\nwendcode{}\nwbegindocs{86}{\Tt{}copy-vector\nwendquote} is an exported function.
\nwenddocs{}\nwbegincode{87}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:copy-vector
\nwendcode{}\nwbegindocs{88}\nwdocspar

\subsection{Manipulating Subsets of Vectors}
\label{sec:vector-subsets}

Subsets of vectors are operated on using {\Tt{}subvector\nwendquote} and
{\Tt{}replace-vector\nwendquote}. {\Tt{}subvector\nwendquote} returns a new {\Tt{}vector-object\nwendquote} that
is a subvector starting at {\Tt{}start\nwendquote} index and ending at the optional
{\Tt{}end\nwendquote} index that defaults to the last element.
\nwenddocs{}\nwbegincode{89}\moddef{Generic function: Subset of a vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric subvector (vector start &optional end)
  (:documentation
   "Return a new vector that is a subvector of the vector."))

\nwendcode{}\nwbegindocs{90}{\Tt{}subvector\nwendquote} is settable.
\nwenddocs{}\nwbegincode{91}\moddef{Generic function: Subset of a vector}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric (setf subvector) (subvector vector start &optional end)
  (:documentation
   "Set the subvector of the vector."))

\nwendcode{}\nwbegindocs{92}The {\Tt{}replace-vector\nwendquote} function requires 2 vectors and has keyword
arguments for the start and end index of each vector. It destructively
replaces the specified subset of {\Tt{}vector1\nwendquote} with that of {\Tt{}vector2\nwendquote},
returning the modified {\Tt{}vector1\nwendquote}. The number of elements replaced is
equal to the minimum of the subsets.
\nwenddocs{}\nwbegincode{93}\moddef{Generic function: Destructively replace the subset of a vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric replace-vector (vector1 vector2 &key
                            start1 end1 start2 end2)
  (:documentation
   "Destructively replace the elements of vector1 with vector2."))

\nwendcode{}\nwbegindocs{94}{\Tt{}subvector\nwendquote} and {\Tt{}replace-vector\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{95}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:subvector :replace-vector
\nwendcode{}\nwbegindocs{96}\nwdocspar

\section{Vector Iteration Operations}
\label{sec:vector-iteration-operations}

Many of the vector implementations of the fundamental linear algebra
operations described in Chapter~\ref{chap:fundamental-operations} are
concisely expressed using iteration functions. Two mapping functions
are defined in this section, {\Tt{}map-vector\nwendquote} and {\Tt{}map-into-vector\nwendquote}
and a vector specific macro, {\Tt{}dovector\nwendquote}, analogous to {\Tt{}DOLIST\nwendquote}.
\nwenddocs{}\nwbegincode{97}\moddef{Vector iteration operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Vector iteration operations
\LA{}Generic function: Map over a vector\RA{}
\LA{}Generic function: Map into a vector\RA{}
\LA{}Macro: Iterate over a vector\RA{}
\nwendcode{}\nwbegindocs{98}\nwdocspar
\begin{table}
  \centering
  \caption{Vector iteration operations.}
  \begin{tabular}{p{0.22\textwidth}p{0.65\textwidth}}
    \hline
    Operation & Description\\
    \hline
    {\Tt{}map-vector\nwendquote}      & Calls a function on successive sets of
                          vector objects. \\
    {\Tt{}map-into-vector\nwendquote} & Destructively maps into the result
                          vector. \\ 
    {\Tt{}dovector\nwendquote}        & Iterate over a vector returning result. \\
    \hline
  \end{tabular}
  \label{tab:vector-iteration}
\end{table}

The arguments to the {\Tt{}map-vector\nwendquote} function are the result type that
must be a subtype of {\Tt{}vector-object\nwendquote}, the function to apply to each
element of the vectors and one or more vector arguments. It returns a
new vector containing the results.
\nwenddocs{}\nwbegincode{99}\moddef{Generic function: Map over a vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric map-vector (result-type function first-vector &rest more-vectors)
  (:documentation
   "Calls function on successive sets of vector objects."))

\nwendcode{}\nwbegindocs{100}The destructive mapping function, {\Tt{}map-into-vector\nwendquote}, modifies a
result vector.
\nwenddocs{}\nwbegincode{101}\moddef{Generic function: Map into a vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric map-into-vector (result-vector function &rest vectors)
  (:documentation
   "Destructively modifies the result vector with the result of
applying the function to each element of the vectors."))

\nwendcode{}\nwbegindocs{102}{\Tt{}map-vector\nwendquote} and {\Tt{}map-into-vector\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{103}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:map-vector :map-into-vector
\nwendcode{}\nwbegindocs{104}\nwdocspar

The {\Tt{}dovector\nwendquote} macro iterates over the vector {\Tt{}vector\nwendquote} with
{\Tt{}element\nwendquote} bound to the current element, executing the {\Tt{}body\nwendquote} form
for each iteration, returning {\Tt{}result\nwendquote}.
\nwenddocs{}\nwbegincode{105}\moddef{Macro: Iterate over a vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmacro dovector ((element vector &optional result)
                    &body body)
  "Iterate over vector returning result."
  (let ((pos (gensym "POS-"))
        (end (gensym "END-")))
    `(let ((,end (vector-length ,vector))
           (,element nil))
      (dotimes (,pos ,end ,result)
        (setf ,element (vref ,vector ,pos))
        ,@body))))

\nwendcode{}\nwbegindocs{106}{\Tt{}dovector\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{107}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:dovector
\nwendcode{}\nwbegindocs{108}\nwdocspar

\section{Vector Transformations}
\label{sec:vector-transformations}

Vector transformations are used to perform matrix decomposition. Three
transformations are defined in this section, the Givens rotation, the
Jacobi rotation and the Householder reflection.
\nwenddocs{}\nwbegincode{109}\moddef{Vector transformations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Vector transformations
\LA{}Function: Givens rotation\RA{}
\LA{}Function: Jacobi rotation\RA{}
\LA{}Function: Householder reflection\RA{}
\LA{}Generic function: Apply vector rotation\RA{}
\nwendcode{}\nwbegindocs{110}\nwdocspar

\note{Need to establish a rule of float substitutability for vector
  transformations.(CLHS 12.1.3.3)}

\subsection{Givens Rotation}
\label{sec:givens}

A Givens rotation\cite{lawn148}, $R(c,s)$, is defined as a 2x2 unitary
matrix that rotates a vector with 2 elements, $f$ and $g$, into a
vector with a result, $r$, and a zero.
\begin{equation}
  \label{eq:givens-rotation}
  R(c,s) \cdot
  \begin{pmatrix}
    f \\ g
  \end{pmatrix}
  \equiv
  \begin{pmatrix}
    c & s \\ - \bar{s} & c
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
    f \\ g
  \end{pmatrix}
  =
  \begin{pmatrix}
    r \\ 0
  \end{pmatrix}
\end{equation}
When $f,g \in \mathbb{R}^2$, the Givens rotation is\cite{linear-algebra}
\begin{equation}
  \label{eq:real-rotation}
  R(\theta) \equiv
  \begin{pmatrix}
    \cos \theta & -\sin \theta \\
    sin \theta & \cos \theta
  \end{pmatrix}
\end{equation}
which is a counter-clockwise rotation by $\theta$. In this case,
$\theta$ is chosen such that
\begin{equation}
  \label{eq:real-givens}
  \begin{pmatrix}
    \cos \theta & - \sin \theta \\
    \sin \theta & \cos \theta
  \end{pmatrix}
  \begin{pmatrix}
    f \\ g
  \end{pmatrix}
  =
  \begin{pmatrix}
    \sqrt{ f^2 + g^2 } \\ 0
  \end{pmatrix}
\end{equation}

As discussed in the LAPACK Working Note~148\cite{lawn148},
implementation of the Givens rotation is not trivial, especially when
$f=0$ or $g=0$. When exceptional conditions such as underflow or
{\Tt{}NaN\nwendquote} are not considered, the algorithm for real and complex inputs
is defined in Algorithm~1\cite{lawn148}.
\begin{algorithm}
  \caption{Algorithm~1 in LAWN~148 for the Givens rotation.}
  \label{algorithm-1-lawn-148}
  \begin{algorithmic}
    \IF[includes the case $f=g=0$]{$g=0$}
    \STATE $c \leftarrow 1$
    \STATE $s \leftarrow 0$
    \STATE $r \leftarrow f$
    \ELSIF[$g$ must be nonzero]{$f=0$}
    \STATE $c \leftarrow 0$
    \STATE $s \leftarrow \mbox{sign}( \bar{g} )$
    \STATE $r \leftarrow |g|$
    \ELSE[$f$ and $g$ both nonzero]
    \STATE $c \leftarrow |f|/\sqrt{|f|^2 + |g|^2}$
    \STATE $s \leftarrow \mbox{sign}(f)\bar{g}/\sqrt{|f|^2 + |g|^2}$
    \STATE $r \leftarrow \mbox{sign}(f)\sqrt{|f|^2 + |g|^2}$
    \ENDIF
  \end{algorithmic}
\end{algorithm}
This is the algorithm implemented.
\nwenddocs{}\nwbegincode{111}\moddef{Function: Givens rotation}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun givens-rotation (f g)
  "Return c,s,r defined from the Givens rotation."
  (cond
    ((zerop g)
     (values 1 0 f))
    ((zerop f)
     (values 0 (signum (conjugate g)) (abs g)))
    (t
     (let* ((abs-f (abs f))
            (abs-g (abs g))
            (sqrtfg (sqrt (+ (* abs-f abs-f) (* abs-g abs-g)))))
       (values
        (/ abs-f sqrtfg)
        (/ (* (signum f) (conjugate g)) sqrtfg)
        (* (signum f) sqrtfg))))))

\nwendcode{}\nwbegindocs{112}{\Tt{}givens-rotation\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{113}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:givens-rotation
\nwendcode{}\nwbegindocs{114}\nwdocspar

\subsubsection{Jacobi Rotation}
\label{sec:jacobi}

The Jacobi rotation is used to compute eigenvalues and eigenvectors
for the symmetric eigenproblem and singular value
decomposition.\cite{linear-algebra} While the performance of the
Jacobi rotation not as good as other methods, it can be used to
compute small values of eigenvalues and eigenvectors with more
accuracy then other methods. It is also easily
parallelized.\cite{linear-algebra} The rotation is constructed to
satisfy
\begin{equation}
  \label{eq:jacobi-rotation}
  \begin{pmatrix}
    a & 0 \\ 0 & b
  \end{pmatrix}
  =
  \begin{pmatrix}
    c & \bar{s} \\ -s & c
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
    x & y \\ \bar{y} & z
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
    c & -\bar{s} \\ s & c
  \end{pmatrix}
\end{equation}
given $x$, $y$ and $z$. In equation~\ref{eq:jacobi-rotation}, $c
\equiv \cos\theta$, $s \equiv \exp^{i\psi} \sin\theta$, $x,y \in R$
and $y \equiv Y\exp^{i\phi}$. Expanding the matrix multiplication on
the right side of equation~\ref{eq:jacobi-rotation} results in
\begin{equation}
  \label{eq:jacobi-expansion}
  \begin{pmatrix}
    a & 0 \\ 0 & b
  \end{pmatrix}
  =
  \begin{pmatrix}
    c^2 x + c \bar{s} \bar{y} + c s y + s \bar{s} z &
    - c \bar{s} x - \bar{s} \bar{s} \bar{y} + c^2 y + c \bar{s} z \\
    - c s x + c^2 \bar{y} - s s y + c s z &
    s \bar{s} x - c \bar{s} \bar{y} - c s y + c^2 z
  \end{pmatrix}
\end{equation}
Now the off diagonal terms can be set to 0 and used to solve for the
rotational terms.
\begin{align}
  \label{eq:jacobi-rot-terms}
  \frac{x-z}{y} & = \frac{c^2 - s\bar{s}}{c\bar{s}} \notag \\
  \frac{x-z}{Y\exp^{i\phi}} &
  = \frac{\cos^2\theta -
    \sin^2\theta}{\cos\theta\exp^{-i\psi}\sin\theta} \notag \\
  \frac{x-z}{Y} &
  = \exp^{i\phi}\exp^{i\psi} \frac{\cos^2\theta -
    \sin^2\theta}{\cos\theta\sin\theta}
\end{align}
Define the term $\tau$ by setting $\psi=-\phi$ and dividing
equation~\ref{eq:jacobi-rot-terms} by 2.
\begin{equation}
  \label{eq:jacobi-tau}
  \frac{x-z}{2Y} = \frac{\cos 2\theta}{\sin 2\theta} = \cot 2\theta = \tau
\end{equation}
Express the identity $\tan 2\theta = 2\tan\theta/(1-\tan^2\theta)$ as
the quadratic equation $t^2 + 2\tau t - 1 = 0$ to solve for
$\cos\theta$ where $t = \tan\theta$. Next, $\cos\theta$ can be
substituted into the definition of $t$ to obtain $\sin\theta$. With
$\sin\theta$, all terms required to calculate $a$ and $b$ have been
obtained. This results in Algorithm~\ref{alg:jacobi-rotation}.
\begin{algorithm}
  \caption{Jacobi Rotation, Given $x$, $y$ and $z$.}
  \label{alg:jacobi-rotation}
  \begin{algorithmic}
    \STATE $\tau \leftarrow ( x - z ) / ( 2 \cdot |y| )$
    \STATE $t \leftarrow \mbox{sign}(\tau) /
           (|\tau| + \sqrt{1+\tau^2})$
    \STATE $c = \cos\theta \leftarrow 1 / \sqrt{1 + t^2}$
    \STATE $\sin\theta \leftarrow c \cdot t$
    \STATE $s \leftarrow \exp^{i\psi} \sin\theta$
    \STATE $a \leftarrow x \cos^2\theta + z \sin^2\theta + 2|y|\sin\theta\cos\theta$
    \STATE $b \leftarrow x \sin^2\theta + z \cos^2\theta - 2|y|\sin\theta\cos\theta$
    \RETURN $a$, $b$, $c$ and $s$
  \end{algorithmic}
\end{algorithm}
\nwenddocs{}\nwbegincode{115}\moddef{Function: Jacobi rotation}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun jacobi-rotation (x y z)
  "Return a, b, cos(theta) and sin(theta) terms from the Jacobi rotation."
  (let* ((yabs (abs y))
         (tau  (/ (- x z) 2.0 yabs))
         (tee  (/ (float-sign tau)
                  (+ (abs tau) (sqrt (+ 1.0 (expt tau 2))))))
         (cos-theta (/ (sqrt (+ 1.0 (expt tee 2))))) ; Invert sqrt
         (sin-theta (* cos-theta tee)))
    (values
     ;; a : first eigenvalue
     (+ (* cos-theta cos-theta x)
        (* 2.0 cos-theta sin-theta yabs)
        (* sin-theta sin-theta z))
     ;; b : second eigenvalue
     (+ (* sin-theta sin-theta x)
        (* -2.0 cos-theta sin-theta yabs)
        (* cos-theta cos-theta z))
     ;; Cosine theta
     cos-theta
     ;; Sine theta
     (* (conjugate (signum y)) sin-theta))))

\nwendcode{}\nwbegindocs{116}{\Tt{}jacobi-rotation\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{117}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:jacobi-rotation
\nwendcode{}\nwbegindocs{118}\nwdocspar

\subsubsection{Householder Reflection}
\label{sec:householder}

A Householder reflection is a matrix of the form\cite{linear-algebra}
\begin{equation}
  \label{eq:householder}
  P = I - 2uu^T
\end{equation}
where $\|u\|_2 = 1$. The matrix $P$ is symmetric and orthogonal. Given
a vector $x$, the Householder reflection is used to zero out all
elements except for the first. The algorithm utilized in
CLARFG\cite{lapack} is implemented here without the scaling
considerations.
\nwenddocs{}\nwbegincode{119}\moddef{Function: Householder reflection}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun householder-reflection (alpha vector)
  "Return Beta, Tau and the Householder vector."
  (let* ((beta (- (float-sign
                   (realpart alpha)
                   (lapy2 alpha (norm vector :measure 2)))))
         (tau  (- 1 (/ alpha beta))))
    (values beta tau (scale (/ alpha) vector))))

\nwendcode{}\nwbegindocs{120}{\Tt{}householder-reflection\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{121}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:householder-reflection
\nwendcode{}\nwbegindocs{122}\nwdocspar

\subsection{Apply Vector Rotation}
\label{sec:apply-vector-rot}

The function {\Tt{}apply-rotation\nwendquote} applies a vector rotation constructed
from {\Tt{}cc\nwendquote} and {\Tt{}ss\nwendquote} to {\Tt{}vector1\nwendquote} and {\Tt{}vector2\nwendquote}, expressed in
equation~\ref{eq:apply-rotation}. The rotation is returned in 2 new
vectors.
\begin{equation}
  \label{eq:apply-rotation}
  \begin{pmatrix}
    \mbox{result1}_i \\ \mbox{result2}_i
  \end{pmatrix}
  \leftarrow
  \begin{pmatrix}
    c & s \\ -\bar{s} & c
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
    x_i \\ y_i
  \end{pmatrix}
\end{equation}
\nwenddocs{}\nwbegincode{123}\moddef{Generic function: Apply vector rotation}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric apply-rotation (vector1 vector2 cc ss)
  (:documentation
   "Return the plane rotations of vector1 and vector2 by cc and ss."))

\nwendcode{}\nwbegindocs{124}The destructive version, {\Tt{}napply-rotation\nwendquote}, stores the result in
{\Tt{}vector1\nwendquote} and {\Tt{}vector2\nwendquote}.
\nwenddocs{}\nwbegincode{125}\moddef{Generic function: Apply vector rotation}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric napply-rotation (vector1 vector2 cc ss)
  (:documentation
   "Return the plane rotations of vector1 and vector2 by cc and ss."))

\nwendcode{}\nwbegindocs{126}{\Tt{}apply-rotation\nwendquote} and {\Tt{}napply-rotation\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{127}\moddef{Vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:apply-rotation :napply-rotation
\nwendcode{}\nwbegindocs{128}\nwdocspar

\chapter{Matrices}
\label{chap:matrices}

In this chapter, the CLOS is used to define a linear algebra matrix
object that is the superclass for all linear algebra matrices. Then,
general, symmetric, Hermitian and triangular(upper and lower) matrices
are defined. In addition, objects are defined for the identity and
permutation matrices. Matrices are zero-indexed which is standard in
Common Lisp.
\nwenddocs{}\nwbegincode{129}\moddef{matrix.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Matrix superclass\RA{}
\LA{}Matrix interface operations\RA{}
\nwendcode{}\nwbegindocs{130}Definition of matrices depends on the definition of the linear
algebra package and fundamental operations.
\nwenddocs{}\nwbegincode{131}\moddef{Matrix dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "matrix"
       :depends-on ("defpackage"
                    "fundamental-ops"))
\nwendcode{}\nwbegindocs{132}All matrix objects are subclasses of the {\Tt{}matrix-object\nwendquote}
superclass.  No presumptions are made about the internal storage of
the matrix data, therefore, this superclass has not slots.
\nwenddocs{}\nwbegincode{133}\moddef{Matrix superclass}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Matrix superclass
(defclass matrix-object ()
  ()
  (:documentation
   "A superclass for all matrices."))

\nwendcode{}\nwbegindocs{134}The {\Tt{}matrix-object\nwendquote} superclass is an exported symbol.
\nwenddocs{}\nwbegincode{135}\moddef{Matrix exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:matrix-object
\nwendcode{}\nwbegindocs{136}\nwdocspar

\note{The matrix object is an attractive place for 2 slots. The first
  slot is a boolean named {\Tt{}IMMUTABLE\nwendquote} and would allow the user to
  mark a matrix immutable. While not strictly being immutable, as this
  is not possible in CL, the immutable slot would restrict the
  interface to operations that don't modify the contents of the
  matrix. Hopefully, this would aid with adding concurrency to the
  operations. The second slot would be {\Tt{}FLOAT-TYPE\nwendquote} or some
  equivalent name with a class allocation. There would be an
  associated function {\Tt{}SET-FLOAT-TYPE\nwendquote} that would allow the user to
  set the floating point precision. This slot would serve 2 functions.
  First, it would set the floating point precision for all newly
  constructed matrices.  Second, if {\Tt{}SET-FLOAT-TYPE\nwendquote} was called with
  existing matrix instances, it would modify the contents of all
  existing instances to correspond to the specified floating point
  precision. This concept needs to be better developed and extended to
  vectors.}

\note{Two more types of matrices need to be defined, banded and sparse.}

\section{Matrix Interface Operations}
\label{sec:matrix-interface-operations}

The matrix interface is presented in this section. It is designed to
facilitate integrating new types of matrices into the linear algebra
package with minimal knowledge of the package internals.  The design
is modeled after the array interface and is intended to also be
consistent with the linear algebra vector interface.
\nwenddocs{}\nwbegincode{137}\moddef{Matrix interface operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Matrix interface operations
\LA{}Generic function: Initialize a matrix with data\RA{}
\LA{}Function: Make a new matrix\RA{}
\LA{}Function: Matrix predicate\RA{}
\LA{}Generic function: Matrix bounds predicate\RA{}
\LA{}Generic function: Matrix element type\RA{}
\LA{}Generic function: Matrix dimensions\RA{}
\LA{}Generic function: Matrix row dimension\RA{}
\LA{}Generic function: Matrix column dimension\RA{}
\LA{}Generic function: Matrix element reference\RA{}
\LA{}Generic function: Copy a matrix\RA{}
\LA{}Generic function: Subset of a matrix\RA{}
\LA{}Generic function: Destructively replace the subset of a matrix\RA{}
\LA{}Function: Validate a range of rows and columns\RA{}
\nwendcode{}\nwbegindocs{138}\nwdocspar
\begin{table}
  \centering
  \caption{Matrix interface operations.}
  \begin{tabular}{p{0.35\textwidth}p{0.6\textwidth}}
    \hline
    Operation & Description\\
    \hline
    {\Tt{}make-matrix\nwendquote}         & Create a new matrix.\\
    {\Tt{}initialize-matrix\nwendquote}   & Validate initial data and initialize the matrix.\\
    {\Tt{}matrixp\nwendquote}             & Test for a matrix object.\\
    {\Tt{}matrix-in-bounds-p\nwendquote}  & Verify the indices don't exceed matrix dimensions.\\
    {\Tt{}matrix-element-type\nwendquote} & Return the type of the vector elements.\\
    {\Tt{}matrix-dimensions\nwendquote}   & Return the dimension of the matrix.\\
    {\Tt{}matrix-row-dimension\nwendquote} & Return the number of rows in the matrix.\\
    {\Tt{}matrix-column-dimension\nwendquote} & Return the number of columns in the matrix.\\
    {\Tt{}mref\nwendquote}           & Reference a matrix element, settable.\\
    {\Tt{}copy-matrix\nwendquote}    & Perform a deep copy of the matrix.\\
    {\Tt{}submatrix\nwendquote}      & Return a submatrix of a matrix, settable. \\
    {\Tt{}replace-matrix\nwendquote} & Destructively replace elements of a matrix
                         with elements from another.\\
    \hline
  \end{tabular}
  \label{tab:matrix-interface}
\end{table}

\subsection{Creating Matrices}
\label{sec:creating-matrices}

A new matrix instance is created using the function {\Tt{}make-matrix\nwendquote}.
The default behavior will return a general matrix with initial
elements of zero. Specifying the element type will result in the
matrix elements being initialized with zeroes of that type or restrict
the type of the initial element or contents. The initial contents can
be specified using a nested sequence or a two-dimensional array. The
shape of the intial contents must match the specified rows and
columns.
\nwenddocs{}\nwbegincode{139}\moddef{Function: Make a new matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun make-matrix (rows columns &key
                    (matrix-type 'dense-matrix)
                    (element-type t)
                    (initial-element nil initial-element-p)
                    (initial-contents nil initial-contents-p))
  "Return a new matrix instance."
  (let ((new-matrix (make-instance matrix-type)))
    (cond
      ((and initial-element-p initial-contents-p)
       (error "Cannot specify both INITIAL-ELEMENT and INITIAL-CONTENTS."))
      (initial-contents-p
       (initialize-matrix
        new-matrix initial-contents rows columns element-type))
      (initial-element-p
       (initialize-matrix
        new-matrix initial-element rows columns element-type))
      (t
       (initialize-matrix
        new-matrix (coerce 0 element-type) rows columns element-type)))))

\nwendcode{}\nwbegindocs{140}The {\Tt{}make-matrix\nwendquote} function relies on the generic function
{\Tt{}initialize-matrix\nwendquote} to initialize the instance of the matrix. This
enables the addition of new matrix types without modification to the
{\Tt{}make-matrix\nwendquote} function.  The {\Tt{}initialize-matrix\nwendquote} function should
be specialized on the type of the matrix and the data. Generally,
there are 4 types of data for a matrix: data in a nested sequence,
data in a 2D array, data in another matrix and an initial element.
\nwenddocs{}\nwbegincode{141}\moddef{Generic function: Initialize a matrix with data}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric initialize-matrix (matrix data rows columns
                               &optional element-type)
  (:documentation
   "Initialize the matrix with data."))

\nwendcode{}\nwbegindocs{142}{\Tt{}make-matrix\nwendquote} and {\Tt{}initialize-matrix\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{143}\moddef{Matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:make-matrix :initialize-matrix
\nwendcode{}\nwbegindocs{144}\nwdocspar

\note{Initializing the default matrix with zeroes is not valid if the
  element type is {\Tt{}RATIO\nwendquote} or {\Tt{}BIGNUM\nwendquote}.}

\note{Matrix construction is an open topic. The main issue is that the
  argument list may not map to banded or sparse matrices. If it is
  determined that there is not a way for {\Tt{}make-matrix\nwendquote} to map to
  banded or sparse matrices, the interface will be revised to be more
  abstract. There is also the possibility of creating a {\Tt{}defmatrix\nwendquote}
  macro that generates the interface for a new matrix definition. In
  either case, {\Tt{}make-matrix\nwendquote} in the future may more closely resemble
  {\Tt{}MAKE-INSTANCE\nwendquote}.}

\subsection{Matrix Predicates}
\label{sec:matrix-predicates}

Two matrix predicates are defined. The function {\Tt{}matrixp\nwendquote} returns
true if the object is a matrix and false otherwise.
\nwenddocs{}\nwbegincode{145}\moddef{Function: Matrix predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun matrixp (object)
  "Return true if object is a matrix, NIL otherwise."
  (typep object 'matrix-object))

\nwendcode{}\nwbegindocs{146}Indices for a matrix are check against the dimensions with
{\Tt{}matrix-in-bounds-p\nwendquote}. It is a generic function that can be tailored
to the specific type of matrix. It returns true if the matrix
coordinates are valid, {\Tt{}NIL\nwendquote} otherwise.
\nwenddocs{}\nwbegincode{147}\moddef{Generic function: Matrix bounds predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric matrix-in-bounds-p (matrix row column)
  (:documentation
   "Return true if ROW and COLUMN do not exceed the dimensions of MATRIX."))

\nwendcode{}\nwbegindocs{148}{\Tt{}matrixp\nwendquote} and {\Tt{}matrix-in-bounds-p\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{149}\moddef{Matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:matrixp :matrix-in-bounds-p
\nwendcode{}\nwbegindocs{150}\nwdocspar

\subsection{Inspecting Matrices}
\label{sec:inspecting-matrices}

The specific type of the matrix element is returned by
{\Tt{}matrix-element-type\nwendquote}.
\nwenddocs{}\nwbegincode{151}\moddef{Generic function: Matrix element type}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric matrix-element-type (matrix)
  (:documentation
   "Return the element type of MATRIX."))

\nwendcode{}\nwbegindocs{152}The size of the matrix is returned from {\Tt{}matrix-dimensions\nwendquote}.
\nwenddocs{}\nwbegincode{153}\moddef{Generic function: Matrix dimensions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric matrix-dimensions (matrix)
  (:documentation
   "Return the number of rows and columns in MATRIX."))

\nwendcode{}\nwbegindocs{154}The number of rows of a matrix is returned from
{\Tt{}matrix-row-dimension\nwendquote}
\nwenddocs{}\nwbegincode{155}\moddef{Generic function: Matrix row dimension}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric matrix-row-dimension (matrix)
  (:documentation
   "Return the number of rows in MATRIX."))

\nwendcode{}\nwbegindocs{156}and the number of columns of a matrix is returned from
{\Tt{}matrix-column-dimension\nwendquote}.
\nwenddocs{}\nwbegincode{157}\moddef{Generic function: Matrix column dimension}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric matrix-column-dimension (matrix)
  (:documentation
   "Return the number of columns in MATRIX."))

\nwendcode{}\nwbegindocs{158}{\Tt{}matrix-element-type\nwendquote}, {\Tt{}matrix-dimensions\nwendquote},
{\Tt{}matrix-row-dimension\nwendquote} and \\
{\Tt{}matrix-column-dimension\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{159}\moddef{Matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:matrix-element-type
:matrix-dimensions
:matrix-row-dimension
:matrix-column-dimension
\nwendcode{}\nwbegindocs{160}\nwdocspar

\subsection{Referencing Matrices}
\label{sec:referencing-matrices}

Elements of a matrix are accessed using {\Tt{}mref\nwendquote}.
\nwenddocs{}\nwbegincode{161}\moddef{Generic function: Matrix element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric mref (matrix row column)
  (:documentation
   "Return the matrix element at ROW,COLUMN."))

\nwendcode{}\nwbegindocs{162}{\Tt{}mref\nwendquote} is settable for appropriate matrix subclasses.
\nwenddocs{}\nwbegincode{163}\moddef{Generic function: Matrix element reference}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric (setf mref) (data matrix row column)
  (:documentation
   "Set the element at row,column of matrix to data."))

\nwendcode{}\nwbegindocs{164}{\Tt{}mref\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{165}\moddef{Matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:mref
\nwendcode{}\nwbegindocs{166}\nwdocspar

\subsection{Copying Matrices}
\label{sec:copying-matrices}

A new instance of a matrix is obtained from {\Tt{}copy-matrix\nwendquote}. This
function performs a deep copy of the matrix argument.
\nwenddocs{}\nwbegincode{167}\moddef{Generic function: Copy a matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric copy-matrix (matrix)
  (:documentation
   "Return a copy of the matrix."))

\nwendcode{}\nwbegindocs{168}{\Tt{}copy-matrix\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{169}\moddef{Matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:copy-matrix
\nwendcode{}\nwbegindocs{170}\nwdocspar

\subsection{Manipulating Subsets of Matrices}
\label{sec:matrix-subsets}

Subsets of matrices are operated on using {\Tt{}submatrix\nwendquote} and
{\Tt{}replace-matrix\nwendquote}. A new submatrix of a matrix is returned from
{\Tt{}submatrix\nwendquote}.
\nwenddocs{}\nwbegincode{171}\moddef{Generic function: Subset of a matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric submatrix (matrix row column &key row-end column-end)
  (:documentation
   "Return a submatrix of the matrix."))

\nwendcode{}\nwbegindocs{172}The submatrix may be settable.
\nwenddocs{}\nwbegincode{173}\moddef{Generic function: Subset of a matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric (setf submatrix) (submatrix matrix row column
                              &key row-end column-end)
  (:documentation
   "Set the submatrix of the matrix."))

\nwendcode{}\nwbegindocs{174}A destructive function, {\Tt{}replace-matrix\nwendquote}, analogous to the
sequence function {\Tt{}REPLACE\nwendquote}, allows bulk replacement of all or a
subset of the elements of a matrix.
\nwenddocs{}\nwbegincode{175}\moddef{Generic function: Destructively replace the subset of a matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defgeneric replace-matrix (matrix1 matrix2 &key
                            row1 row1-end column1 column1-end
                            row2 row2-end column2 column2-end)
  (:documentation
   "Destructively replace elements of matrix1 with matrix2."))

\nwendcode{}\nwbegindocs{176}{\Tt{}submatrix\nwendquote} and {\Tt{}replace-matrix\nwendquote} are exported symbols.
\nwenddocs{}\nwbegincode{177}\moddef{Matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:submatrix :replace-matrix
\nwendcode{}\nwbegindocs{178}\nwdocspar

\note{Instead of having 8 keyword arguments for {\Tt{}replace-matrix\nwendquote}, it
  may be better to have the same 4 as the standard {\Tt{}REPLACE\nwendquote}
  function and pass 2 element sequences to each.}

\subsection{Matrix Validated Range}
\label{sec:matrix-validated-range}

The function {\Tt{}matrix-validated-range\nwendquote} validates a range of rows and
columns against the dimensions of the matrix.
\nwenddocs{}\nwbegincode{179}\moddef{Function: Validate a range of rows and columns}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun matrix-validated-range (matrix row column &optional row-end column-end)
  "Returns a validated range of rows and columns for the matrix."
  (destructuring-bind (row-dimension column-dimension)
      (matrix-dimensions matrix)
    (let ((row-end    (or row-end row-dimension))
          (column-end (or column-end column-dimension)))
      (if (and (<= 0 row row-end row-dimension)
               (<= 0 column column-end column-dimension))
          (list row column row-end column-end)
          (error "The matrix range (~D:~D,~D:~D) is invalid."
                 row column row-end column-end)))))

\nwendcode{}\nwbegindocs{180}{\Tt{}matrix-validated-range\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{181}\moddef{Matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:matrix-validated-range
\nwendcode{}\nwbegindocs{182}\nwdocspar

\chapter{Identity and Permutation Matrices}
\label{chap:identity-and-permutation-matrices}

The identity and permutation matrices are defined in this chapter.
Both are direct subclasses of the {\Tt{}matrix-object\nwendquote} and have no
subclasses.

\section{Identity Matrix}
\label{sec:identity-mat}

The identity matrix is a square matrix with ones on the diagonal and
zeroes off diagonal.
\nwenddocs{}\nwbegincode{183}\moddef{identity-matrix.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Class: Identity matrix\RA{}
\LA{}Function: Identity matrix predicate\RA{}
\LA{}Method: Initialize the identity matrix\RA{}
\LA{}Method: Identity matrix bounds predicate\RA{}
\LA{}Method: Identity matrix element type\RA{}
\LA{}Method: Identity matrix dimensions\RA{}
\LA{}Method: Identity matrix element reference\RA{}
\LA{}Method: Copy an identity matrix\RA{}
\LA{}Method: Submatrix of an identity matrix\RA{}
\nwendcode{}\nwbegindocs{184}The identity matrix depends on the linear algebra package,
fundamental operations and the matrix interface.
\nwenddocs{}\nwbegincode{185}\moddef{Identity matrix dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "identity-matrix"
       :depends-on ("defpackage"
                    "fundamental-ops"
                    "matrix"))
\nwendcode{}\nwbegindocs{186}The requirements for the identity matrix object are that it store
the size of the matrix and the element type. Strictly, the only slot
required for the identity matrix is a size slot, but element type
information is useful. Consequently, the identity matrix object is
defined with 2 slots. The size of the matrix is recorded in the
{\Tt{}size\nwendquote} slot. To maintain the proper type of the zero and one values,
the {\Tt{}contents\nwendquote} slot is a 2 element vector with the first value equal
to zero and the second equal to one.
\nwenddocs{}\nwbegincode{187}\moddef{Class: Identity matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass identity-matrix (matrix-object)
  ((size
    :type    fixnum
    :initarg :size
    :reader  size
    :reader  matrix-row-dimension
    :reader  matrix-column-dimension)
   (contents
    :type    (array * (2))
    :initarg :contents
    :reader  contents))
  (:documentation
   "Identity matrix object."))

\nwendcode{}\nwbegindocs{188}{\Tt{}identity-matrix\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{189}\moddef{Identity matrix exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:identity-matrix
\nwendcode{}\nwbegindocs{190}\nwdocspar

\subsection{Initializing Identity Matrices}
\label{sec:initializing-identity-matrices}

Only one initial data method is defined for the identity matrix. It
does not make sense to initialize it with anything. For an identity
matrix, {\Tt{}initial-data\nwendquote} sets the size and element type of the matrix.
\nwenddocs{}\nwbegincode{191}\moddef{Method: Initialize the identity matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix identity-matrix) (data number)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the identity matrix.."
  (cond
    ((not (zerop data))
     (error "Initial data is invalid for an identity matrix."))
    ((not (= rows columns))
     (error "Rows and columns are not equal."))
    (t
     (setf (slot-value matrix 'size) rows)
     (setf (slot-value matrix 'contents)
           (make-array 2 :element-type element-type
                       :initial-contents
                       (list (coerce 0 element-type)
                             (coerce 1 element-type))))
     ;; Return the matrix
     matrix)))

\nwendcode{}\nwbegindocs{192}{\Tt{}initialize-matrix\nwendquote} was exported with the definition of the
generic function.

\subsection{Identity Matrix Predicates}
\label{sec:identity-matrix-predicates}

{\Tt{}identity-matrix-p\nwendquote} returns true if the object is an identity matrix
and {\Tt{}NIL\nwendquote} otherwise.
\nwenddocs{}\nwbegincode{193}\moddef{Function: Identity matrix predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun identity-matrix-p (object)
  "Return true if object is an identity-matrix."
  (typep object 'identity-matrix))

\nwendcode{}\nwbegindocs{194}{\Tt{}matrix-in-bounds-p\nwendquote} compares the indices against the {\Tt{}size\nwendquote}
value.
\nwenddocs{}\nwbegincode{195}\moddef{Method: Identity matrix bounds predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-in-bounds-p ((matrix identity-matrix)
                               (row integer) (column integer))
  "Return true if row and column do not exceed the dimensions of matrix."
  (and (<= 0 row)    (< row    (size matrix))
       (<= 0 column) (< column (size matrix))))

\nwendcode{}\nwbegindocs{196}{\Tt{}matrix-in-bounds-p\nwendquote} was exported with the definition of the
generic function. {\Tt{}identity-matrix-p\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{197}\moddef{Identity matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:identity-matrix-p
\nwendcode{}\nwbegindocs{198}\nwdocspar

\subsection{Inspecting Identity Matrices}
\label{sec:inspecting-identity-matrices}

The identity matrix implementation of {\Tt{}matrix-element-type\nwendquote} is a
wrapper around {\Tt{}array-element-type\nwendquote}.
\nwenddocs{}\nwbegincode{199}\moddef{Method: Identity matrix element type}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-element-type ((matrix identity-matrix))
  "Return the element type of the identity matrix."
  (array-element-type (contents matrix)))

\nwendcode{}\nwbegindocs{200}The identity matrix implementation of {\Tt{}matrix-dimensions\nwendquote} returns
a 2 element list with both elements set to {\Tt{}size\nwendquote}.
\nwenddocs{}\nwbegincode{201}\moddef{Method: Identity matrix dimensions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-dimensions ((matrix identity-matrix))
  "Return the number of rows and columns in matrix."
  (list (size matrix) (size matrix)))

\nwendcode{}\nwbegindocs{202}The specific row and column dimension functions,
{\Tt{}matrix-row-dimension\nwendquote} and {\Tt{}matrix-column-dimension\nwendquote} are defined
as readers for the {\Tt{}size\nwendquote} slot. All of these symbols were exported
with the definition of the generic functions.

\subsection{Referencing Identity Matrices}
\label{sec:referencing-identity-matrices}

Reference to an element of an identity matrix returns either one or
zero. One is returned if the element is on the diagonal and zero
otherwise.
\nwenddocs{}\nwbegincode{203}\moddef{Method: Identity matrix element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod mref ((matrix identity-matrix)
                 (row integer) (column integer))
  "Return the element of the matrix at row,column."
  (if (= row column)
      (aref (contents matrix) 1)
      (aref (contents matrix) 0)))

\nwendcode{}\nwbegindocs{204}An identity matrix is not settable. {\Tt{}mref\nwendquote} was exported with the
definition of the generic function.

\subsection{Copying Identity Matrices}
\label{sec:copying-identity-matrices}

A copy of an identity matrix is returned from {\Tt{}copy-matrix\nwendquote}.
\nwenddocs{}\nwbegincode{205}\moddef{Method: Copy an identity matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod copy-matrix ((matrix identity-matrix))
  "Return a copy of the matrix."
  (let ((element-type (matrix-element-type matrix)))
    (make-instance
     'identity-matrix
     :size (size matrix)
     :contents (make-array 2 :element-type element-type
                           :initial-contents
                           (list (coerce 0 element-type)
                                 (coerce 1 element-type))))))

\nwendcode{}\nwbegindocs{206}{\Tt{}copy-matrix\nwendquote} was exported with the definition of the generic
function.

\subsection{Manipulating Subsets of Identity Matrices}
\label{sec:identity-matrix-subsets}

The submatrix of an identity matrix is another identity matrix if the
start and end row equal the start and end column, respectively.  If
the start row and column are not equal, the submatrix is a square
matrix if the range is square and a dense matrix otherwise.
\nwenddocs{}\nwbegincode{207}\moddef{Method: Submatrix of an identity matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod submatrix ((matrix identity-matrix)
                      (row integer) (column integer)
                      &key row-end column-end)
  "Return a matrix created from the submatrix of matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (- row-end row))
          (numcols (- column-end column))
          (element-type (matrix-element-type matrix)))
      (cond
        ;; On the diagonal
        ((and (= row column) (= numrows numcols))
         (make-instance
          'identity-matrix
          :size numrows
          :contents (make-array 2 :element-type element-type
                                :initial-contents
                                (list (coerce 0 element-type)
                                      (coerce 1 element-type)))))
        ;; Intersects the diagonal
        ((and (<= row column-end) (<= column row-end))
         (multiple-value-bind (r0 c0 size)
             (cond
               ((< row column)
                (values (- column row) 0 (min numcols (- row-end column))))
               ((< column row)
                (values 0 (- row column) (min numrows (- column-end row))))
               (t (values 0 0 (min numrows numcols))))
           (let ((one (coerce 1 element-type))
                 (contents (make-array (list numrows numcols)
                                       :element-type element-type
                                       :initial-element (coerce 0 element-type))))
             (make-instance
              (if (= numrows numcols) 'square-matrix 'dense-matrix)
              :contents
              (dotimes (i0 size contents)
                (setf (aref contents (+ r0 i0) (+ c0 i0)) one))))))
        ;; A zero matrix
        (t (make-instance
            (if (= numrows numcols) 'square-matrix 'dense-matrix)
            :contents (make-array (list numrows numcols)
                                  :element-type element-type
                                  :initial-element (coerce 0 element-type))))))))

\nwendcode{}\nwbegindocs{208}The identity matrix is immutable, so no settable or destructive
methods are defined.

\section{Permutation Matrix}
\label{sec:permutation-mat}

The permutation matrix is a square matrix where there is a single
value of one in each row and column with the remaining elements equal
to zero.
\nwenddocs{}\nwbegincode{209}\moddef{permutation-matrix.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Class: Permutation matrix\RA{}
\LA{}Function: Permutation matrix predicate\RA{}
\LA{}Before method: Verify element type not specified and rows equal columns\RA{}
\LA{}Method: Initialize the permutation matrix along the diagonal\RA{}
\LA{}Function: Initialize the permutation matrix with a nested sequence\RA{}
\LA{}Method: Initialize the permutation matrix with a nested sequence\RA{}
\LA{}Method: Initialize the permutation matrix with a 2D array\RA{}
\LA{}Method: Permutation matrix bounds predicate\RA{}
\LA{}Method: Permutation matrix element type\RA{}
\LA{}Method: Permutation matrix dimensions\RA{}
\LA{}Method: Permutation matrix row dimension\RA{}
\LA{}Method: Permutation matrix column dimension\RA{}
\LA{}Method: Permutation matrix element reference\RA{}
\LA{}Method: Copy a permutation matrix\RA{}
\LA{}Method: Subset of a permutation matrix\RA{}
\LA{}Method: Permutation matrix transpose\RA{}
\nwendcode{}\nwbegindocs{210}The permutation matrix depends on the linear algebra package,
fundamental operations and the matrix interface.
\nwenddocs{}\nwbegincode{211}\moddef{Permutation matrix dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "permutation-matrix"
       :depends-on ("defpackage"
                    "fundamental-ops"
                    "matrix"))
\nwendcode{}\nwbegindocs{212}The {\Tt{}contents\nwendquote} slot is a vector equal in length to the size of the
matrix. The vector is populated with integer values where the index of
the value corresponds to row and the value corresponds to the column
index.
\nwenddocs{}\nwbegincode{213}\moddef{Class: Permutation matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass permutation-matrix (matrix-object)
  ((contents
    :type     (array fixnum (*))
    :initarg  :contents
    :accessor contents))
  (:documentation
   "Permutation matrix object."))

\nwendcode{}\nwbegindocs{214}{\Tt{}permutation-matrix\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{215}\moddef{Permutation matrix exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:permutation-matrix
\nwendcode{}\nwbegindocs{216}\nwdocspar

\subsection{Initializing Permutation Matrices}
\label{sec:initializing-permutation-matrices}

The {\Tt{}contents\nwendquote} of a permutation matrix is a first rank array with a
length equal to the size of the matrix. It is invalid to initialize
the permutation matrix with a value. There are 2 tests that apply to
all permutation matrix input data regardless of type. A permutation
matrix is a square matrix, so rows must equal columns. The element
type cannot be specified. Those tests are expressed in a before method
of {\Tt{}initialize-matrix\nwendquote} specialized on {\Tt{}permutation-matrix\nwendquote}.
\nwenddocs{}\nwbegincode{217}\moddef{Before method: Verify element type not specified and rows equal columns}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix :before ((matrix permutation-matrix) data
                                      (rows integer) (columns integer)
                                      &optional element-type)
  "Verify that the element-type was not set and that rows equals columns."
  (declare (ignore matrix data))
  (unless (eq t element-type)
    (error "Cannot specify the element type of a permutation matrix."))
  (unless (= rows columns)
    (error "Number of rows must equal the number of columns.")))

\nwendcode{}\nwbegindocs{218}A default permutation matrix is populated with ones on the diagonal,
equivalent to an identity matrix.
\nwenddocs{}\nwbegincode{219}\moddef{Method: Initialize the permutation matrix along the diagonal}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix permutation-matrix) (data (eql 0))
                              (rows integer) (columns integer)
                              &optional element-type)
  (declare (ignore element-type))
  (loop with contents =
        (setf (contents matrix)
              (make-array rows :element-type 'fixnum))
        for index below rows do
        (setf (aref contents index) index)
        finally (return matrix)))

\nwendcode{}\nwbegindocs{220}The permutation matrix can be initialized with a nested sequence. As
before, the method for nested sequences must be specialized on lists
and vectors separately. Both methods call an internal function to
initialize the permutation matrix.
\nwenddocs{}\nwbegincode{221}\moddef{Function: Initialize the permutation matrix with a nested sequence}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; FIXME : Use the LOOP.
(defun %initialize-permutation-matrix-with-seq (matrix data size)
  (if (= size (length data))
      (let ((contents (setf (contents matrix)
                            (make-array size :element-type 'fixnum))))
        ;; Fill contents, there should be no duplicates.
        (dotimes (i0 size)
          (if (= size (length (elt data i0)))
              (setf (aref contents i0)
                    (or (position 1 (elt data i0))
                        (error "Invalid permutation data.")))
              (error "Columns unequal in length.")))
        ;; FIXME : Find a better way to identify duplicates.
        ;; If duplicates, not a permutation matrix.
        (unless (= size (length (remove-duplicates contents)))
          (error "Invalid permutation in data."))
        ;; Return the matrix
        matrix)
      (error "Invalid number of rows of data.")))

\nwendcode{}\nwbegindocs{222}First, define the initialization for data with a list as the first
rank data structure.
\nwenddocs{}\nwbegincode{223}\moddef{Method: Initialize the permutation matrix with a nested sequence}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix permutation-matrix) (data list)
                              (rows integer) (columns integer)
                              &optional element-type)
  "Initialize the permutation matrix with a list."
  (declare (ignore columns element-type))
  (%initialize-permutation-matrix-with-seq matrix data rows))

\nwendcode{}\nwbegindocs{224}Next, define the initialization for data with a vector as the first
rank data structure.
\nwenddocs{}\nwbegincode{225}\moddef{Method: Initialize the permutation matrix with a nested sequence}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix permutation-matrix) (data vector)
                              (rows integer) (columns integer)
                              &optional element-type)
  "Initialize the permutation matrix with a list."
  (declare (ignore columns element-type))
  (%initialize-permutation-matrix-with-seq matrix data rows))

\nwendcode{}\nwbegindocs{226}Finally, the permutation matrix can be initialized with a 2D array.
\nwenddocs{}\nwbegincode{227}\moddef{Method: Initialize the permutation matrix with a 2D array}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix permutation-matrix) (data array)
                              (rows fixnum) (columns fixnum)
                              &optional element-type)
  "Initialize the permutation matrix with a 2D array."
  (declare (ignore element-type))
  (cond
    ((not (= rows (array-dimension data 0)))
     (error "Invalid number of rows of data."))
    ((not (= columns (array-dimension data 1)))
     (error "Invalid number of columns of data."))
    (t
     (let ((row -1))
       (map-into
        (setf (contents matrix) (make-array rows))
        (lambda ()
          (incf row)
          (do ((column 0 (1+ column)))
              ((cond
                 ((>= column columns)
                  (error "Invalid permutation data."))
                 ((= 1 (aref data row column))))
               column))))
       ;; FIXME : Find a better way to identify duplicates.
       (unless (= rows (length (remove-duplicates (contents matrix))))
         (error "Invalid permutation in data."))
       ;; Return the permutation matrix
       matrix))))

\nwendcode{}\nwbegindocs{228}{\Tt{}initialize-matrix\nwendquote} was exported with the definition of the
generic function.

\subsection{Permutation Matrix Predicates}
\label{sec:permutation-matrix-predicates}

The function {\Tt{}identity-matrix-p\nwendquote} returns true if the object is a
matrix and false otherwise.
\nwenddocs{}\nwbegincode{229}\moddef{Function: Permutation matrix predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun permutation-matrix-p (object)
  "Return true if object is a permutation-matrix."
  (typep object 'permutation-matrix))

\nwendcode{}\nwbegindocs{230}The permutation matrix implmementation of {\Tt{}matrix-in-bounds-p\nwendquote}
checks the bounds against the length of the contents vector.
\nwenddocs{}\nwbegincode{231}\moddef{Method: Permutation matrix bounds predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-in-bounds-p ((matrix permutation-matrix)
                               (row integer) (column integer))
  "Return true if row and column do not exceed the dimensions of matrix."
  (let ((size (length (contents matrix))))
    (and (<= 0 row)    (< row    size)
         (<= 0 column) (< column size))))

\nwendcode{}\nwbegindocs{232}{\Tt{}permutation-matrix-p\nwendquote} is an exported symbol.
{\Tt{}matrix-in-bounds-p\nwendquote} was exported with the definition of the generic
function.
\nwenddocs{}\nwbegincode{233}\moddef{Permutation matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:permutation-matrix-p
\nwendcode{}\nwbegindocs{234}\nwdocspar

\subsection{Inspecting Permutation Matrices}
\label{sec:inspecting-permuation-matrices}

The permutation matrix implementation of {\Tt{}matrix-element-type\nwendquote}
always returns {\Tt{}fixnum\nwendquote}.
\nwenddocs{}\nwbegincode{235}\moddef{Method: Permutation matrix element type}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-element-type ((matrix permutation-matrix))
  "Element type of the permutation matrix."
  'fixnum)

\nwendcode{}\nwbegindocs{236}The permutation matrix implementation of {\Tt{}matrix-dimensions\nwendquote}
returns the length of the contents vector twice.
\nwenddocs{}\nwbegincode{237}\moddef{Method: Permutation matrix dimensions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-dimensions ((matrix permutation-matrix))
  "Return the number of rows and columns in matrix."
  (let ((size (length (contents matrix))))
    (list size size)))

\nwendcode{}\nwbegindocs{238}The permutation matrix implementation of {\Tt{}matrix-row-dimensions\nwendquote}
returns the length of the contents vector.
\nwenddocs{}\nwbegincode{239}\moddef{Method: Permutation matrix row dimension}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-row-dimension ((matrix permutation-matrix))
  "Return the number of rows in matrix."
  (length (contents matrix)))

\nwendcode{}\nwbegindocs{240}{\Tt{}matrix-column-dimension\nwendquote} simply returns the length of the
contents vector as well.
\nwenddocs{}\nwbegincode{241}\moddef{Method: Permutation matrix column dimension}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-column-dimension ((matrix permutation-matrix))
  "Return the number of columns in matrix."
  (length (contents matrix)))

\nwendcode{}\nwbegindocs{242}All of these symbols were exported with the definition of the
generic functions.

\subsection{Referencing Permutation Matrices}
\label{sec:referencing-permutation-matrices}

The elements of a permutation matrix are either 1 or zero. A 1 is
returned if the value stored in the contents matrix at {\Tt{}row\nwendquote} is
equal to {\Tt{}column\nwendquote}, 0 otherwise.
\nwenddocs{}\nwbegincode{243}\moddef{Method: Permutation matrix element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod mref ((matrix permutation-matrix)
                 (row integer) (column integer))
  "Return 1 if a permutation and 0 otherwise."
  (if (= column (aref (contents matrix) row)) 1 0))

\nwendcode{}\nwbegindocs{244}The {\Tt{}(setf\ mref)\nwendquote} function is used to swap the rows of a
permutation matrix. The only valid data value is one.
\nwenddocs{}\nwbegincode{245}\moddef{Method: Permutation matrix element reference}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf mref) ((data (eql 1)) (matrix permutation-matrix)
                        (row integer) (column integer))
  "Swap rows of the permutation matrix."
  (let* ((contents (contents matrix))
         (swap (position column contents)))
    (psetf
     (aref contents swap) (aref contents row)
     (aref contents row)  column)))

\nwendcode{}\nwbegindocs{246}{\Tt{}mref\nwendquote} was exported with the definition of the generic function.

\subsection{Copying Permutation Matrices}
\label{sec:copying-permutation-matrices}

A new permutation matrix that is a copy of the supplied permutation
matrix is returned from {\Tt{}copy-matrix\nwendquote}.
\nwenddocs{}\nwbegincode{247}\moddef{Method: Copy a permutation matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod copy-matrix ((matrix permutation-matrix))
  "Return a copy of the permutation matrix."
  (make-instance
   'permutation-matrix
   :contents (copy-seq (contents matrix))))

\nwendcode{}\nwbegindocs{248}{\Tt{}copy-matrix\nwendquote} was exported with the definition of the generic
function.

\subsection{Manipulating Subsets of Permutation Matrices}
\label{sec:permutation-matrix-subsets}

The subset of a permutation matrix is either a dense matrix or a
square matrix.
\nwenddocs{}\nwbegincode{249}\moddef{Method: Subset of a permutation matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod submatrix ((matrix permutation-matrix)
                      (row integer) (column integer)
                      &key row-end column-end)
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let* ((numrows (- row-end row))
           (numcols (- column-end column))
           (permute  (contents matrix))
           (contents (make-array (list numrows numcols)
                                 :element-type 'fixnum
                                 :initial-element 0)))
      (make-instance
       (if (= numrows numcols) 'square-matrix 'dense-matrix)
       :contents
       (do ((i0 0   (1+ i0))
            (i1 row (1+ i1)))
           ((>= i0 numrows) contents)
         (when (< (1- column) (aref permute i1) column-end)
           (setf (aref contents i0 (- (aref permute i1) column)) 1)))))))

\nwendcode{}\nwbegindocs{250}Setting or replacing the subset of a permutation matrix is an
invalid operation and not defined. {\Tt{}submatrix\nwendquote} was exported with the
definition of the generic function.

\subsection{Permutation Matrix Transpose}
\label{sec:permutation-matrix-transpose}

The {\Tt{}transpose\nwendquote} function is the only fundamental operation
implemented for the permutation matrix.
\nwenddocs{}\nwbegincode{251}\moddef{Method: Permutation matrix transpose}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod transpose ((matrix permutation-matrix) &key conjugate)
  "Transpose the permutation matrix."
  (declare (ignore conjugate))
  (let ((contents (contents matrix)))
    (make-instance
     'permutation-matrix
     :contents
     (loop with permuted =
           (make-array (length contents) :element-type 'fixnum)
           for column across contents
           as  row = 0 then (1+ row)
           do (setf (aref permuted column) row)
           finally (return permuted)))))

\nwendcode{}\nwbegindocs{252}The destructive version, {\Tt{}ntranspose\nwendquote}, requires an initialization
function to count the number of rows to skip and determine the first
row to transpose.
\nwenddocs{}\nwbegincode{253}\moddef{Method: Permutation matrix transpose}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %init-ntranspose (contents)
  "Count the number of rows to skip and the first row."
  (loop with row0 = nil
        for row below (length contents)
        as column = (aref contents row)
        if (= row column) count row into skip
        else do (unless row0 (setf row0 row))
        finally (return (values row0 skip))))

(defmethod ntranspose ((matrix permutation-matrix) &key conjugate)
  "Destructively transpose the permutation matrix."
  (declare (ignore conjugate))
  (multiple-value-bind (row0 skip)
      (%init-ntranspose (contents matrix))
    (loop with contents = (contents matrix)
          repeat (- (length contents) skip)
          for row = row0 then column
          and column = (aref contents row0) then nextrow
          as nextrow = (aref contents column)
          do (setf (aref contents column) row)
          finally (return matrix))))

\nwendcode{}\nwbegindocs{254}{\Tt{}transpose\nwendquote} and {\Tt{}ntranspose\nwendquote} were exported with the definition
of the generic function.

\chapter{Data Vectors}
\label{chap:data-vectors}

The linear algebra vector objects for column and row vectors are
defined in this chapter as subclasses of a data vector. Fundamental
operations described in Chapter~\ref{chap:fundamental-operations} that
are applicable to vectors are implemented.
\nwenddocs{}\nwbegincode{255}\moddef{data-vector.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Data vector classes\RA{}
\LA{}Data vector interface operations\RA{}
\LA{}Data vector iteration operations\RA{}
\LA{}Data vector transformations\RA{}
\LA{}Data vector fundamental operations\RA{}
\nwendcode{}\nwbegindocs{256}Definition of data vectors depends on the linear algebra package,
auxiliary routines, fundamental operations and the vector interface.
\nwenddocs{}\nwbegincode{257}\moddef{Data vector dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "data-vector"
       :depends-on ("defpackage"
                    "auxiliary"
                    "fundamental-ops"
                    "vector"
                    "permutation-matrix"))
\nwendcode{}\nwbegindocs{258}\nwdocspar

\section{Data Vector Classes}
\label{sec:data-vector-classes}

The data vector class is a superclass for two other classes, a row
vector and a colum vector.
\nwenddocs{}\nwbegincode{259}\moddef{Data vector classes}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Data vector classes
\LA{}Class: Data vector\RA{}
\LA{}Class: Row vector\RA{}
\LA{}Class: Column vector\RA{}
\nwendcode{}\nwbegindocs{260}The internal structure of the column and row vector is identical, so
they are defined as subclasses of the {\Tt{}data-vector\nwendquote} which is a
subclass of the {\Tt{}vector-object\nwendquote}. Furthermore, for many operations,
the distinction between a column and row vector is not meaningful. In
those cases, the operations are specialized on {\Tt{}data-vector\nwendquote}. The
{\Tt{}data-vector\nwendquote} also hides differences between a {\Tt{}simple-vector\nwendquote}
with no element type information and a 1D {\Tt{}simple-array\nwendquote} that has
element type information.
\nwenddocs{}\nwbegincode{261}\moddef{Class: Data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass data-vector (vector-object)
  ((contents
    :type (array * (*))
    :initarg :contents
    :accessor contents))
  (:documentation
   "A data vector."))

\nwendcode{}\nwbegindocs{262}In linear algebra operations, the distinction between a column and
row vector is significant. The standard Common Lisp vector does not
provide this distinction, so {\Tt{}row-vector\nwendquote} and {\Tt{}column-vector\nwendquote}
classes are defined.
\nwenddocs{}\nwbegincode{263}\moddef{Class: Row vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass row-vector (data-vector)
  ()
  (:documentation
   "A row vector."))

\nwendcode{}\nwbegindocs{264}\nwdocspar
\nwenddocs{}\nwbegincode{265}\moddef{Class: Column vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass column-vector (data-vector)
  ()
  (:documentation
   "A column vector."))

\nwendcode{}\nwbegindocs{266}{\Tt{}data-vector\nwendquote}, {\Tt{}row-vector\nwendquote} and {\Tt{}column-vector\nwendquote} are exported
symbols.
\nwenddocs{}\nwbegincode{267}\moddef{Data vector exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:data-vector :row-vector :column-vector
\nwendcode{}\nwbegindocs{268}\nwdocspar

\section{Data Vector Interface Operations}
\label{sec:data-vector-interface-operations}

The vector interface operations for data vectors are implemented in
this section. The operations are specialized on the {\Tt{}data-vector\nwendquote}
object when possible. Otherwise, they are specialized separately on
the {\Tt{}row-vector\nwendquote} and {\Tt{}column-vector\nwendquote} objects.
\nwenddocs{}\nwbegincode{269}\moddef{Data vector interface operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Data vector interface operations
\LA{}Method: Initialize the data vector with a number\RA{}
\LA{}Method: Initialize the data vector with a sequence\RA{}
\LA{}Function: Create a row vector\RA{}
\LA{}Function: Create a column vector\RA{}
\LA{}Function: Row vector predicate\RA{}
\LA{}Function: Column vector predicate\RA{}
\LA{}Method: Data vector bounds predicate\RA{}
\LA{}Method: Data vector element type\RA{}
\LA{}Method: Data vector length\RA{}
\LA{}Method: Data vector element reference\RA{}
\LA{}Method: Copy the data vector\RA{}
\LA{}Method: Subset of a data vector\RA{}
\LA{}Method: Destructively replace a data vector subset\RA{}
\nwendcode{}\nwbegindocs{270}\nwdocspar

\subsection{Initializing Data Vectors}
\label{sec:initializing-data-vectors}

Two initialization functions are defined for data vectors. The first
function initializes the vector with a number.
\nwenddocs{}\nwbegincode{271}\moddef{Method: Initialize the data vector with a number}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-vector ((vector data-vector) (data number)
                              (size integer) &optional
                              (element-type 'number))
  "Initialize a data vector with a value."
  (setf (contents vector)
        (make-array size
                    :element-type element-type
                    :initial-element data))
  ;; Return the data vector
  vector)

\nwendcode{}\nwbegindocs{272}The second function initializes the vector with a sequence.
\nwenddocs{}\nwbegincode{273}\moddef{Method: Initialize the data vector with a sequence}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-vector ((vector data-vector) (data sequence)
                              (size integer) &optional
                              (element-type 'number))
  "Initialize a data vector with a sequence."
  (setf (contents vector)
        (make-array size
                    :element-type element-type
                    :initial-contents data))
  ;; Return the data vector
  vector)

\nwendcode{}\nwbegindocs{274}\nwdocspar

Two convenience functions are defined for creating vectors.
{\Tt{}row-vector\nwendquote} accepts an arbitrary number of numeric arguments and
returns an instance of a row vector initialized with those arguments.
\nwenddocs{}\nwbegincode{275}\moddef{Function: Create a row vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun row-vector (&rest numbers)
  "Create a row vector from the numbers."
  (make-vector (length numbers)
               :vector-type 'row-vector
               :initial-contents numbers))

\nwendcode{}\nwbegindocs{276}Similarly, {\Tt{}column-vector\nwendquote} accepts an arbitrary number of numeric
arguments and returns an instance of column vector initialized with
those arguments.
\nwenddocs{}\nwbegincode{277}\moddef{Function: Create a column vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun column-vector (&rest numbers)
  "Create a column vector from the numbers."
  (make-vector (length numbers)
               :vector-type 'column-vector
               :initial-contents numbers))

\nwendcode{}\nwbegindocs{278}{\Tt{}row-vector\nwendquote} and {\Tt{}column-vector\nwendquote} were exported with the
definition of the column and row vector objects.

\subsection{Data Vector Predicates}
\label{sec:data-vector-predicates}

Three predicates specific to data vectors are defined.
{\Tt{}column-vector-p\nwendquote} accepts a single argument and returns true if is
is a {\Tt{}column-vector\nwendquote}.
\nwenddocs{}\nwbegincode{279}\moddef{Function: Column vector predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun column-vector-p (object)
  "Return true if object is a column-vector, NIL otherwise."
  (typep object 'column-vector))

\nwendcode{}\nwbegindocs{280}Similarly, {\Tt{}row-vector-p\nwendquote} accepts a single argument and returns
true if it is a {\Tt{}row-vector\nwendquote}.
\nwenddocs{}\nwbegincode{281}\moddef{Function: Row vector predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun row-vector-p (object)
  "Return true if object is a row-vector, NIL otherwise."
  (typep object 'row-vector))

\nwendcode{}\nwbegindocs{282}Finally, the implementation of {\Tt{}vector-in-bounds-p\nwendquote} is specialized
on the {\Tt{}data-vector\nwendquote} object. It wraps {\Tt{}array-in-bounds-p\nwendquote},
returning true if the index does not exceed the bounds of the vector.
\nwenddocs{}\nwbegincode{283}\moddef{Method: Data vector bounds predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod vector-in-bounds-p ((vector data-vector) (index integer))
  "Return true if index does not exceed the dimensions of vector."
  (array-in-bounds-p (contents vector) index))

\nwendcode{}\nwbegindocs{284}{\Tt{}vector-in-bounds-p\nwendquote} was exported with the definition of the
generic function. {\Tt{}column-vector-p\nwendquote} and {\Tt{}row-vector-p\nwendquote} are
exported symbols.
\nwenddocs{}\nwbegincode{285}\moddef{Data vector exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:column-vector-p :row-vector-p
\nwendcode{}\nwbegindocs{286}\nwdocspar

\subsection{Inspecting Data Vectors}
\label{sec:inspecting-data-vectors}

The {\Tt{}vector-element-type\nwendquote} function specialized on the data vector is
a wrapper for {\Tt{}array-element-type\nwendquote}.
\nwenddocs{}\nwbegincode{287}\moddef{Method: Data vector element type}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod vector-element-type ((vector data-vector))
  "Return the element type of vector."
  (array-element-type (contents vector)))

\nwendcode{}\nwbegindocs{288}The length of a vector is obtained with {\Tt{}vector-length\nwendquote}.
\nwenddocs{}\nwbegincode{289}\moddef{Method: Data vector length}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod vector-length ((vector data-vector))
  "Return the length of the vector."
  (length (contents vector)))

\nwendcode{}\nwbegindocs{290}{\Tt{}vector-element-type\nwendquote} and {\Tt{}vector-length\nwendquote} were exported with the
definition of the generic functions.

\subsection{Referencing Data Vectors}
\label{sec:referencing-data-vectors}

The {\Tt{}vref\nwendquote} function specialized for data vectors is a wrapper for
{\Tt{}aref\nwendquote}.
\nwenddocs{}\nwbegincode{291}\moddef{Method: Data vector element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod vref ((vector data-vector) (index integer))
  "Return the element of vector at index."
  (aref (contents vector) index))

\nwendcode{}\nwbegindocs{292}{\Tt{}vref\nwendquote} is settable.
\nwenddocs{}\nwbegincode{293}\moddef{Method: Data vector element reference}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf vref) ((data number) (vector data-vector) (index integer))
  "Set the element of vector at index to data."
  (setf (aref (contents vector) index) data))

\nwendcode{}\nwbegindocs{294}{\Tt{}vref\nwendquote} was exported with the definition of the generic function.

\subsection{Copying Data Vectors}
\label{sec:copying-data-vectors}

The {\Tt{}copy-data\nwendquote} function specialized for data vectors is essentially
a wrapper for {\Tt{}COPY-SEQ\nwendquote}.
\nwenddocs{}\nwbegincode{295}\moddef{Method: Copy the data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod copy-vector ((vector data-vector))
  "Return a copy of the vector."
  (make-instance
   (class-of vector)
   :contents (copy-seq (contents vector))))

\nwendcode{}\nwbegindocs{296}{\Tt{}copy-vector\nwendquote} was exported with the definition of the generic
function.

\subsection{Manipulating Subsets of Data Vectors}
\label{sec:data-vector-subsets}

Functions for manipulating subsets of vectors are specialized on
{\Tt{}data-vector\nwendquote}. The {\Tt{}subvector\nwendquote} of a data vector is essentially a
wrapper for {\Tt{}subseq\nwendquote}.
\nwenddocs{}\nwbegincode{297}\moddef{Method: Subset of a data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod subvector ((vector data-vector) start &optional end)
  "Return a new data vector that is a subset of vector."
  (make-instance
   (class-of vector)
   :contents (subseq (contents vector) start end)))

\nwendcode{}\nwbegindocs{298}The {\Tt{}subvector\nwendquote} of a data vector is settable.
\nwenddocs{}\nwbegincode{299}\moddef{Method: Subset of a data vector}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf subvector) ((subvector data-vector)
                             (vector data-vector)
                             start &optional end)
  "Set the subvector of the data vector."
  (setf (subseq (contents vector) start end)
        (contents subvector))
  ;; Return the subvector
  subvector)

\nwendcode{}\nwbegindocs{300}Similarly, {\Tt{}replace-vector\nwendquote} specialized on a data vector is
essentially a wrapper for {\Tt{}REPLACE\nwendquote}.
\nwenddocs{}\nwbegincode{301}\moddef{Method: Destructively replace a data vector subset}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod replace-vector ((vector1 data-vector) (vector2 data-vector)
                           &key (start1 0) end1 (start2 0) end2)
  "Destructively replace the elements of vector1 with vector2."
  (replace (contents vector1) (contents vector2)
           :start1 start1 :end1 end1 :start2 start2 :end2 end2)
  ;; Return vector1
  vector1)

\nwendcode{}\nwbegindocs{302}{\Tt{}subvector\nwendquote} and {\Tt{}replace-vector\nwendquote} were exported with the
definition of the generic functions.

\note{In {\Tt{}(setf\ subvector)\nwendquote} and {\Tt{}replace-vector\nwendquote}, it may be
  correct to constrain both arguments to the same type, either both
  {\Tt{}column-vector\nwendquote} or {\Tt{}row-vector\nwendquote}. Conversely, it may be useful to
  be able to specify the subvector using a sequence.}

\section{Data Vector Mapping Functions}
\label{sec:data-vector-mapping}

Implementation of the vector mapping functions for data vectors are
specialized on {\Tt{}data-vector\nwendquote}.
\nwenddocs{}\nwbegincode{303}\moddef{Data vector iteration operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Data vector iteration operations
\LA{}Function: Map over the data vector\RA{}
\LA{}Method: Map over the data vector\RA{}
\LA{}Function: Map into the data vector\RA{}
\LA{}Method: Map into the data vector\RA{}
\nwendcode{}\nwbegindocs{304}To avoid redundant verification of the arguments, an internal
version, {\Tt{}{\%}map-data-vector\nwendquote}, is implemented with the essential
logic.
\nwenddocs{}\nwbegincode{305}\moddef{Function: Map over the data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %map-data-vector (result-type function first-vector
                         &rest more-vectors)
  "Non-validating version of map-vector."
  (make-instance result-type
                 :contents
                 (apply #'map
                        (class-of (contents first-vector))
                        function
                        (contents first-vector)
                        (mapcar #'contents more-vectors))))

\nwendcode{}\nwbegindocs{306}For external use in {\Tt{}map-vector\nwendquote}, the internal version is wrapped
by tests to validate the arguments.
\nwenddocs{}\nwbegincode{307}\moddef{Method: Map over the data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod map-vector :before (result-type (function function)
                               (first-vector data-vector)
                               &rest more-vectors)
  "Verify the arguments to map-vector."
  (declare (ignore function))
  (unless (subtypep result-type 'data-vector)
    (error "~A is not a subtype of DATA-VECTOR." result-type))
  (unless (every (lambda (x) (typep x 'data-vector)) more-vectors)
    (error "All vectors must be data vectors.")))

(defmethod map-vector (result-type (function function)
                       (first-vector data-vector)
                       &rest more-vectors)
  "Calls function on successive sets of data vectors."
  (apply #'%map-data-vector
         result-type
         function
         first-vector
         more-vectors))

\nwendcode{}\nwbegindocs{308}Similarly, the destructive mapping function is organized into an
internal version, {\Tt{}{\%}map-into-data-vector\nwendquote},
\nwenddocs{}\nwbegincode{309}\moddef{Function: Map into the data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %map-into-data-vector (result-vector function &rest vectors)
  "Non-validating version of map-into-vector."
  (apply #'map-into
         (contents result-vector)
         function
         (mapcar #'contents vectors))
  ;; Return the result vector
  result-vector)

\nwendcode{}\nwbegindocs{310}and an external version, {\Tt{}map-into-vector\nwendquote}, that validates the
arguments.
\nwenddocs{}\nwbegincode{311}\moddef{Method: Map into the data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod map-into-vector :before ((result-vector data-vector)
                                    (function function) &rest vectors)
  "Verify the arguments to map-into-vector."
  (declare (ignore result-vector function))
  (unless (every (lambda (x) (typep x 'data-vector)) vectors)
    (error "All vectors must be data vectors.")))

(defmethod map-into-vector ((result-vector data-vector)
                            (function function) &rest vectors)
  "Destructively modifies the result vector with the result of
applying the function to each element of the vectors."
  (apply #'%map-into-data-vector
         result-vector
         function
         vectors))

\nwendcode{}\nwbegindocs{312}{\Tt{}map-vector\nwendquote} and {\Tt{}map-into-vector\nwendquote} were exported with the
definition of the generic functions.

\section{Data Vector Transformations}
\label{sec:data-vector-transformations}

The three vector transformations are defined as functions. Therefore,
the only operation that needs to be specialized on the data vector is
the application of the rotation.
\nwenddocs{}\nwbegincode{313}\moddef{Data vector transformations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Data vector transformations
\LA{}Method: Apply rotation to the data vectors\RA{}
\LA{}Method: Destructively apply rotation to the data vectors\RA{}
\nwendcode{}\nwbegindocs{314}{\Tt{}apply-rotation\nwendquote} returns 2 new vectors that are the rotations of
{\Tt{}vector1\nwendquote} and {\Tt{}vector2\nwendquote}.
\nwenddocs{}\nwbegincode{315}\moddef{Method: Apply rotation to the data vectors}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod apply-rotation :before ((vector1 data-vector) (vector2 data-vector) cc ss)
  "Verify the input to apply-rotation."
  (declare (ignore cc ss))
  (unless (= (vector-length vector1) (vector-length vector2))
    (error "VECTOR1 and VECTOR2 are not of equal length.")))

(defmethod apply-rotation ((vector1 data-vector) (vector2 data-vector) cc ss)
  "Return the plane rotations of vector1 and vector2 by cc and ss."
  (let ((rvec1 (make-vector (vector-length vector1)
                            :vector-type (class-of vector1)
                            :element-type (vector-element-type vector1)))
        (rvec2 (make-vector (vector-length vector2)
                            :vector-type (class-of vector2)
                            :element-type (vector-element-type vector2))))
    (dotimes (pos (vector-length vector1) (values rvec1 rvec2))
      (setf (vref rvec1 pos)
            (+ (* cc (vref vector1 pos))
               (* ss (vref vector2 pos))))
      (setf (vref rvec2 pos)
            (+ (* -1 (conjugate ss) (vref vector1 pos))
               (* cc (vref vector2 pos)))))))

\nwendcode{}\nwbegindocs{316}The destructive version, {\Tt{}napply-rotation\nwendquote}, stores the result in
{\Tt{}vector1\nwendquote} and {\Tt{}vector2\nwendquote}.
\nwenddocs{}\nwbegincode{317}\moddef{Method: Destructively apply rotation to the data vectors}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod napply-rotation :before ((vector1 data-vector) (vector2 data-vector) cc ss)
  "Verify the input to napply-rotation."
  (declare (ignore cc ss))
  (unless (= (vector-length vector1) (vector-length vector2))
    (error "VECTOR1 and VECTOR2 are not of equal length.")))

(defmethod napply-rotation ((vector1 data-vector) (vector2 data-vector) cc ss)
  "Return the plane rotations of vector1 and vector2 by cc and ss."
  (dotimes (pos (vector-length vector1) (values vector1 vector2))
    (psetf (vref vector1 pos)
           (+ (* cc (vref vector1 pos))
              (* ss (vref vector2 pos)))
           (vref vector2 pos)
           (+ (* -1 (conjugate ss) (vref vector1 pos))
              (* cc (vref vector2 pos))))))

\nwendcode{}\nwbegindocs{318}{\Tt{}apply-rotation\nwendquote} and {\Tt{}napply-rotation\nwendquote} were exported with the
definition of the generic functions.

\section{Data Vector Fundamental Operations}
\label{sec:data-vector-fundamental-operations}

All fundamental operations are specialized for the data vector class.
\nwenddocs{}\nwbegincode{319}\moddef{Data vector fundamental operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Data vector fundamental operations
\LA{}Method: Scaled sum of squares of the data vector\RA{}
\LA{}Method: Scaled sum of powers of p of the data vector\RA{}
\LA{}Function: Data vector Taxicab norm\RA{}
\LA{}Function: Data vector Euclidean norm\RA{}
\LA{}Function: Data vector P norm\RA{}
\LA{}Function: Data vector Infinity norm\RA{}
\LA{}Method: Data vector norm\RA{}
\LA{}Method: Data vector transpose\RA{}
\LA{}Method: Data vector permutation\RA{}
\LA{}Method: Scale the data vector\RA{}
\LA{}Method: Data vector binary addition\RA{}
\LA{}Method: Data vector binary subtraction\RA{}
\LA{}Method: Data vector dot product\RA{}
\nwendcode{}\nwbegindocs{320}\nwdocspar

\subsection{Scaled Sums of Data Vectors}
\label{sec:scaled-data-vector-sums}

{\Tt{}sumsq\nwendquote} is specialized on the {\Tt{}data-vector\nwendquote} object.
\nwenddocs{}\nwbegincode{321}\moddef{Method: Scaled sum of squares of the data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod sumsq ((vector data-vector) &key (scale 0) (sumsq 1))
  "Return the scaling parameter and the sum of the squares of vector."
  (let ((abs-val nil))
    (dovector (elm vector (values scale sumsq))
      (when (< 0 (setf abs-val (abs elm)))
        (if (< scale abs-val)
            (setf sumsq (1+ (* sumsq (expt (/ scale abs-val) 2)))
                  scale abs-val)
            (setf sumsq (+ sumsq (expt (/ elm scale) 2))))))))

\nwendcode{}\nwbegindocs{322}Similarly, {\Tt{}sump\nwendquote} is specialized on the {\Tt{}data-vector\nwendquote} object.
\nwenddocs{}\nwbegincode{323}\moddef{Method: Scaled sum of powers of p of the data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod sump ((vector data-vector) (p number) &key (scale 0) (sump 1))
  "Return the scaling parameter and the sum of the P powers of vector."
  (let ((abs-val nil))
    (dovector (elm vector (values scale sump))
      (when (< 0 (setf abs-val (abs elm)))
        (if (< scale abs-val)
            (setf sump (1+ (* sump (expt (/ scale abs-val) p)))
                  scale abs-val)
            (setf sump (+ sump (expt (/ elm scale) p))))))))

\nwendcode{}\nwbegindocs{324}{\Tt{}sumsq\nwendquote} and {\Tt{}sump\nwendquote} were exported with the definition of the
generic functions.

\subsection{Data Vector Norm}
\label{sec:data-vector-norm}

The vector norm returns the measure of the vector, specified by the
{\Tt{}measure\nwendquote} keyword. {\Tt{}measure\nwendquote} defaults to a value of 1, also known as
the Taxicab norm.

The {\Tt{}norm\nwendquote} function is a wrapper function that calls the appropriate
function for the value of {\Tt{}measure\nwendquote}. Three measures are specifically
implemented for vectors, the Taxicab norm({\Tt{}measure\nwendquote}$=1$), the
Euclidean norm({\Tt{}measure\nwendquote}$=2$) and the Infinity
norm({\Tt{}measure\nwendquote}$=\infty$). All other values of {\Tt{}measure\nwendquote} are
handled by a single function.
\nwenddocs{}\nwbegincode{325}\moddef{Method: Data vector norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod norm ((vector data-vector) &key (measure 1))
  "Return the p-norm of the vector."
  (case measure
    (1         (%data-vector-1-norm vector))
    (2         (%data-vector-2-norm vector))
    (:infinity (%data-vector-infinity-norm vector))
    (otherwise
     (if (and (numberp measure) (> measure 2))
         (%data-vector-p-norm vector measure)
         (error "Unrecognized norm, ~A." measure)))))

\nwendcode{}\nwbegindocs{326}The vector specific {\Tt{}norm\nwendquote} function calls one of four functions
based on the value of {\Tt{}measure\nwendquote}. The four functions are the
{\Tt{}{\%}data-vector-1-norm\nwendquote}, {\Tt{}{\%}data-vector-2-norm\nwendquote},
{\Tt{}{\%}data-vector-p-norm\nwendquote} and {\Tt{}{\%}data-vector-infinity-norm\nwendquote} routines.
The {\Tt{}{\%}data-vector-1-norm\nwendquote} is called the ``Taxicab norm'' of a vector. It
is the sum of the absolute values of the vector.
\nwenddocs{}\nwbegincode{327}\moddef{Function: Data vector Taxicab norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %data-vector-1-norm (vector)
  "Return the Taxicab norm of the data vector."
  (loop for element across (contents vector)
        sum (abs element)))

\nwendcode{}\nwbegindocs{328}The {\Tt{}{\%}data-vector-2-norm\nwendquote} is called the ``Euclidean norm'' of a
vector. It is the square root of the sum of the squares of the vector.
\nwenddocs{}\nwbegincode{329}\moddef{Function: Data vector Euclidean norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %data-vector-2-norm (vector)
  "Return the Euclidean norm of the vector."
  (multiple-value-bind (scale sumsq)
      (sumsq (%map-data-vector 'column-vector #'abs vector))
    (* scale (sqrt sumsq))))

\nwendcode{}\nwbegindocs{330}The {\Tt{}{\%}data-vector-p-norm\nwendquote} is the general form of the vector norm.
It is the $P_{th}$ root of the sum of the $P$ powers of the vector.
\nwenddocs{}\nwbegincode{331}\moddef{Function: Data vector P norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %data-vector-p-norm (vector p)
  "Return the p-norm of the vector."
  (multiple-value-bind (scale sump)
      (sump (%map-data-vector 'column-vector #'abs vector) p)
    (* scale (expt sump (/ p)))))

\nwendcode{}\nwbegindocs{332}Lastly, the {\Tt{}{\%}data-vector-infinity-norm\nwendquote} is the maximum absolute
value of the vector.
\nwenddocs{}\nwbegincode{333}\moddef{Function: Data vector Infinity norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %data-vector-infinity-norm (vector)
  "Return the infinity, or maximum, norm of vector."
  (loop for element across (contents vector)
        maximize (abs element)))

\nwendcode{}\nwbegindocs{334}None of the specific norm functions are exported symbols.

\subsection{Data Vector Transpose}
\label{sec:vector-transpose}

The {\Tt{}transpose\nwendquote} function is implemented separately for the
{\Tt{}column-vector\nwendquote} and {\Tt{}row-vector\nwendquote}. The function simply returns the
converse type of the argument, copying the contents. When set to true,
the optional {\Tt{}conjugate\nwendquote} variable returns the Hermitian transpose of
complex valued vectors and has no effect on real valued vectors.
\nwenddocs{}\nwbegincode{335}\moddef{Method: Data vector transpose}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod transpose ((vector column-vector) &key conjugate)
  "Return a row vector."
  (%map-data-vector 'row-vector
                    (if conjugate #'conjugate #'identity)
                    vector))

(defmethod transpose ((vector row-vector) &key conjugate)
  "Return a column vector."
  (%map-data-vector 'column-vector
                    (if conjugate #'conjugate #'identity)
                    vector))

\nwendcode{}\nwbegindocs{336}The destructive vector transpose is performed using
{\Tt{}CHANGE-CLASS\nwendquote}.
\nwenddocs{}\nwbegincode{337}\moddef{Method: Data vector transpose}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod ntranspose ((vector column-vector) &key conjugate)
  "Return a row vector destructively."
  (if conjugate
      (%map-into-data-vector
       (change-class vector 'row-vector) #'conjugate vector)
      (change-class vector 'row-vector)))

(defmethod ntranspose ((vector row-vector) &key conjugate)
  "Return a column vector destructively."
  (if conjugate
      (%map-into-data-vector
       (change-class vector 'column-vector) #'conjugate vector)
      (change-class vector 'column-vector)))

\nwendcode{}\nwbegindocs{338}{\Tt{}transpose\nwendquote} and {\Tt{}ntranspose\nwendquote} were exported with the definition
of the generic function.

\subsection{Vector Permutation}
\label{sec:vector-permutation}

Data vector permutation, {\Tt{}permute\nwendquote}, is implemented separately for
the {\Tt{}column-vector\nwendquote} and {\Tt{}row-vector\nwendquote}. Permutation of a row vector
is performed by pre-multiplying the permutation matrix with the row
vector.
\nwenddocs{}\nwbegincode{339}\moddef{Method: Data vector permutation}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod permute :before ((vector row-vector) (matrix permutation-matrix))
  "Verify that the dimensions are compatible."
  (unless (= (vector-length vector) (matrix-row-dimension matrix))
    (error "Vector and permutation matrix sizes incompatible.")))

(defmethod permute ((vector row-vector) (matrix permutation-matrix))
  "Return the permutation of the row vector."
  (make-instance
   'row-vector
   :contents
   (loop with permuted =
         (make-array (vector-length vector)
                     :element-type (vector-element-type vector))
         for column across (contents matrix)
         and row = 0 then (1+ row)
         do (setf (aref permuted column) (vref vector row))
         finally (return permuted))))

\nwendcode{}\nwbegindocs{340}Permutation of a column vector is performed by multiplying the
column vector with the permutation matrix.
\nwenddocs{}\nwbegincode{341}\moddef{Method: Data vector permutation}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod permute :before ((matrix permutation-matrix) (vector column-vector))
  "Verify that the dimensions are compatible."
  (unless (= (vector-length vector) (matrix-column-dimension matrix))
    (error "Vector and permutation matrix sizes incompatible.")))

(defmethod permute ((matrix permutation-matrix) (vector column-vector))
  "Return the permutation of the column vector."
  (make-instance
   'row-vector
   :contents
   (loop with permuted =
         (make-array (vector-length vector)
                     :element-type (vector-element-type vector))
         for column across (contents matrix)
         and row = 0 then (1+ row)
         do (setf (aref permuted row) (vref vector column))
         finally (return permuted))))

\nwendcode{}\nwbegindocs{342}\nwdocspar

Similarly, destructive data vector permutation is implemented
separately for the {\Tt{}column-vector\nwendquote} and {\Tt{}row-vector\nwendquote}. Destructive
permutation of a {\Tt{}row-vector\nwendquote} requires 2 temporary values to store
the next value to swap and the next column for the swap.
\nwenddocs{}\nwbegincode{343}\moddef{Method: Data vector permutation}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod npermute :before ((vector row-vector) (matrix permutation-matrix))
  "Verify that the dimensions are compatible."
  (unless (= (vector-length vector) (matrix-row-dimension matrix))
    (error "Vector and permutation matrix sizes incompatible.")))

(defmethod npermute ((vector row-vector) (matrix permutation-matrix))
  "Destructively permute the row vector."
  (multiple-value-bind (row0 skip)
      (%init-ntranspose (contents matrix))
    (loop with mat = (contents matrix)
          with vec = (contents vector)
          repeat (- (length mat) skip)
          for column-swap = (aref mat row0) then column-next
          and value-swap  = (aref vec row0) then value-next
          as column-next = (aref mat column-swap)
          as value-next  = (aref vec column-swap)
          do (setf (aref vec column-swap) value-swap)
          finally (return vector))))

\nwendcode{}\nwbegindocs{344}The destructive permutation of a {\Tt{}column-vector\nwendquote} is simply
implemented using {\Tt{}ROTATEF\nwendquote}.
\nwenddocs{}\nwbegincode{345}\moddef{Method: Data vector permutation}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod npermute :before ((matrix permutation-matrix) (vector column-vector))
  "Verify that the dimensions are compatible."
  (unless (= (vector-length vector) (matrix-column-dimension matrix))
    (error "Vector and permutation matrix sizes incompatible.")))

(defmethod npermute ((matrix permutation-matrix) (vector column-vector))
  "Destructively permute the column vector."
  (multiple-value-bind (row0 skip)
      (%init-ntranspose (contents matrix))
    (loop with mat = (contents matrix)
          with vec = (contents vector)
          repeat (- (length mat) skip 1)
          for row = row0 then column
          as column = (aref mat row)
          do (rotatef (aref vec row) (aref vec column))
          finally (return vector))))

\nwendcode{}\nwbegindocs{346}\nwdocspar

\note{Use of {\Tt{}ROTATEF\nwendquote} in the destructive permutation of a
  {\Tt{}column-vector\nwendquote} needs to be reviewed to evaluate how much consing
  it generates.}

\subsection{Vector Scale}
\label{sec:vector-scale}

Scale the elements of the vector argument by the scalar argument. A
new vector is returned using the {\Tt{}scale\nwendquote} function.
\nwenddocs{}\nwbegincode{347}\moddef{Method: Scale the data vector}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod scale ((scalar number) (vector data-vector))
  "Return the vector scaled by scalar."
  (%map-data-vector (class-of vector)
                    (lambda (x) (* scalar x))
                    vector))

\nwendcode{}\nwbegindocs{348}The vector argument is destructively modified using the {\Tt{}nscale\nwendquote}
function.
\nwenddocs{}\nwbegincode{349}\moddef{Method: Scale the data vector}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod nscale ((scalar number) (vector data-vector))
  "Return the vector destructively scaled by scalar."
  (%map-into-data-vector vector
                         (lambda (x) (* scalar x))
                         vector))

\nwendcode{}\nwbegindocs{350}{\Tt{}scale\nwendquote} and {\Tt{}nscale\nwendquote} were exported with the generic functions.

\subsection{Vector Addition}
\label{sec:vector-addition}

{\Tt{}add\nwendquote} returns a new vector of the sum of {\Tt{}vector1\nwendquote} and {\Tt{}vector2\nwendquote}.
\nwenddocs{}\nwbegincode{351}\moddef{Method: Data vector binary addition}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod add :before ((vector1 data-vector) (vector2 data-vector)
                        &key scalar1 scalar2)
  "Verify that the dimensions are equal."
  (declare (ignore scalar1 scalar2))
  (unless (= (vector-length vector1) (vector-length vector2))
    (error "VECTOR1 and VECTOR2 are not of equal length.")))

(defmethod add ((vector1 column-vector) (vector2 column-vector)
                &key scalar1 scalar2)
  "Return the addition of scalar1*vector1 with scalar2*vector2."
  (%map-data-vector (common-class-of vector1 vector2 'column-vector)
                    (scaled-binary-op #'+ scalar1 scalar2)
                    vector1 vector2))

(defmethod add ((vector1 row-vector) (vector2 row-vector)
                &key scalar1 scalar2)
  "Return the addition of scalar1*vector1 with scalar2*vector2."
  (%map-data-vector (common-class-of vector1 vector2 'row-vector)
                    (scaled-binary-op #'+ scalar1 scalar2)
                    vector1 vector2))

\nwendcode{}\nwbegindocs{352}The destructive version, {\Tt{}nadd\nwendquote}, returns the result in the first
argument.
\nwenddocs{}\nwbegincode{353}\moddef{Method: Data vector binary addition}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod nadd :before ((vector1 data-vector) (vector2 data-vector)
                         &key scalar1 scalar2)
  "Verify that the dimensions are equal."
  (declare (ignore scalar1 scalar2))
  (unless (= (vector-length vector1) (vector-length vector2))
    (error "VECTOR1 and VECTOR2 are not of equal length in NADD-SCALED.")))

(defmethod nadd ((vector1 column-vector) (vector2 column-vector)
                 &key scalar1 scalar2)
  "Return the addition of scalar2*vector2 to scalar1*vector1."
  (%map-into-data-vector vector1
                         (scaled-binary-op #'+ scalar1 scalar2)
                         vector1 vector2))

(defmethod nadd ((vector1 row-vector) (vector2 row-vector)
                 &key scalar1 scalar2)
  "Return the addition of scalar2*vector2 to scalar1*vector1."
  (%map-into-data-vector vector1
                         (scaled-binary-op #'+ scalar1 scalar2)
                         vector1 vector2))

\nwendcode{}\nwbegindocs{354}{\Tt{}add\nwendquote} and {\Tt{}nadd\nwendquote} are exported with the definition of the generic
function.

\subsection{Vector Subtraction}
\label{sec:vector-subtraction}

{\Tt{}subtract\nwendquote} returns a new vector that is {\Tt{}vector2\nwendquote} subtracted from
{\Tt{}vector1\nwendquote}.
\nwenddocs{}\nwbegincode{355}\moddef{Method: Data vector binary subtraction}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod subtract :before ((vector1 data-vector) (vector2 data-vector)
                             &key scalar1 scalar2)
  "Verify that the dimensions are equal."
  (declare (ignore scalar1 scalar2))
  (unless (= (vector-length vector1) (vector-length vector2))
    (error "VECTOR1 and VECTOR2 are not of equal length.")))

(defmethod subtract ((vector1 column-vector) (vector2 column-vector)
                     &key scalar1 scalar2)
  "Return the subraction of scalar2*vector2 from scalar1*vector1."
  (%map-data-vector (common-class-of vector1 vector2 'column-vector)
                    (scaled-binary-op #'- scalar1 scalar2)
                    vector1 vector2))

(defmethod subtract ((vector1 row-vector) (vector2 row-vector)
                     &key scalar1 scalar2)
  "Return the subraction of scalar2*vector2 from scalar1*vector1."
  (%map-data-vector (common-class-of vector1 vector2 'row-vector)
                    (scaled-binary-op #'- scalar1 scalar2)
                    vector1 vector2))

\nwendcode{}\nwbegindocs{356}The destructive version, {\Tt{}nsubtract\nwendquote}, returns the result in the
first argument.
\nwenddocs{}\nwbegincode{357}\moddef{Method: Data vector binary subtraction}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod nsubtract :before ((vector1 data-vector) (vector2 data-vector)
                              &key scalar1 scalar2)
  "Verify that the dimensions are equal."
  (declare (ignore scalar1 scalar2))
  (unless (= (vector-length vector1) (vector-length vector2))
    (error "VECTOR1 and VECTOR2 are not of equal length.")))

(defmethod nsubtract ((vector1 column-vector) (vector2 column-vector)
                      &key scalar1 scalar2)
  "Return the subraction of scalar2*vector2 from scalar1*vector1."
  (%map-into-data-vector vector1
                         (scaled-binary-op #'- scalar1 scalar2)
                         vector1 vector2))

(defmethod nsubtract ((vector1 row-vector) (vector2 row-vector)
                      &key scalar1 scalar2)
  "Return the subraction of scalar2*vector2 from scalar1*vector1."
  (%map-into-data-vector vector1
                         (scaled-binary-op #'- scalar1 scalar2)
                         vector1 vector2))

\nwendcode{}\nwbegindocs{358}{\Tt{}subtract\nwendquote} and {\Tt{}nsubtract\nwendquote} are exported with the definitions of
the generic functions.

\subsection{Data Vector Dot Product}
\label{sec:data-vector-dot-product}

The dot product of data vectors necessitates a {\Tt{}row-vector\nwendquote} for the
first argument and a {\Tt{}column-vector\nwendquote} for the second.
\nwenddocs{}\nwbegincode{359}\moddef{Method: Data vector dot product}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod product :before ((vector1 row-vector) (vector2 column-vector)
                            &key scalar conjugate)
  "Verify that the dimensions are equal."
  (declare (ignore scalar conjugate))
  (unless (= (vector-length vector1) (vector-length vector2))
    (error "VECTOR1 and VECTOR2 are not of equal length.")))

(defmethod product ((vector1 row-vector) (vector2 column-vector)
                    &key (scalar nil scalarp) conjugate)
  "Return the dot product of vector1 and vector2."
  (loop with op = (if conjugate
                      (lambda (x y) (* (conjugate x) y))
                      #'*)
        for element1 across (contents vector1)
        and element2 across (contents vector2)
        sum (funcall op element1 element2) into result
        finally
        (return (if scalarp (* scalar result) result))))

\nwendcode{}\nwbegindocs{360}{\Tt{}product\nwendquote} was exported with the definition of the generic function.

\note{Application of the conjugate should be restricted to complex
  valued vectors. The only issue with applying it to real valued
  vectors is that it is computationally inefficient. Benchmarking
  should determine whether or not this is a legitimate concern.}

\chapter{Dense Matrices}
\label{chap:dense-matrices}

A matrix is concise way to express a linear system. It organizes the
coefficients of the system into rows and columns. There is no
requirement that the number of rows equals the number of columns. When
the number of rows is less than the number of columns, the system is
under determined. When the number of rows exceeds the number of
columns, the system is over determined. The purpose of the dense
matrix object is to represent any matrix.
\nwenddocs{}\nwbegincode{361}\moddef{dense-matrix.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Class: Dense matrix\RA{}
\LA{}Dense matrix interface operations\RA{}
\LA{}Dense matrix fundamental operations\RA{}
\nwendcode{}\nwbegindocs{362}The dense matrix depends on the linear algebra package, fundamental
operations, the matrix interface and data vectors.
\nwenddocs{}\nwbegincode{363}\moddef{Dense matrix dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "dense-matrix"
       :depends-on ("defpackage"
                    "fundamental-ops"
                    "matrix"
                    "data-vector"))
\nwendcode{}\nwbegindocs{364}The dense matrix is a direct subclass of {\Tt{}matrix-object\nwendquote}. It has a
single slot, {\Tt{}contents\nwendquote}, a rank 2 array where the matrix data is
stored. This should be an appropriate data type for storage of most
types of matrices, but can be overridden if another type of storage is
more appropriate.
\nwenddocs{}\nwbegincode{365}\moddef{Class: Dense matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass dense-matrix (matrix-object)
  ((contents
    :type     (array * (* *))
    :initarg  :contents
    :accessor contents))
  (:documentation
   "Dense matrix object."))

\nwendcode{}\nwbegindocs{366}{\Tt{}dense-matrix\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{367}\moddef{Dense matrix exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:dense-matrix
\nwendcode{}\nwbegindocs{368}\nwdocspar

\section{Dense Matrix Interface Operations}
\label{sec:dense-matrix-interface-operations}

The matrix interface operations for dense matrices are implemented in
this section. All operations are specialized on the {\Tt{}dense-matrix\nwendquote}
object.
\nwenddocs{}\nwbegincode{369}\moddef{Dense matrix interface operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Dense matrix interface operations
\LA{}Function: Dense matrix predicate\RA{}
\LA{}Method: Initialize the dense matrix with a value\RA{}
\LA{}Method: Initialize the dense matrix with a nested sequence\RA{}
\LA{}Before method: Verify the array data dimensions\RA{}
\LA{}Method: Initialize the dense matrix with a 2D array\RA{}
\LA{}Method: Dense matrix bounds predicate\RA{}
\LA{}Method: Dense matrix dimensions\RA{}
\LA{}Method: Dense matrix row dimension\RA{}
\LA{}Method: Dense matrix column dimension\RA{}
\LA{}Method: Dense matrix element type\RA{}
\LA{}Method: Dense matrix element reference\RA{}
\LA{}Method: Copy a dense matrix\RA{}
\LA{}Method: Subset of a dense matrix\RA{}
\LA{}Method: Destructively replace a subset of a dense matrix\RA{}
\nwendcode{}\nwbegindocs{370}\nwdocspar

\subsection{Initializing Dense Matrices}
\label{sec:initializing-dense-matrices}

The contents of a dense matrix is a second rank array with
dimensions of {\Tt{}rows\nwendquote} by {\Tt{}columns\nwendquote}. When an {\Tt{}initial-element\nwendquote} is
supplied to {\Tt{}make-matrix\nwendquote}, it is simply passed to the construction
of the contents array. Otherwise, if no {\Tt{}initial-contents\nwendquote} are
supplied, a zero coerced to {\Tt{}element-type\nwendquote} is supplied as the
{\Tt{}initial-element\nwendquote}.
\nwenddocs{}\nwbegincode{371}\moddef{Method: Initialize the dense matrix with a value}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix dense-matrix) (data number)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the dense matrix with an initial element."
  (setf (contents matrix)
        (make-array (list rows columns)
                    :element-type element-type
                    :initial-element data))
  ;; Return the matrix
  matrix)

\nwendcode{}\nwbegindocs{372}When a nested sequence is supplied as the {\Tt{}initial-contents\nwendquote}, it
is simply passed to the construction of the contents array. The method
must be specialized on both {\Tt{}LIST\nwendquote} and {\Tt{}VECTOR\nwendquote} instead of
{\Tt{}SEQUENCE\nwendquote} because the system class {\Tt{}VECTOR\nwendquote} is a subclass of
{\Tt{}ARRAY\nwendquote} which is a subclass of {\Tt{}SEQUENCE\nwendquote}.
\nwenddocs{}\nwbegincode{373}\moddef{Method: Initialize the dense matrix with a nested sequence}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix dense-matrix) (data list)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the dense matrix with a nested sequence."
  (setf (contents matrix)
        (make-array (list rows columns)
                    :element-type element-type
                    :initial-contents data))
  ;; Return the matrix
  matrix)

(defmethod initialize-matrix ((matrix dense-matrix) (data vector)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the dense matrix with a nested sequence."
  (setf (contents matrix)
        (make-array (list rows columns)
                    :element-type element-type
                    :initial-contents data))
  ;; Return the matrix
  matrix)

\nwendcode{}\nwbegindocs{374}For initial contents specified by a 2D array, a before method is
required because the {\Tt{}MAKE-ARRAY\nwendquote} function is not used to initialize
the contents. The before method verifies that the dimensions of the
data array are compatible with the matrix. Each element of the data
array is also verified to be a subtype of {\Tt{}element-type\nwendquote}.
\nwenddocs{}\nwbegincode{375}\moddef{Before method: Verify the array data dimensions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix :before ((matrix dense-matrix) (data array)
                                      (rows integer) (columns integer)
                                      &optional (element-type t))
  "Verify that the size of the data is valid."
  (when (vectorp data) (return-from initialize-matrix))
  (unless (= 2 (array-rank data))
    (error "Rank of array data is invalid."))
  (unless (= rows (array-dimension data 0))
    (error "Invalid number of rows of data."))
  (unless (= columns (array-dimension data 1))
    (error "Invalid number of columns of data."))
  (unless (subtypep (array-element-type data)
                    (upgraded-array-element-type element-type))
    (error "Data type, ~A, is not of type ~A."
           (array-element-type data) element-type)))

\nwendcode{}\nwbegindocs{376}When a 2D array is supplied as the {\Tt{}initial-contents\nwendquote}, the
contents slot of the dense matrix is set to a new, uninitialized,
array. Then, each element of the data array is copied to the new
contents array.
\nwenddocs{}\nwbegincode{377}\moddef{Method: Initialize the dense matrix with a 2D array}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix dense-matrix) (data array)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the dense matrix with a 2D array."
  (let ((contents
         (setf (contents matrix)
               (make-array (list rows columns)
                           :element-type element-type))))
    (dotimes (i0 rows matrix)
      (dotimes (i1 columns)
        (setf (aref contents i0 i1) (aref data i0 i1))))))

\nwendcode{}\nwbegindocs{378}{\Tt{}initialize-matrix\nwendquote} was exported with the definition of the generic
function.

\note{A good reason to implement a matrix condition system is that the
  {\Tt{}MAKE-ARRAY\nwendquote} function is relied upon to signal errors in the input
  data for nested sequences. The error messages will relate to array
  errors and may obsfucate the error and the solution.}

\subsection{Dense Matrix Predicates}
\label{sec:dense-matrix-predicates}

The function {\Tt{}dense-matrix-p\nwendquote} returns true if the object is a
matrix and false otherwise.
\nwenddocs{}\nwbegincode{379}\moddef{Function: Dense matrix predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun dense-matrix-p (object)
  "Return true if object is a dense matrix."
  (typep object 'dense-matrix))

\nwendcode{}\nwbegindocs{380}The dense matrix implementation of {\Tt{}matrix-in-bounds-p\nwendquote} is a
wrapper around {\Tt{}array-in-bounds-p\nwendquote}.
\nwenddocs{}\nwbegincode{381}\moddef{Method: Dense matrix bounds predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-in-bounds-p ((matrix dense-matrix)
                               (row integer) (column integer))
  "Return true if row and column do not exceed the dimensions of matrix."
  (array-in-bounds-p (contents matrix) row column))

\nwendcode{}\nwbegindocs{382}{\Tt{}dense-matrix-p\nwendquote} is an exported symbol. {\Tt{}matrix-in-bounds-p\nwendquote}
was exported with the definition of the generic function.
\nwenddocs{}\nwbegincode{383}\moddef{Dense matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:dense-matrix-p
\nwendcode{}\nwbegindocs{384}\nwdocspar

\subsection{Inspecting Dense Matrices}
\label{sec:inspecting-dense-matrices}

The dense matrix implementation of {\Tt{}matrix-element-type\nwendquote} is a
wrapper around {\Tt{}ARRAY-ELEMENT-TYPE\nwendquote}.
\nwenddocs{}\nwbegincode{385}\moddef{Method: Dense matrix element type}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-element-type ((matrix dense-matrix))
  "Return the element type of the matrix."
  (array-element-type (contents matrix)))

\nwendcode{}\nwbegindocs{386}The dense matrix implementation of {\Tt{}matrix-dimensions\nwendquote} is a
wrapper around {\Tt{}ARRAY-DIMENSIONS\nwendquote}.
\nwenddocs{}\nwbegincode{387}\moddef{Method: Dense matrix dimensions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-dimensions ((matrix dense-matrix))
  "Return the number of rows and columns in matrix."
  (array-dimensions (contents matrix)))

\nwendcode{}\nwbegindocs{388}The dense matrix implementation of {\Tt{}matrix-row-dimension\nwendquote} is a
wrapper around {\Tt{}ARRAY-DIMENSION\nwendquote} with the axis number set to zero.
\nwenddocs{}\nwbegincode{389}\moddef{Method: Dense matrix row dimension}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-row-dimension ((matrix dense-matrix))
  "Return the number of rows in matrix."
  (array-dimension (contents matrix) 0))

\nwendcode{}\nwbegindocs{390}Similarly, the dense matrix implementation of
{\Tt{}matrix-column-dimension\nwendquote} is a wrapper around {\Tt{}ARRAY-DIMENSION\nwendquote}
with the axis number set to one.
\nwenddocs{}\nwbegincode{391}\moddef{Method: Dense matrix column dimension}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod matrix-column-dimension ((matrix dense-matrix))
  "Return the number of columns in matrix."
  (array-dimension (contents matrix) 1))

\nwendcode{}\nwbegindocs{392}All of these symbols were exported with the definition of the
generic functions.

\subsection{Referencing Dense Matrices}
\label{sec:referencing-dense-matrices}

The dense matrix implementation of {\Tt{}mref\nwendquote} is a wrapper around
{\Tt{}AREF\nwendquote}.
\nwenddocs{}\nwbegincode{393}\moddef{Method: Dense matrix element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod mref ((matrix dense-matrix) (row integer) (column integer))
  "Return the element of matrix at row,column."
  (aref (contents matrix) row column))

\nwendcode{}\nwbegindocs{394}A dense matrix is settable. The implementation is simply a wrapper
around {\Tt{}(setf\ aref)\nwendquote}.
\nwenddocs{}\nwbegincode{395}\moddef{Method: Dense matrix element reference}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf mref) ((data number) (matrix dense-matrix)
                        (row integer) (column integer))
  "Set the element of matrix at row,column."
  (setf (aref (contents matrix) row column) data))

\nwendcode{}\nwbegindocs{396}{\Tt{}mref\nwendquote} was exported with the definition of the generic function.

\subsection{Copying Dense Matrices}
\label{sec:copying-dense-matrices}

A new dense matrix that is a copy of the supplied dense matrix is
returned from {\Tt{}copy-matrix\nwendquote}.
\nwenddocs{}\nwbegincode{397}\moddef{Method: Copy a dense matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod copy-matrix ((matrix dense-matrix))
  "Return a copy of the dense matrix."
  (let ((rows     (matrix-row-dimension matrix))
        (columns  (matrix-column-dimension matrix))
        (original (contents matrix))
        (contents (make-array (matrix-dimensions matrix)
                              :element-type
                              (matrix-element-type matrix))))
    (make-instance
     (class-of matrix)
     :contents
     (dotimes (i0 rows contents)
       (dotimes (i1 columns)
         (setf (aref contents i0 i1) (aref original i0 i1)))))))

\nwendcode{}\nwbegindocs{398}{\Tt{}copy-matrix\nwendquote} was exported with the definition of the generic
function.

\subsection{Manipulating Subsets of Dense Matrices}
\label{sec:dense-matrix-subsets}

The submatrix of a dense matrix is always a dense matrix.
\nwenddocs{}\nwbegincode{399}\moddef{Method: Subset of a dense matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod submatrix ((matrix dense-matrix)
                      (row integer) (column integer)
                      &key row-end column-end)
  "Return a dense matrix created from the submatrix of a matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let* ((numrows (- row-end row))
           (numcols (- column-end column))
           (original (contents matrix))
           (contents (make-array (list numrows numcols)
                                 :element-type
                                 (matrix-element-type matrix))))
      (make-instance
       'dense-matrix
       :contents
       (dotimes (i0 numrows contents)
         (dotimes (i1 numcols)
           (setf (aref contents i0 i1)
                 (aref original (+ row i0) (+ column i1)))))))))

\nwendcode{}\nwbegindocs{400}The submatrix of a dense matrix is settable.
\nwenddocs{}\nwbegincode{401}\moddef{Method: Subset of a dense matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf submatrix) ((data dense-matrix) (matrix dense-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set the submatrix of matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data)))
          (mat (contents matrix))
          (dat (contents data)))
      (do ((di0 0   (1+ di0))
           (mi0 row (1+ mi0)))
          ((>= di0 numrows) data)       ; Return the data
        (do ((di1 0      (1+ di1))
             (mi1 column (1+ mi1)))
            ((>= di1 numcols))
          (setf (aref mat mi0 mi1) (aref dat di0 di1)))))))

\nwendcode{}\nwbegindocs{402}For the definition of a dense matrix, {\Tt{}replace-matrix\nwendquote} is
specialized on the first matrix being a {\Tt{}dense-matrix\nwendquote}. The second
matrix is specialized on the {\Tt{}matrix-object\nwendquote} superclass and
therefore can be any type of matrix.
\nwenddocs{}\nwbegincode{403}\moddef{Method: Destructively replace a subset of a dense matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod replace-matrix ((matrix1 dense-matrix) (matrix2 dense-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of matrix1 with matrix2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2)))
            (contents1 (contents matrix1))
            (contents2 (contents matrix2)))
        (do ((i0    0    (1+ i0))
             (m1-i0 row1 (1+ m1-i0))
             (m2-i0 row2 (1+ m2-i0)))
            ((>= i0 numrows) matrix1)   ; Return MATRIX1
          (do ((i1    0       (1+ i1))
               (m1-i1 column1 (1+ m1-i1))
               (m2-i1 column2 (1+ m2-i1)))
              ((>= i1 numcols))
            (setf (aref contents1 m1-i0 m1-i1)
                  (aref contents2 m2-i0 m2-i1))))))))

\nwendcode{}\nwbegindocs{404}{\Tt{}submatrix\nwendquote} and {\Tt{}replace-matrix\nwendquote} were exported with the
definitions of the generic functions.

\section{Dense Matrix Fundamental Operations}
\label{sec:dense-matrix-fundamental-operations}

\nwenddocs{}\nwbegincode{405}\moddef{Dense matrix fundamental operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Dense matrix fundamental operations
\LA{}Method: Scaled sum of squares of the dense matrix\RA{}
\LA{}Method: Scaled sum of powers of p of the dense matrix\RA{}
\LA{}Function: Dense matrix 1 norm\RA{}
\LA{}Function: Dense matrix max norm\RA{}
\LA{}Function: Dense matrix Frobenius norm\RA{}
\LA{}Function: Dense matrix infinity norm\RA{}
\LA{}Method: Dense matrix norm\RA{}
\LA{}Method: Dense matrix transpose\RA{}
\LA{}Method: Dense matrix scale\RA{}
\LA{}Method: Dense matrix addition\RA{}
\LA{}Method: Row vector - dense matrix product\RA{}
\LA{}Method: Dense matrix - column vector product\RA{}
\LA{}Method: Dense matrix - matrix product\RA{}
\nwendcode{}\nwbegindocs{406}\nwdocspar

\subsection{Scaled Sums of Dense Matrices}
\label{sec:scaled-sums-of-dense-matrices}

{\Tt{}sumsq\nwendquote} is specialized on the {\Tt{}dense-matrix\nwendquote} object.
\nwenddocs{}\nwbegincode{407}\moddef{Method: Scaled sum of squares of the dense matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod sumsq ((matrix dense-matrix) &key (scale 0) (sumsq 1))
  "Return the scaling parameter and the sum of the squares of the matrix."
  (destructuring-bind (numrows numcols) (matrix-dimensions matrix)
    (let ((mat (contents matrix))
          (abs-val 0))
      (dotimes (i0 numrows (values scale sumsq))
        (dotimes (i1 numcols)
          (when (< 0 (setf abs-val (abs (aref mat i0 i1))))
            (if (< scale abs-val)
                (setf sumsq (1+ (* sumsq (expt (/ scale abs-val) 2)))
                      scale abs-val)
                (incf sumsq (expt (/ abs-val scale) 2)))))))))

\nwendcode{}\nwbegindocs{408}similarly, {\Tt{}sump\nwendquote} is specialized on the {\Tt{}dense-matrix\nwendquote} object.
\nwenddocs{}\nwbegincode{409}\moddef{Method: Scaled sum of powers of p of the dense matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod sump ((matrix dense-matrix) (p number) &key (scale 0) (sump 1))
  "Return the scaling parameter and the sum of the P powers of the matrix."
  (unless (plusp p) (error "The power(~A) must be positive." p))
  (destructuring-bind (numrows numcols) (matrix-dimensions matrix)
    (let ((mat (contents matrix))
          (abs-val 0))
      (dotimes (i0 numrows (values scale sump))
        (dotimes (i1 numcols)
          (when (< 0 (setf abs-val (abs (aref mat i0 i1))))
            (if (< scale abs-val)
                (setf sump (1+ (* sump (expt (/ scale abs-val) p)))
                      scale abs-val)
                (incf sump (expt (/ (aref mat i0 i1) scale) p)))))))))

\nwendcode{}\nwbegindocs{410}\nwdocspar

\note{At the minimum, the test for a positive power P in {\Tt{}sump\nwendquote}
  should be put in a {\Tt{}:BEFORE\nwendquote} method specialized on
  {\Tt{}dense-matrix\nwendquote}. It's possible it should be applied to a
  {\Tt{}:BEFORE\nwendquote} method for both {\Tt{}data-vector\nwendquote} and {\Tt{}dense-matrix\nwendquote}
  {\Tt{}sump\nwendquote}.}

\subsection{Dense Matrix Norm}
\label{sec:dense-matrix-norm}

the {\Tt{}norm\nwendquote} function for dense matrices is a wrapper function that
calls the appropriate function for the value of {\Tt{}measure\nwendquote}. Four
measures are implemented for dense matrices, the 1-norm, the max norm,
the Frobenius norm and the infinity norm.
\nwenddocs{}\nwbegincode{411}\moddef{Method: Dense matrix norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod norm ((matrix dense-matrix) &key (measure 1))
  "Return the norm of the matrix."
  (case measure
    (1          (%dense-matrix-1-norm matrix))
    (:max       (%dense-matrix-max-norm matrix))
    (:frobenius (%dense-matrix-frobenius-norm matrix))
    (:infinity  (%dense-matrix-infinity-norm matrix))
    (otherwise  (error "Unrecognized norm, ~A." measure))))

\nwendcode{}\nwbegindocs{412}\nwdocspar
\nwenddocs{}\nwbegincode{413}\moddef{Function: Dense matrix 1 norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %dense-matrix-1-norm (matrix)
  "Return the 1 norm of the matrix."
  (destructuring-bind (numrows numcols) (matrix-dimensions matrix)
    (let ((mat (contents matrix))
          (zero (coerce 0 (matrix-element-type matrix)))
          (norm 0)
          (sum 0))
      (dotimes (i1 numcols norm)
        (setf sum zero)
        (dotimes (i0 numrows)
          (incf sum (abs (aref mat i0 i1))))
        (setf norm (max sum norm))))))

\nwendcode{}\nwbegindocs{414}\nwdocspar
\nwenddocs{}\nwbegincode{415}\moddef{Function: Dense matrix max norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %dense-matrix-max-norm (matrix)
  "Return the max norm of the matrix."
  (destructuring-bind (numrows numcols) (matrix-dimensions matrix)
    (let ((mat (contents matrix))
          (norm 0))
      (dotimes (i0 numrows norm)
        (dotimes (i1 numcols)
          (setf norm (max norm (abs (aref mat i0 i1)))))))))

\nwendcode{}\nwbegindocs{416}\nwdocspar
\nwenddocs{}\nwbegincode{417}\moddef{Function: Dense matrix Frobenius norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %dense-matrix-frobenius-norm (matrix)
  "Return the Frobenius norm of the matrix."
  (multiple-value-bind (scale sumsq) (sumsq matrix)
    (* scale (sqrt sumsq))))

\nwendcode{}\nwbegindocs{418}\nwdocspar
\nwenddocs{}\nwbegincode{419}\moddef{Function: Dense matrix infinity norm}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %dense-matrix-infinity-norm (matrix)
  "Return the infinity norm of the matrix."
  (destructuring-bind (numrows numcols) (matrix-dimensions matrix)
    (let ((mat (contents matrix))
          (zero (coerce 0 (matrix-element-type matrix)))
          (norm 0)
          (sum 0))
      (dotimes (i0 numrows norm)
        (setf sum zero)
        (dotimes (i1 numcols)
          (incf sum (abs (aref mat i0 i1))))
        (setf norm (max sum norm))))))

\nwendcode{}\nwbegindocs{420}\nwdocspar

\subsection{Dense Matrix Transpose}
\label{sec:dense-matrix-transpose}

The {\Tt{}transpose\nwendquote} function for a dense matrix returns a dense
matrix. When set to true, the {\Tt{}conjugate\nwendquote} keyword returns the
Hermitian transpose of the complex valued matrices and does nothing
for real valued vectors.
\nwenddocs{}\nwbegincode{421}\moddef{Method: Dense matrix transpose}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod transpose ((matrix dense-matrix) &key conjugate)
  "Return the transpose of the matrix."
  (make-instance
   (class-of matrix)
   :contents
   (destructuring-bind (numrows numcols)
       (matrix-dimensions matrix)
     (let ((op (if conjugate #'conjugate #'identity))
           (contents  (contents matrix))
           (tcontents (make-array
                       (list numcols numrows)
                       :element-type
                       (matrix-element-type matrix))))
       (dotimes (i0 numrows tcontents)
         (dotimes (i1 numcols)
           (setf (aref tcontents i1 i0)
                 (funcall op (aref contents i0 i1)))))))))

\nwendcode{}\nwbegindocs{422}The destructive version, {\Tt{}ntranspose\nwendquote}, is limited to dense
matrices with an equal number of rows and columns.
\nwenddocs{}\nwbegincode{423}\moddef{Method: Dense matrix transpose}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod ntranspose ((matrix dense-matrix) &key conjugate)
  "Replace the contents of the dense matrix with the transpose."
  (destructuring-bind (numrows numcols) (matrix-dimensions matrix)
    (if (= numrows numcols)
        (let ((op (if conjugate #'conjugate #'identity))
              (contents (contents matrix)))
          (dotimes (i0 numrows matrix)
            ;; FIXME : Conjugate on the diagonal may not be correct.
            (setf (aref contents i0 i0) (funcall op (aref contents i0 i0)))
            (do ((i1 (1+ i0) (1+ i1)))
                ((>= i1 numcols)) 
              (psetf
               (aref contents i0 i1) (funcall op (aref contents i1 i0))
               (aref contents i1 i0) (funcall op (aref contents i0 i1))))))
        (error "Rows and columns unequal."))))

\nwendcode{}\nwbegindocs{424}\nwdocspar

\subsection{Dense Matrix Scale}
\label{sec:dense-matrix-scale}

Scale the elements of the {\Tt{}dense-matrix\nwendquote} by the scalar argument. A
new vector is returned using the {\Tt{}scale\nwendquote} function.
\nwenddocs{}\nwbegincode{425}\moddef{Method: Dense matrix scale}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod scale ((scalar number) (matrix dense-matrix))
  "Scale each element of the dense matrix."
  (make-instance
   (class-of matrix)
   :contents
   (destructuring-bind (numrows numcols)
       (matrix-dimensions matrix)
     (let ((contents (contents matrix))
           (scaled (make-array (list numrows numcols)
                               :element-type
                               (matrix-element-type matrix))))
       (dotimes (i0 numrows scaled)
         (dotimes (i1 numcols)
           (setf (aref scaled i0 i1)
                 (* scalar (aref contents i0 i1)))))))))

\nwendcode{}\nwbegindocs{426}The dense matrix is destructively modified with {\Tt{}nscale\nwendquote}.
\nwenddocs{}\nwbegincode{427}\moddef{Method: Dense matrix scale}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod nscale ((scalar number) (matrix dense-matrix))
  "Scale each element of the dense matrix."
  (destructuring-bind (numrows numcols)
      (matrix-dimensions matrix)
    (let ((contents (contents matrix)))
      (dotimes (i0 numrows matrix)
        (dotimes (i1 numcols)
          (setf (aref contents i0 i1)
                (* scalar (aref contents i0 i1))))))))

\nwendcode{}\nwbegindocs{428}\nwdocspar

\subsection{Dense Matrix Addition}
\label{sec:dense-matrix-addition}

{\Tt{}add\nwendquote} returns a new matrix with the sum of {\Tt{}matrix1\nwendquote} and {\Tt{}matrix2\nwendquote}.
\nwenddocs{}\nwbegincode{429}\moddef{Method: Dense matrix addition}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup

\nwendcode{}\nwbegindocs{430}\nwdocspar

\subsection{Dense Matrix Product}
\label{sec:dense-matrix-product}

The fundamental operation {\Tt{}product\nwendquote} is specialized on
{\Tt{}dense-matrix\nwendquote} for 2 matrix-vector operations and 1 matrix-matrix
operation. The first matrix-vector operation is the product of a dense
matrix pre-multiplied by a row vector.
\nwenddocs{}\nwbegincode{431}\moddef{Method: Row vector - dense matrix product}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod product :before ((vector row-vector) (matrix dense-matrix)
                            &key scalar)
  "Verify the inputs."
  (declare (ignore scalar))
  (unless (= (vector-length vector) (matrix-row-dimension matrix))
    (error "Row vector(~D) is incompatible with matrix~A."
           (vector-length vector) (matrix-dimensions matrix))))

(defmethod product ((vector row-vector) (matrix dense-matrix)
                    &key scalar)
  "Return a row vector generated by the pre-multiplication of a dense
matrix by a row vector."
  (destructuring-bind (numrows numcols) (matrix-dimensions matrix)
    (let ((vec (contents vector))
          (mat (contents matrix))
          (zero (coerce 0 (vector-element-type vector)))
          (val  nil)
          (newvec (make-array
                   numcols
                   :element-type
                   (vector-element-type vector))))
      (make-instance
       'row-vector
       :contents
       (dotimes (i1 numcols newvec)
         (setf val zero)
         (dotimes (i0 numrows)
           (incf val (* (aref vec i0) (aref mat i0 i1))))
         (if scalar
             (setf (aref newvec i1) (* scalar val))
             (setf (aref newvec i1) val)))))))

\nwendcode{}\nwbegindocs{432}The second matrix-vector operation is the product of a dense matrix
with a column vector.
\nwenddocs{}\nwbegincode{433}\moddef{Method: Dense matrix - column vector product}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod product :before ((matrix dense-matrix) (vector column-vector)
                            &key scalar)
  "Verify the input."
  (declare (ignore scalar))
  (unless (= (vector-length vector) (matrix-column-dimension matrix))
    (error "Column vector(~D) is incompatible with matrix~A."
           (vector-length vector) (matrix-dimensions matrix))))

(defmethod product ((matrix dense-matrix) (vector column-vector)
                    &key scalar)
  "Return a column vector generated by the multiplication of the dense
matrix with a column vector."
  (destructuring-bind (numrows numcols) (matrix-dimensions matrix)
    (let ((vec (contents vector))
          (mat (contents matrix))
          (zero (coerce 0 (vector-element-type vector)))
          (val nil)
          (newvec (make-array
                   numrows
                   :element-type
                   (vector-element-type vector))))
      (make-instance
       'column-vector
       :contents
       (dotimes (i0 numrows newvec)
         (setf val zero)
         (dotimes (i1 numcols)
           (incf val (* (aref mat i0 i1) (aref vec i1))))
         (if scalar
             (setf (aref newvec i0) (* scalar val))
             (setf (aref newvec i0) val)))))))

\nwendcode{}\nwbegindocs{434}The single matrix-matrix operation is the matrix product of 2 dense
matrices.
\nwenddocs{}\nwbegincode{435}\moddef{Method: Dense matrix - matrix product}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod product :before ((matrix1 dense-matrix) (matrix2 dense-matrix)
                            &key scalar)
  "Verify the input."
  (declare (ignore scalar))
  (unless (= (matrix-column-dimension matrix1) (matrix-row-dimension matrix2))
    (error "The matrix dimensions, ~A and ~A, are not compatible."
           (matrix-dimensions matrix1) (matrix-dimensions matrix2))))

(defmethod product ((matrix1 dense-matrix) (matrix2 dense-matrix)
                    &key scalar)
  "Return the product of the dense matrices."
  (destructuring-bind (numrow1 numcol1) (matrix-dimensions matrix1)
    (let* ((mat1 (contents matrix1))
           (mat2 (contents matrix2))
           (zero (coerce 0 (matrix-element-type matrix1)))
           (val nil)
           (numcol2 (matrix-column-dimension matrix2))
           (newmat (make-array (list numrow1 numcol2)
                               :element-type
                               (matrix-element-type matrix1))))
      (make-instance
       (common-class-of matrix1 matrix2 'dense-matrix)
       :contents
       (dotimes (i0 numrow1 newmat)
         (dotimes (i2 numcol2)
           (setf val zero)
           (dotimes (i1 numcol1)
             (incf val (* (aref mat1 i0 i1) (aref mat2 i1 i2))))
           (if scalar
               (setf (aref newmat i0 i2) (* scalar val))
               (setf (aref newmat i0 i2) val))))))))

\nwendcode{}\nwbegindocs{436}\nwdocspar

\chapter{Square Matrices}
\label{chap:square-matrices}

A square matrix is defined as a matrix with the number of columns
equal to the number of rows. It is implemented as a subclass of the
dense matrix.
\nwenddocs{}\nwbegincode{437}\moddef{square-matrix.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Class: Square matrix\RA{}
\LA{}Square matrix interface operations\RA{}
\nwendcode{}\nwbegindocs{438}A square matrix deponds on the linear algebra package, fundamental
operations, the matrix interface and the dense matrix.
\nwenddocs{}\nwbegincode{439}\moddef{Square matrix dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "square-matrix"
       :depends-on ("defpackage"
                    "fundamental-ops"
                    "matrix"
                    "dense-matrix"))
\nwendcode{}\nwbegindocs{440}The square matrix is a direct subclass of {\Tt{}dense-matrix\nwendquote} with no
modifications to the slots.
\nwenddocs{}\nwbegincode{441}\moddef{Class: Square matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass square-matrix (dense-matrix)
  ()
  (:documentation
   "Square matrix object."))

\nwendcode{}\nwbegindocs{442}{\Tt{}square-matrix\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{443}\moddef{Square matrix exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:square-matrix
\nwendcode{}\nwbegindocs{444}\nwdocspar

\section{Square Matrix Interface Operations}
\label{sec:square-matrix-interface-operations}

The square matrix differs from the dense matrix only by the
requirement that the number of rows and columns are equal.
Consequently, only a total of 3 functions and methods are required.
\nwenddocs{}\nwbegincode{445}\moddef{Square matrix interface operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Square matrix interface operations
\LA{}Function: Square matrix predicate\RA{}
\LA{}Before method: Verify that the input data is square\RA{}
\LA{}Method: Subset of a square matrix\RA{}
\nwendcode{}\nwbegindocs{446}\nwdocspar

\subsection{Initializing Square Matrices}
\label{sec:initializing-square-matrices}

All initialization methods applicable to a dense matrix are
applicable to a square matrix. The only additional constraint on the
square matrix is that the number of rows is equal to the number of
columns. This test is independent of the data type and implemented in
a before method.
\nwenddocs{}\nwbegincode{447}\moddef{Before method: Verify that the input data is square}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix :before ((matrix square-matrix) data
                                      (rows integer) (columns integer)
                                      &optional element-type)
  "Verify that the number of rows and colums are equal."
  (declare (ignore matrix data element-type))
  (unless (= rows columns)
    (error "Number of rows must equal the number of columns.")))

\nwendcode{}\nwbegindocs{448}{\Tt{}initialize-matrix\nwendquote} was exported with the definition of the
generic function.

\subsection{Square Matrix Predicates}
\label{sec:square-matrix-predicates}

The function {\Tt{}square-matrix-p\nwendquote} returns true if the object is a
matrix and false otherwise. The {\Tt{}matrix-in-bounds-p\nwendquote} predicate
specialized for dense matrices is applicable to square matrices, so
there is no version specialized on the square matrix class.
\nwenddocs{}\nwbegincode{449}\moddef{Function: Square matrix predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun square-matrix-p (object)
  "Return true if OBJECT is a square matrix."
  (typep object 'square-matrix))

\nwendcode{}\nwbegindocs{450}{\Tt{}square-matrix-p\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{451}\moddef{Square matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:square-matrix-p
\nwendcode{}\nwbegindocs{452}\nwdocspar

\subsection{Inspecting Square Matrices}
\label{sec:inspecting-square-matrices}

All of the functions for inspecting matrices, {\Tt{}matrix-element-type\nwendquote},
{\Tt{}matrix-dimensions\nwendquote}, {\Tt{}matrix-row-dimension\nwendquote} and
{\Tt{}matrix-column-dimension\nwendquote} are applicable to square matrices.
Therefore, none of the matrix inspection functions are specialized for
the square matrix class.

\subsection{Referencing Square Matrices}
\label{sec:referencing-square-matrices}

The matrix reference function, {\Tt{}mref\nwendquote}, specialized for the dense
matrix is applicable to the square matrix. A square matrix is settable
and the {\Tt{}(setf\ mref)\nwendquote} function specialized for the dense matrix is
also applicable. Therefore, {\Tt{}mref\nwendquote} is not specialized for a square
matrix.

\subsection{Copying Square Matrices}
\label{sec:copying-square-matrices}

The {\Tt{}copy-matrix\nwendquote} method specialized for the dense matrix is
applicable to a square matrix.

\subsection{Manipulating Subsets of Square Matrices}
\label{sec:square-matrix-subsets}

The {\Tt{}submatrix\nwendquote} function specialized on the square matrix returns a
square matrix if the number of rows of the subset equals the number of
columns. Otherwise it returns a dense matrix.
\nwenddocs{}\nwbegincode{453}\moddef{Method: Subset of a square matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod submatrix ((matrix square-matrix)
                      (row integer) (column integer)
                      &key row-end column-end)
  "Return a matrix created from the submatrix of matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let* ((numrows (- row-end row))
           (numcols (- column-end column))
           (original (contents matrix))
           (contents (make-array (list numrows numcols)
                                 :element-type
                                 (matrix-element-type matrix))))
      (make-instance
       (if (= numrows numcols) 'square-matrix 'dense-matrix)
       :contents
       (dotimes (i0 numrows contents)
         (dotimes (i1 numcols)
           (setf (aref contents i0 i1)
                 (aref original (+ row i0) (+ column i1)))))))))

\nwendcode{}\nwbegindocs{454}The submatrix of a square matrix is settable regardless of the data
matrix type. Therefore, both the {\Tt{}(setf\ submatrix)\nwendquote} and
{\Tt{}replace-matrix\nwendquote} functions specialized on the dense matrix are
applicable to the square matrix. {\Tt{}submatrix\nwendquote} and {\Tt{}replace-matrix\nwendquote}
were exported with the definitions of the generic functions.

\chapter{Hermitian Matrices}
\label{chap:hermitian-matrices}

A Hermitian matrix is a square matrix with complex elements off the
diagonal and real elements on the diagonal. The transpose of the
matrix is equal to the conjugate of the matrix elements.
\nwenddocs{}\nwbegincode{455}\moddef{hermitian-matrix.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Class: Hermitian matrix\RA{}
\LA{}Hermitian matrix interface operations\RA{}
\nwendcode{}\nwbegindocs{456}The hermitian matrix depends on the linear algebra package,
auxiliary functions, fundamental operations, the matrix interface and
the square matrix.
\nwenddocs{}\nwbegincode{457}\moddef{Hermitian matrix dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "hermitian-matrix"
       :depends-on ("defpackage"
                    "auxiliary"
                    "fundamental-ops"
                    "matrix"
                    "square-matrix"))
\nwendcode{}\nwbegindocs{458}The symmetric matrix is a direct subclass of {\Tt{}square-matrix\nwendquote} with
no modifications to the slots.
\nwenddocs{}\nwbegincode{459}\moddef{Class: Hermitian matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass hermitian-matrix (square-matrix)
  ()
  (:documentation
   "Hermitian matrix object."))

\nwendcode{}\nwbegindocs{460}{\Tt{}hermitian-matrix\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{461}\moddef{Hermitian matrix exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:hermitian-matrix
\nwendcode{}\nwbegindocs{462}\nwdocspar

\note{The Hermitian matrix object is not completely validated and
  needs more review.}

\section{Hermitian Matrix Interface Operations}
\label{sec:hermitian-matrix-interface-operations}

The matrix interface operations for Hermitian matrices are implemented
in this section. All operations are specialized on the
{\Tt{}hermitian-matrix\nwendquote} object.
\nwenddocs{}\nwbegincode{463}\moddef{Hermitian matrix interface operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Hermitian matrix interface operations
\LA{}Function: Hermitian matrix predicate\RA{}
\LA{}Function: Verify that the nested sequence is Hermitian\RA{}
\LA{}Method: Initialize the Hermitian matrix with a complex is an error\RA{}
\LA{}Method: Initialize the Hermitian matrix with a nested sequence\RA{}
\LA{}Method: Initialize the Hermitian matrix with a 2D array\RA{}
\LA{}Method: Hermitian matrix element reference\RA{}
\LA{}Function: Subset of a Hermitian matrix\RA{}
\LA{}Method: Subset of a Hermitian matrix\RA{}
\LA{}Function: Destructively replace a subset of a Hermitian matrix\RA{}
\LA{}Method: Destructively replace a subset of a Hermitian matrix\RA{}
\nwendcode{}\nwbegindocs{464}\nwdocspar

\subsection{Initializing Hermitian Matrices}
\label{sec:initializing-hermitian-matrices}

When initializing a Hermitian matrix, the data is verified to be
Hermitian while the contents of the matrix are being populated. It is
an error to initialize a Hermitian matrix with a complex value.
\nwenddocs{}\nwbegincode{465}\moddef{Method: Initialize the Hermitian matrix with a complex is an error}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix hermitian-matrix) (data complex)
                              (rows integer) (columns integer)
                              &optional (element-type 'complex))
  "It is an error to initialize a Hermitian matrix with a complex
element."
  (declare (ignore data rows columns element-type))
  (error "The initial element for a ~A must be real." (type-of matrix)))

\nwendcode{}\nwbegindocs{466}The contents of a Hermitian matrix initialized with a nested
sequence are verified to be Hermitian using an internal function.
\nwenddocs{}\nwbegincode{467}\moddef{Function: Verify that the nested sequence is Hermitian}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %initialize-hermitian-matrix-with-seq (matrix data
                                              rows columns
                                              element-type)
  "Initialize and validate a Hermitian matrix with a sequence."
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type
                                    :initial-contents data))))
    (dotimes (i0 rows matrix)
      (if (zerop (imagpart (aref contents i0 i0)))
          (dotimes (i1 i0)
            (unless (complex-equal
                     (aref contents i0 i1)
                     (conjugate
                      (aref contents i1 i0)))
              (error "The data is not Hermitian.")))
          (error "The data is not Hermitian.")))))

\nwendcode{}\nwbegindocs{468}Two methods are required to process nested sequences, the first
specialized for lists as the first rank data structure.
\nwenddocs{}\nwbegincode{469}\moddef{Method: Initialize the Hermitian matrix with a nested sequence}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix hermitian-matrix) (data list)
                              (rows integer) (columns integer)
                              &optional (element-type 'complex))
  "Initialize the Hermitian matrix with a nested sequence."
  (%initialize-hermitian-matrix-with-seq matrix data
                                         rows columns
                                         element-type))

\nwendcode{}\nwbegindocs{470}The second method for nested sequences is specialized on vectors as
the first rank data structures.
\nwenddocs{}\nwbegincode{471}\moddef{Method: Initialize the Hermitian matrix with a nested sequence}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix hermitian-matrix) (data vector)
                              (rows integer) (columns integer)
                              &optional (element-type 'complex))
  "Initialize the Hermitian matrix with a nested sequence."
  (%initialize-hermitian-matrix-with-seq matrix data
                                         rows columns
                                         element-type))

\nwendcode{}\nwbegindocs{472}The final Hermitian matrix initialization method is specialized for
2D arrays.
\nwenddocs{}\nwbegincode{473}\moddef{Method: Initialize the Hermitian matrix with a 2D array}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix hermitian-matrix) (data array)
                              (rows integer) (columns integer)
                              &optional (element-type 'complex))
  "Initialize the Hermitian matrix with a 2D array."
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type))))
    (dotimes (i0 rows matrix)
      (if (zerop
           (imagpart
            (setf (aref contents i0 i0) (aref data i0 i0))))
          (dotimes (i1 i0)
            (unless (complex-equal
                     (setf (aref contents i0 i1)
                           (aref data i0 i1))
                     (conjugate
                      (setf (aref contents i1 i0)
                            (aref data i1 i0))))
              (error "The data is not Hermitian.")))
          (error "The data is not Hermitian.")))))

\nwendcode{}\nwbegindocs{474}{\Tt{}initialize-matrix\nwendquote} was exported with the definition of the generic
function.

\subsection{Hermitian Matrix Predicates}
\label{sec:hermitian-matrix-predicates}

The function {\Tt{}hermitian-matrix-p\nwendquote} returns true if the object is a
hermitian matrix and false otherwise.
\nwenddocs{}\nwbegincode{475}\moddef{Function: Hermitian matrix predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun hermitian-matrix-p (object)
  "Return true if object is a hermitian-matrix, NIL otherwise."
  (typep object 'hermitian-matrix))

\nwendcode{}\nwbegindocs{476}{\Tt{}hermitian-matrix-p\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{477}\moddef{Hermitian matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:hermitian-matrix-p
\nwendcode{}\nwbegindocs{478}\nwdocspar

\subsection{Inspecting Hermitian Matrices}
\label{sec:inspecting-hermitian-matrices}

All of the functions for inspecting matrices, {\Tt{}matrix-element-type\nwendquote},
{\Tt{}matrix-dimensions\nwendquote}, {\Tt{}matrix-row-dimension\nwendquote} and
{\Tt{}matrix-column-dimension\nwendquote} are applicable to Hermitian matrices.
Therefore, none of the matrix inspection functions are specialized for
the Hermitian matrix class.

\subsection{Referencing Hermitian Matrices}
\label{sec:referencing-hermitian-matrices}

The matrix reference function, {\Tt{}mref\nwendquote}, specialized for the dense
matrix is applicable to the hermitian matrix. A Hermitian matrix is
settable with the constraint that the transpose element must also be
set. Therefore, {\Tt{}(setf\ mref)\nwendquote} is specialized for a Hermitian matrix.
\nwenddocs{}\nwbegincode{479}\moddef{Method: Hermitian matrix element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf mref) ((data number) (matrix hermitian-matrix)
                        (row integer) (column integer))
  "Set the element at row,column of matrix to data."
  (if (= row column)
      (unless (zerop
               (imagpart
                (setf (aref (contents matrix) row column) data)))
        (error "Diagonal Hermitian matrix elements must have a zero ~
                imaginary component."))
      (setf (aref (contents matrix) row column) data
            (aref (contents matrix) column row) (conjugate data))))

\nwendcode{}\nwbegindocs{480}{\Tt{}mref\nwendquote} was exported with the definition of the generic function.

\subsection{Copying Hermitian Matrices}
\label{sec:copying-hermitian-matrices}

The {\Tt{}copy-matrix\nwendquote} function specialized on {\Tt{}square-matrix\nwendquote} applies
to Hermitian matrices as well. Therefore, {\Tt{}copy-matrix\nwendquote} is not
specialized for the symmetric matrix class.

\subsection{Manipulating Subsets of Hermitian Matrices}
\label{sec:hermitian-matrix-subsets}

As with the symmetric matrix, the {\Tt{}submatrix\nwendquote} function specialized
on the Hermitian matrix returns one of a Hermitian matrix, a square
matrix or a dense matrix depending on the specified range. If the
start row equals the start column and the end row equals the end
column, a Hermitian matrix is returned. If the number of rows equals
the number of columns, but the start and end rows do not equal the
start and end columns, respectively, a square matrix is returned.
Otherwise, a dense matrix is returned.
\nwenddocs{}\nwbegincode{481}\moddef{Method: Subset of a Hermitian matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod submatrix ((matrix hermitian-matrix)
                      (row integer) (column integer)
                      &key row-end column-end)
  "Return a matrix created from the submatrix of matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let* ((numrows (- row-end row))
           (numcols (- column-end column))
           (original (contents matrix))
           (contents (make-array (list numrows numcols)
                                 :element-type
                                 (matrix-element-type matrix))))
      (make-instance
       (cond ((and (= row column) (= numrows numcols))
              'hermitian-matrix)
             ((= numrows numcols)
              'square-matrix)
             (t 'dense-matrix))
       :contents
       (dotimes (i0 numrows contents)
         (dotimes (i1 numcols)
           (setf (aref contents i0 i1)
                 (aref original (+ row i0) (+ column i1)))))))))

\nwendcode{}\nwbegindocs{482}The submatrix of a Hermitian matrix is settable for only 2
conditions. The first condition requires Hermitian data and the start
and end row to equal the start and end column, respectively.
\nwenddocs{}\nwbegincode{483}\moddef{Function: Subset of a Hermitian matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %setf-hermitian-submatrix-on-diagonal (matrix data row numrows)
  (let ((mat (contents matrix))
        (dat (contents data)))
    (do ((di0 0   (1+ di0))
         (mi0 row (1+ mi0)))
        ((>= di0 numrows) data)         ; Return the data
      (setf (aref mat mi0 mi0) (aref dat di0 di0))
      (do ((di1 (1+ di0)      (1+ di1))
           (mi1 (+ 1 row di0) (1+ mi1)))
          ((>= di1 numrows))
        (setf (aref mat mi0 mi1) (aref dat di0 di1)
              (aref mat mi1 mi0) (aref dat di1 di0))))))

\nwendcode{}\nwbegindocs{484}The second condition is when the subset does not intersect the
diagonal. This is equivalent to saying the start column is less than
the end row or that the end column is less than the start row. In
addition, the data must be complex.
\nwenddocs{}\nwbegincode{485}\moddef{Function: Subset of a Hermitian matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %setf-hermitian-submatrix-off-diagonal (matrix data
                                               row column
                                               numrows numcols)
  (let ((mat (contents matrix))
        (dat (contents data)))
    (do ((di0 0   (1+ di0))
         (mi0 row (1+ mi0)))
        ((>= di0 numrows) data)         ; Return the data
      (do ((di1 0      (1+ di1))
           (mi1 column (1+ mi1)))
          ((>= di1 numcols))
        (setf (aref mat mi0 mi1) (aref dat di0 di1)
              (aref mat mi1 mi0) (conjugate (aref dat di0 di1)))))))

\nwendcode{}\nwbegindocs{486}When the data is Hermitian, both conditions must be considered.
\nwenddocs{}\nwbegincode{487}\moddef{Method: Subset of a Hermitian matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf submatrix) ((data hermitian-matrix)
                             (matrix hermitian-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set a submatrix of the matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data))))
      (cond
        ((and (= row column) (= numrows numcols))
         (%setf-hermitian-submatrix-on-diagonal matrix data
                                                row numrows))
        ((or (< (+ row numrows -1) column)
             (< (+ column numcols -1) row))
         (%setf-hermitian-submatrix-off-diagonal matrix data
                                                 row column
                                                 numrows numcols))
        (t
         (error "Range(~D:~D,~D:~D) results in a non-Hermitian matrix."
                row row-end column column-end))))))

\nwendcode{}\nwbegindocs{488}When the data is any other type of matrix and the elements are
complex, only the second condition needs to be considered. The subset
is set if it does not intersect the diagonal.
\nwenddocs{}\nwbegincode{489}\moddef{Method: Subset of a Hermitian matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf submatrix) ((data dense-matrix)
                             (matrix hermitian-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set a submatrix of the matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data))))
      (if (or (< (+ row numrows -1) column)
              (< (+ column numcols -1) row))
          (%setf-hermitian-submatrix-off-diagonal matrix data
                                                  row column
                                                  numrows numcols)
          (error "Range(~D:~D,~D:~D) results in a non-Hermitian matrix."
                 row row-end column column-end)))))

\nwendcode{}\nwbegindocs{490}Destructively replacing the subset of a Hermitian matrix is subject
to one of 2 conditions. The first condition is that the start and end
row of each matrix equals the start and end column, respectively.
\nwenddocs{}\nwbegincode{491}\moddef{Function: Destructively replace a subset of a Hermitian matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %replace-hermitian-matrix-on-diagonal (matrix1 matrix2
                                              row1 column1
                                              row2 column2
                                              numrows numcols)
  "Destructively replace a subset on the diagonal of matrix1 with
matrix2."
  (let ((contents1 (contents matrix1))
        (contents2 (contents matrix2)))
    (do ((   i0 0    (1+ i0))
         (m1-i0 row1 (1+ m1-i0))
         (m2-i0 row2 (1+ m2-i0)))
        ((>= i0 numrows) matrix1)       ; Return matrix1
      (setf (aref contents1 m1-i0 m1-i0) (aref contents2 m2-i0 m2-i0))
      (do ((   i1 (1+ i0)          (1+ i1))
           (m1-i1 (+ 1 column1 i0) (1+ m1-i1))
           (m2-i1 (+ 1 column2 i0) (1+ m2-i1)))
          ((>= i1 numcols))
        (setf (aref contents1 m1-i0 m1-i1) (aref contents2 m2-i0 m2-i1)
              (aref contents1 m1-i1 m1-i0) (aref contents2 m2-i1 m2-i0))))))

\nwendcode{}\nwbegindocs{492}The other condition is that the subset does not intersect the
diagonal.
\nwenddocs{}\nwbegincode{493}\moddef{Function: Destructively replace a subset of a Hermitian matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %replace-hermitian-matrix-off-diagonal (matrix1 matrix2
                                               row1 column1
                                               row2 column2
                                               numrows numcols)
  "Destructively replace a subset off the diagonal of matrix1 with
matrix2."
  (let ((contents1 (contents matrix1))
        (contents2 (contents matrix2)))
    (do ((   i0 0    (1+ i0))
         (m1-i0 row1 (1+ m1-i0))
         (m2-i0 row2 (1+ m2-i0)))
        ((>= i0 numrows) matrix1)       ; Return matrix1
      (do ((   i1 0       (1+ i1))
           (m1-i1 column1 (1+ m1-i1))
           (m2-i1 column2 (1+ m2-i1)))
          ((>= i1 numcols))
        (setf (aref contents1 m1-i0 m1-i1) (aref contents2 m2-i0 m2-i1)
              (aref contents1 m1-i1 m1-i0) (conjugate
                                            (aref contents2 m2-i0 m2-i1)))))))

\nwendcode{}\nwbegindocs{494}Similarly, when both matrices are Hermitian, both conditions must be
considered.
\nwenddocs{}\nwbegincode{495}\moddef{Method: Destructively replace a subset of a Hermitian matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod replace-matrix ((matrix1 hermitian-matrix) (matrix2 hermitian-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of matrix1 with matrix2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2))))
        (cond
          ((and (= row1 column1) (= row2 column2) (= numrows numcols))
           (%replace-hermitian-matrix-on-diagonal matrix1 matrix2
                                                  row1 column1
                                                  row2 column2
                                                  numrows numcols))
          ((or (< (+ row1 numrows -1) column1)
               (< (+ column1 numcols -1) row1))
           (%replace-hermitian-matrix-off-diagonal matrix1 matrix2
                                                   row1 column1
                                                   row2 column2
                                                   numrows numcols))
          (t
           (error "Range(~D:~D,~D:~D) results in a non-Hermitian matrix."
                  row1 (+ row1 numrows -1) column1 (+ column1 numcols -1))))))))

\nwendcode{}\nwbegindocs{496}When the only the matrix that is being destructively modified is
Hermitian only the second condition must be considered.
\nwenddocs{}\nwbegincode{497}\moddef{Method: Destructively replace a subset of a Hermitian matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod replace-matrix ((matrix1 hermitian-matrix) (matrix2 dense-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of matrix1 with matrix2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2))))
        (if (or (< (+ row1 numrows -1) column1) (< (+ column1 numcols -1) row1))
            (%replace-hermitian-matrix-off-diagonal matrix1 matrix2
                                                    row1 column1
                                                    row2 column2
                                                    numrows numcols)
            (error "Range(~D:~D,~D:~D) results in a non-Hermitian matrix."
                   row1 (+ row1 numrows -1) column1 (+ column1 numcols -1)))))))

\nwendcode{}\nwbegindocs{498}{\Tt{}submatrix\nwendquote} and {\Tt{}replace-matrix\nwendquote} were exported with the
definitions of the generic functions.

\note{The situation where the data replacing the subset of a Hermitian
  matrix intersects the diagonal but still results in a Hermitian
  matrix is not considered. It should be added.}

\chapter{Symmetric Matrices}
\label{chap:symmetric-matrices}

A symmetric matrix is a square matrix where the transpose of the
matrix is equal to the original matrix. It is implemented as
specialization of the Hermitian matrix.
\nwenddocs{}\nwbegincode{499}\moddef{symmetric-matrix.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Class: Symmetric matrix\RA{}
\LA{}Symmetric matrix interface operations\RA{}
\nwendcode{}\nwbegindocs{500}The symmetric matrix depends on the linear algebra package,
auxiliary functions, fundamental operations, the matrix interface and
the square matrix.
\nwenddocs{}\nwbegincode{501}\moddef{Symmetric matrix dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "symmetric-matrix"
       :depends-on ("defpackage"
                    "auxiliary"
                    "fundamental-ops"
                    "matrix"
                    "square-matrix"))
\nwendcode{}\nwbegindocs{502}The symmetric matrix is a direct subclass of {\Tt{}hermitian-matrix\nwendquote}
with no modifications to the slots.
\nwenddocs{}\nwbegincode{503}\moddef{Class: Symmetric matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass symmetric-matrix (hermitian-matrix)
  ()
  (:documentation
   "Symmetric matrix object."))

\nwendcode{}\nwbegindocs{504}{\Tt{}symmetric-matrix\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{505}\moddef{Symmetric matrix exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:symmetric-matrix
\nwendcode{}\nwbegindocs{506}\nwdocspar

\section{Symmetric Matrix Interface Operations}
\label{sec:symmetric-matrix-interface-operations}

The matrix interface operations for symmetric matrices are implemented
in this section. All operations are specialized on the
{\Tt{}symmetric-matrix\nwendquote} object.
\nwenddocs{}\nwbegincode{507}\moddef{Symmetric matrix interface operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Symmetric matrix interface opterations
\LA{}Function: Symmetric matrix predicate\RA{}
\LA{}Function: Verify that the nested sequence is symmetric\RA{}
\LA{}Method: Initialize a symmetric matrix with a nested sequence\RA{}
\LA{}Method: Initialize a symmetric matrix with a 2D array\RA{}
\LA{}Method: Symmetric matrix element reference\RA{}
\LA{}Function: Subset of a symmetric matrix\RA{}
\LA{}Method: Subset of a symmetric matrix\RA{}
\LA{}Function: Destructively replace a subset of a symmetric matrix\RA{}
\LA{}Method: Destructively replace a subset of a symmetric matrix\RA{}
\nwendcode{}\nwbegindocs{508}\nwdocspar

\note{The symmetric matrix is generally considered only for real
  elements. Whether or not this should be enforced needs to be
  reviewed.}

\subsection{Initializing Symmetric Matrices}
\label{sec:initializing-symmetric-matrices}

When initializing a symmetric matrix with a sequence, the data is
verified to be symmetric. This is performed with an internal function.
\nwenddocs{}\nwbegincode{509}\moddef{Function: Verify that the nested sequence is symmetric}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %initialize-symmetric-matrix-with-seq (matrix data
                                              rows columns
                                              element-type)
  "Initialize and validate a symmetric matrix with a sequence."
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type
                                    :initial-contents data))))
    (dotimes (i0 rows matrix)
      (dotimes (i1 i0)
        (unless (number-equal
                 (aref contents i0 i1)
                 (aref contents i1 i0))
          (error "The data is not symmetric."))))))

\nwendcode{}\nwbegindocs{510}Two methods are required to process nested sequences. Each wraps the
internal function to verify symmetry. The first is specialized for
lists as the first rank data structure.
\nwenddocs{}\nwbegincode{511}\moddef{Method: Initialize a symmetric matrix with a nested sequence}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix symmetric-matrix) (data list)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize a symmetric matrix."
  (%initialize-symmetric-matrix-with-seq matrix data
                                         rows columns
                                         element-type))

\nwendcode{}\nwbegindocs{512}The second method for nested sequences is specialized on vectors as
the first rank data structure.
\nwenddocs{}\nwbegincode{513}\moddef{Method: Initialize a symmetric matrix with a nested sequence}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix symmetric-matrix) (data vector)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize a symmetric matrix."
  (%initialize-symmetric-matrix-with-seq matrix data
                                         rows columns
                                         element-type))

\nwendcode{}\nwbegindocs{514}The final symmetric matrix initialization method is specialized for
arrays.
\nwenddocs{}\nwbegincode{515}\moddef{Method: Initialize a symmetric matrix with a 2D array}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix symmetric-matrix) (data array)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize a symmetric matrix."
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type))))
    (dotimes (i0 rows matrix)
      (setf (aref contents i0 i0) (aref data i0 i0))
      (dotimes (i1 i0)
        (unless (number-equal
                 (setf (aref contents i0 i1)
                       (aref data i0 i1))
                 (setf (aref contents i1 i0)
                       (aref data i1 i0)))
          (error "The data is not symmetric."))))))

\nwendcode{}\nwbegindocs{516}{\Tt{}initialize-matrix\nwendquote} was exported with the definition of the
generic function.

\subsection{Symmetric Matrix Predicates}
\label{sec:symmetric-matrix-predicates}

The function {\Tt{}symmetric-matrix-p\nwendquote} returns true if the object is a
symmetric matrix and false otherwise.
\nwenddocs{}\nwbegincode{517}\moddef{Function: Symmetric matrix predicate}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun symmetric-matrix-p (object)
  "Return true if object is a symmetric-matrix, NIL otherwise."
  (typep object 'symmetric-matrix))

\nwendcode{}\nwbegindocs{518}{\Tt{}symmetric-matrix-p\nwendquote} is an exported symbol.
\nwenddocs{}\nwbegincode{519}\moddef{Symmetric matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:symmetric-matrix-p
\nwendcode{}\nwbegindocs{520}\nwdocspar

\subsection{Inspecting Symmetric Matrices}
\label{sec:inspecting-symmetric-matrices}

All of the functions for inspecting matrices, {\Tt{}matrix-element-type\nwendquote},
{\Tt{}matrix-dimensions\nwendquote}, {\Tt{}matrix-row-dimension\nwendquote} and
{\Tt{}matrix-column-dimension\nwendquote} are applicable to symmetric matrices.
Therefore, none of the matrix inspection functions are specialized for
the symmetric matrix class.

\subsection{Referencing Symmetric Matrices}
\label{sec:referencing-symmetric-matrices}

The matrix reference function, {\Tt{}mref\nwendquote}, specialized for the dense
matrix is applicable to the symmetric matrix. A symmetric matrix is
settable with the constraint that the transpose element must also be
set. Therefore, {\Tt{}(setf\ mref)\nwendquote} is specialized for a symmetric matrix.
\nwenddocs{}\nwbegincode{521}\moddef{Method: Symmetric matrix element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf mref) ((data number) (matrix symmetric-matrix)
                        (row integer) (column integer))
  "Set the element of matrix at row,column."
  (setf (aref (contents matrix) row column) data
        (aref (contents matrix) column row) data))

\nwendcode{}\nwbegindocs{522}{\Tt{}mref\nwendquote} was exported with the definition of the generic function.

\subsection{Copying Symmetric Matrices}
\label{sec:copying-symmetric-matrices}

The {\Tt{}copy-matrix\nwendquote} function specialized on {\Tt{}square-matrix\nwendquote} applies
to symmetric matrices as well. Therefore, {\Tt{}copy-matrix\nwendquote} is not
specialized for the symmetric matrix class.

\subsection{Manipulating Subsets of Symmetric Matrices}
\label{sec:symmetric-matrix-subsets}

The {\Tt{}submatrix\nwendquote} function specialized on the symmetric matrix returns
either a symmetric matrix, a square matrix or a dense matrix
depending on the specified range. If the start row equals the start
column and the end row equals the end column, a symmetric matrix is
returned. If the number of rows equals the number of columns, but the
start and end rows do not equal the start and end columns,
respectively, a square matrix is returned. Otherwise, a dense matrix
is returned.
\nwenddocs{}\nwbegincode{523}\moddef{Method: Subset of a symmetric matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod submatrix ((matrix symmetric-matrix)
                      (row integer) (column integer)
                      &key row-end column-end)
  "Return a matrix created from the submatrix of matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let* ((numrows (- row-end row))
           (numcols (- column-end column))
           (original (contents matrix))
           (contents (make-array (list numrows numcols)
                                 :element-type
                                 (matrix-element-type matrix))))
      (make-instance
       (cond ((and (= row column) (= numrows numcols))
              'symmetric-matrix)
             ((= numrows numcols)
              'square-matrix)
             (t 'dense-matrix))
       :contents
       (dotimes (i0 numrows contents)
         (dotimes (i1 numcols)
           (setf (aref contents i0 i1)
                 (aref original (+ row i0) (+ column i1)))))))))

\nwendcode{}\nwbegindocs{524}The submatrix of a symmetric matrix is settable for only 2
conditions. The first condition is the start and end row equals the
start and end column, respectively.
\nwenddocs{}\nwbegincode{525}\moddef{Function: Subset of a symmetric matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %setf-symmetric-submatrix-on-diagonal (matrix data row numrows)
  (let ((mat (contents matrix))
        (dat (contents data)))
    (do ((di0 0   (1+ di0))
         (mi0 row (1+ mi0)))
        ((>= di0 numrows) data)         ; Return the data
      (setf (aref mat mi0 mi0) (aref dat di0 di0))
      (do ((di1 (1+ di0)      (1+ di1))
           (mi1 (+ 1 row di0) (1+ mi1)))
          ((>= di1 numrows))
        (setf (aref mat mi0 mi1) (aref dat di0 di1)
              (aref mat mi1 mi0) (aref dat di1 di0))))))

\nwendcode{}\nwbegindocs{526}The second condition is when the subset does not intersect the
diagonal. This is equivalent to saying the start column is less than
the end row or that the end column is less than the start row.
\nwenddocs{}\nwbegincode{527}\moddef{Function: Subset of a symmetric matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %setf-symmetric-submatrix-off-diagonal (matrix data
                                               row column
                                               numrows numcols)
  (let ((mat (contents matrix))
        (dat (contents data)))
    (do ((di0 0   (1+ di0))
         (mi0 row (1+ mi0)))
        ((>= di0 numrows) data)         ; Return the data
      (do ((di1 0      (1+ di1))
           (mi1 column (1+ mi1)))
          ((>= di1 numcols))
        (setf (aref mat mi0 mi1) (aref dat di0 di1)
              (aref mat mi1 mi0) (aref dat di0 di1))))))

\nwendcode{}\nwbegindocs{528}When the data is symmetric, both conditions must be considered.
\nwenddocs{}\nwbegincode{529}\moddef{Method: Subset of a symmetric matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf submatrix) ((data symmetric-matrix)
                             (matrix symmetric-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set a submatrix of the matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data))))
      (cond
        ((and (= row column) (= numrows numcols))
         (%setf-symmetric-submatrix-on-diagonal matrix data
                                                row numrows))
        ((or (<= (+ row numrows -1) column)
             (<= (+ column numcols -1) row))
         (%setf-symmetric-submatrix-off-diagonal matrix data
                                                 row column
                                                 numrows numcols))
        (t
         (error "Range(~D:~D,~D:~D) results in an asymmetric matrix."
                row row-end column column-end))))))

\nwendcode{}\nwbegindocs{530}When the data is any other type of matrix, only the second condition
needs to be considered.
\nwenddocs{}\nwbegincode{531}\moddef{Method: Subset of a symmetric matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf submatrix) ((data dense-matrix)
                             (matrix symmetric-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set a submatrix of MATRIX."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data))))
      (if (or (<= (+ row numrows -1) column)
              (<= (+ column numcols -1) row))
          (%setf-symmetric-submatrix-off-diagonal matrix data
                                                  row column
                                                  numrows numcols)
          (error "Range(~D:~D,~D:~D) results in an asymmetric matrix."
                 row row-end column column-end)))))

\nwendcode{}\nwbegindocs{532}Destructively replacing the subset of a symmetric matrix is subject
to the same 2 conditions as setting the subset. The first condition is
that the start row and column are equal for both matrices and that the
number of rows equals the number of columns.
\nwenddocs{}\nwbegincode{533}\moddef{Function: Destructively replace a subset of a symmetric matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %replace-symmetric-matrix-on-diagonal (matrix1 matrix2
                                              row1 column1
                                              row2 column2
                                              numrows numcols)
  "Destructively replace a subset on the diagonal of matrix1 with
matrix2."
  (let ((contents1 (contents matrix1))
        (contents2 (contents matrix2)))
    (do ((   i0 0    (1+ i0))
         (m1-i0 row1 (1+ m1-i0))
         (m2-i0 row2 (1+ m2-i0)))
        ((>= i0 numrows) matrix1)       ; Return matrix1
      (setf (aref contents1 m1-i0 m1-i0) (aref contents2 m2-i0 m2-i0))
      (do ((   i1 (1+ i0)             (1+ i1))
           (m1-i1 (+ 1 column1 i0) (1+ m1-i1))
           (m2-i1 (+ 1 column2 i0) (1+ m2-i1)))
          ((>= i1 numcols))
        (setf (aref contents1 m1-i0 m1-i1) (aref contents2 m2-i0 m2-i1)
              (aref contents1 m1-i1 m1-i0) (aref contents2 m2-i1 m2-i0))))))

\nwendcode{}\nwbegindocs{534}The second condition occurs when the subset does not intersect the
diagonal of the first matrix.
\nwenddocs{}\nwbegincode{535}\moddef{Function: Destructively replace a subset of a symmetric matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %replace-symmetric-matrix-off-diagonal (matrix1 matrix2
                                               row1 column1
                                               row2 column2
                                               numrows numcols)
  "Destructively replace a subset off the diagonal of matrix1 with
matrix2."
  (let ((contents1 (contents matrix1))
        (contents2 (contents matrix2)))
    (do ((   i0 0    (1+ i0))
         (m1-i0 row1 (1+ m1-i0))
         (m2-i0 row2 (1+ m2-i0)))
        ((>= i0 numrows) matrix1)       ; Return matrix1
      (do ((   i1 0       (1+ i1))
           (m1-i1 column1 (1+ m1-i1))
           (m2-i1 column2 (1+ m2-i1)))
          ((>= i1 numcols))
        (setf (aref contents1 m1-i0 m1-i1) (aref contents2 m2-i0 m2-i1)
              (aref contents1 m1-i1 m1-i0) (aref contents2 m2-i0 m2-i1))))))

\nwendcode{}\nwbegindocs{536}When both matrices are symmetric, both conditions must be
considered.
\nwenddocs{}\nwbegincode{537}\moddef{Method: Destructively replace a subset of a symmetric matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod replace-matrix ((matrix1 symmetric-matrix) (matrix2 symmetric-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of MATRIX1 with MATRIX2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2))))
        (cond
          ((and (= row1 column1) (= row2 column2) (= numrows numcols))
           (%replace-symmetric-matrix-on-diagonal matrix1 matrix2
                                                  row1 column1
                                                  row2 column2
                                                  numrows numcols))
          ((or (<= (+ row1 numrows -1) column1)
               (<= (+ column1 numcols -1) row1))
           (%replace-symmetric-matrix-off-diagonal matrix1 matrix2
                                                   row1 column1
                                                   row2 column2
                                                   numrows numcols))
          (t
           (error "Range(~D:~D,~D:~D) results in an asymmetric matrix."
                  row1 (+ row1 numrows -1) column1 (+ column1 numcols -1))))))))

\nwendcode{}\nwbegindocs{538}When the only the matrix that is being destructively modified is
symmetric, only the second condition must be considered.
\nwenddocs{}\nwbegincode{539}\moddef{Method: Destructively replace a subset of a symmetric matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod replace-matrix ((matrix1 symmetric-matrix) (matrix2 dense-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of MATRIX1 with MATRIX2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2))))
        (if (or (<= (+ row1 numrows -1) column1)
                (<= (+ column1 numcols -1) row1))
            (%replace-symmetric-matrix-off-diagonal matrix1 matrix2
                                                    row1 column1
                                                    row2 column2
                                                    numrows numcols)
            (error "Range(~D:~D,~D:~D) results in an asymmetric matrix."
                   row1 (+ row1 numrows -1) column1 (+ column1 numcols -1)))))))

\nwendcode{}\nwbegindocs{540}{\Tt{}submatrix\nwendquote} and {\Tt{}replace-matrix\nwendquote} were exported with the
definitions of the generic functions.

\chapter{Triangular Matrices}
\label{chap:triangular-matrices}

A triangular matrix is a square matrix with non-zero elements on only
one side of the diagonal.
\nwenddocs{}\nwbegincode{541}\moddef{triangular-matrix.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Class: Triangular matrices\RA{}
\LA{}Triangular matrix interface operations\RA{}
\nwendcode{}\nwbegindocs{542}The triangular matrix depends on the linear algebra package,
fundamental operations, the matrix interface and the square matrix.
\nwenddocs{}\nwbegincode{543}\moddef{Triangular matrix dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "triangular-matrix"
       :depends-on ("defpackage"
                    "fundamental-ops"
                    "matrix"
                    "square-matrix"))
\nwendcode{}\nwbegindocs{544}Both types of triangular matrices are direct subclasses of
{\Tt{}square-matrix\nwendquote} with no modifications to the slots.
\nwenddocs{}\nwbegincode{545}\moddef{Class: Triangular matrices}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defclass upper-triangular-matrix (square-matrix)
  ()
  (:documentation
   "Upper triangular matrix object."))

(defclass lower-triangular-matrix (square-matrix)
  ()
  (:documentation
   "Lower triangular matrix object."))

\nwendcode{}\nwbegindocs{546}{\Tt{}upper-triangular-matrix\nwendquote} and {\Tt{}lower-triangular-matrix\nwendquote} are
exported symbols.
\nwenddocs{}\nwbegincode{547}\moddef{Triangular matrix exports}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:upper-triangular-matrix :lower-triangular-matrix
\nwendcode{}\nwbegindocs{548}\nwdocspar

\section{Triangular Matrix Interface Operations}
\label{sec:triangular-matrix-interface-operations}

The matrix interface operations for triangular matrices are
implemented in this section. Each operation is implemented separately
for upper and lower triangular objects.
\nwenddocs{}\nwbegincode{549}\moddef{Triangular matrix interface operations}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; Triangular matrix interface operations
\LA{}Function: Triangular matrix predicates\RA{}
\LA{}Function: Verify that the nested sequence is triangular\RA{}
\LA{}Method: Initialize the triangular matrix with a value\RA{}
\LA{}Method: Initialize the triangular matrix with a nested sequence\RA{}
\LA{}Method: Initialize the triangular matrix with a 2D array\RA{}
\LA{}Method: Triangular matrix element reference\RA{}
\LA{}Method: Copy a triangular matrix\RA{}
\LA{}Function: Subset of a triangular matrix\RA{}
\LA{}Method: Subset of a triangular matrix\RA{}
\LA{}Function: Destructively replace a subset of a triangular matrix\RA{}
\LA{}Method: Destructively replace a subset of a triangular matrix\RA{}
\nwendcode{}\nwbegindocs{550}\nwdocspar

\subsection{Initializing Triangular Matrices}
\label{sec:initializing-triangular-matrices}

The contents of a triangular matrix is a second rank array with all
elements equal to zero on the appropriate side of the diagonal. When
initializing a triangular matrix, the data is verified to be zero on
the appropriate side of the diagonal. When an {\Tt{}initial-element\nwendquote} is
supplied to {\Tt{}make-matrix\nwendquote}, it is used to fill all of the elements on
the proper side of the diagonal.
\nwenddocs{}\nwbegincode{551}\moddef{Method: Initialize the triangular matrix with a value}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix upper-triangular-matrix) (data number)
                              (rows fixnum) (columns fixnum)
                              &optional (element-type t))
  "Initialize the upper triangular matrix with an initial element."
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type
                                    :initial-element (coerce 0 element-type)))))
    (dotimes (i1 columns matrix)
      (setf (aref contents i1 i1) data)
      (dotimes (i0 i1)
        (setf (aref contents i0 i1) data)))))

(defmethod initialize-matrix ((matrix lower-triangular-matrix) (data number)
                              (rows fixnum) (columns fixnum)
                              &optional (element-type t))
  "Initialize the lower triangular matrix with an initial element."
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type
                                    :initial-element (coerce 0 element-type)))))
    (dotimes (i0 rows matrix)
      (setf (aref contents i0 i0) data)
      (dotimes (i1 i0)
        (setf (aref contents i0 i1) data)))))

\nwendcode{}\nwbegindocs{552}When initialized with a nested sequence, the contents of the
triangular matrix are verified to be triangular using an internal
function.
\nwenddocs{}\nwbegincode{553}\moddef{Function: Verify that the nested sequence is triangular}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %initialize-upper-triangular-matrix-with-seq (matrix data
                                                     rows columns
                                                     element-type)
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type
                                    :initial-contents data))))
    (dotimes (i0 rows matrix)
      (dotimes (i1 i0)
        (unless (zerop (aref contents i0 i1))
          (error "Data is not upper triangular."))))))

(defun %initialize-lower-triangular-matrix-with-seq (matrix data
                                                     rows columns
                                                     element-type)
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type
                                    :initial-contents data))))
    (dotimes (i1 columns matrix)
      (dotimes (i0 i1)
        (unless (zerop (aref contents i0 i1))
          (error "Data is not lower triangular."))))))

\nwendcode{}\nwbegindocs{554}Two methods are required to process nested sequences, the first
specialized for lists as the first rank data structure.
\nwenddocs{}\nwbegincode{555}\moddef{Method: Initialize the triangular matrix with a nested sequence}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix upper-triangular-matrix) (data list)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the upper triangular matrix with a nested sequence."
  (%initialize-upper-triangular-matrix-with-seq matrix data
                                                rows columns
                                                element-type))

(defmethod initialize-matrix ((matrix lower-triangular-matrix) (data list)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the lower triangular matrix with a nested sequence."
  (%initialize-lower-triangular-matrix-with-seq matrix data
                                                rows columns
                                                element-type))

\nwendcode{}\nwbegindocs{556}The second method for nested sequences is specialized on vectors as
the first rank data structure.
\nwenddocs{}\nwbegincode{557}\moddef{Method: Initialize the triangular matrix with a nested sequence}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix upper-triangular-matrix) (data vector)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the upper triangular matrix with a nested sequence."
  (%initialize-upper-triangular-matrix-with-seq matrix data
                                                rows columns
                                                element-type))

(defmethod initialize-matrix ((matrix lower-triangular-matrix) (data vector)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the lower triangular matrix with a nested sequence."
  (%initialize-lower-triangular-matrix-with-seq matrix data
                                                rows columns
                                                element-type))

\nwendcode{}\nwbegindocs{558}Finally, a triangular matrix can also be initialized with a 2D array.
\nwenddocs{}\nwbegincode{559}\moddef{Method: Initialize the triangular matrix with a 2D array}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod initialize-matrix ((matrix upper-triangular-matrix) (data array)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the upper triangular matrix with a 2D array."
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type
                                    :initial-element (coerce 0 element-type)))))
    (dotimes (i1 columns matrix)
      (setf (aref contents i1 i1) (aref data i1 i1))
      (dotimes (i0 i1)
        (if (zerop (aref data i1 i0))
            (setf (aref contents i0 i1) (aref data i0 i1))
            (error "Data is not upper triangular."))))))

(defmethod initialize-matrix ((matrix lower-triangular-matrix) (data array)
                              (rows integer) (columns integer)
                              &optional (element-type t))
  "Initialize the lower triangular matrix with a 2D array."
  (let ((contents (setf (contents matrix)
                        (make-array (list rows columns)
                                    :element-type element-type
                                    :initial-element (coerce 0 element-type)))))
    (dotimes (i0 rows matrix)
      (setf (aref contents i0 i0) (aref data i0 i0))
      (dotimes (i1 i0)
        (if (zerop (aref data i1 i0))
            (setf (aref contents i0 i1) (aref data i0 i1))
            (error "Data is not lower triangular."))))))

\nwendcode{}\nwbegindocs{560}{\Tt{}initialize-matrix\nwendquote} was exported with the definition of the
generic function.

\subsection{Triangular Matrix Predicates}
\label{sec:triangular-matrix-predicates}

The function {\Tt{}upper-triangular-matrix-p\nwendquote} returns true if the object
is an upper triangular matrix and false otherwise.
\nwenddocs{}\nwbegincode{561}\moddef{Function: Triangular matrix predicates}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun upper-triangular-matrix-p (object)
  "Return true if object is an upper triangular matrix."
  (typep object 'upper-triangular-matrix))

\nwendcode{}\nwbegindocs{562}And {\Tt{}lower-triangular-martrix-p\nwendquote} returns true if the object is a
lower triangular matrix and false otherwise.
\nwenddocs{}\nwbegincode{563}\moddef{Function: Triangular matrix predicates}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun lower-triangular-matrix-p (object)
  "Return true if object is a lower triangular matrix."
  (typep object 'lower-triangular-matrix))

\nwendcode{}\nwbegindocs{564}{\Tt{}upper-triangular-matrix-p\nwendquote} and {\Tt{}lower-triangular-matrix-p\nwendquote} are
exported symbols.
\nwenddocs{}\nwbegincode{565}\moddef{Triangular matrix exports}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
:upper-triangular-matrix-p :lower-triangular-matrix-p
\nwendcode{}\nwbegindocs{566}\nwdocspar

\subsection{Inspecting Triangular Matrices}
\label{sec:inspecting-triangular-matrices}

All of the functions for inspecting matrices, {\Tt{}matrix-element-type\nwendquote},
{\Tt{}matrix-dimensions\nwendquote}, {\Tt{}matrix-row-dimension\nwendquote} and
{\Tt{}matrix-column-dimension\nwendquote} are applicable to triangular matrices.
Therefore, none of the matrix inspection functions are specialized for
the triangular matrix classes.

\subsection{Referencing Triangular Matrices}
\label{sec:referencing-triangular-matrices}

The matrix reference function, {\Tt{}mref\nwendquote}, specialized for the dense
matrix is applicable to the triangular matrices. A triangular matrix
is settable with the constraint that the zero elements cannot be set.
Therefore, {\Tt{}(setf\ mref)\nwendquote} is specialized for the triangular matrices.
The row index must be less than or equal to the column index to set an
upper triangular matrix.
\nwenddocs{}\nwbegincode{567}\moddef{Method: Triangular matrix element reference}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf mref) ((data number) (matrix upper-triangular-matrix)
                        (row fixnum) (column fixnum))
  "Set the element of matrix at row,column to data."
  (if (<= row column)
      (setf (aref (contents matrix) row column) data)
      (error "Elements below the diagonal must equal zero.")))

\nwendcode{}\nwbegindocs{568}The column index must be less than or equal to the row index to set
a lower triangular matrix.
\nwenddocs{}\nwbegincode{569}\moddef{Method: Triangular matrix element reference}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf mref) ((data number) (matrix lower-triangular-matrix)
                        (row fixnum) (column fixnum))
  "Set the element of matrix at row,column to data."
  (if (<= column row)
      (setf (aref (contents matrix) row column) data)
      (error "Elements above the diagonal must equal zero.")))

\nwendcode{}\nwbegindocs{570}{\Tt{}mref\nwendquote} was exported with the definition of the generic function.

\subsection{Copying Triangular Matrices}
\label{sec:copying-triangular-matrices}

The {\Tt{}copy-matrix\nwendquote} function is specialized for triangular matrices to
reduce the number of elements set by only updating the triangle.
\nwenddocs{}\nwbegincode{571}\moddef{Method: Copy a triangular matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod copy-matrix ((matrix upper-triangular-matrix))
  "Return a copy of the matrix."
  (let ((columns  (matrix-column-dimension matrix))
        (original (contents matrix))
        (contents (make-array (matrix-dimensions matrix)
                              :element-type
                              (matrix-element-type matrix))))
    (make-instance
     'upper-triangular-matrix
     :contents
     (dotimes (i1 columns contents)
       (setf (aref contents i1 i1) (aref original i1 i1))
       (dotimes (i0 i1)
         (setf (aref contents i0 i1) (aref original i0 i1)))))))

(defmethod copy-matrix ((matrix lower-triangular-matrix))
  "Return a copy of the matrix."
  (let ((rows     (matrix-row-dimension matrix))
        (original (contents matrix))
        (contents (make-array (matrix-dimensions matrix)
                              :element-type
                              (matrix-element-type matrix))))
    (make-instance
     'lower-triangular-matrix
     :contents
     (dotimes (i0 rows contents)
       (setf (aref contents i0 i0) (aref original i0 i0))
       (dotimes (i1 i0)
         (setf (aref contents i0 i1) (aref original i0 i1)))))))

\nwendcode{}\nwbegindocs{572}{\Tt{}copy-matrix\nwendquote} was exported with the definition of the generic
function.

\subsection{Manipulating Subsets of Triangular Matrices}
\label{sec:triangular-matrix-subsets}

The type of the subset of a triangular matrix depends on the ranges of
the subset. If the start and end row equals the start and end column,
respectively, a new triangular matrix is returned. If the number of
rows equals the number of columns, but the start and end rows do not
equal the start and end columns, respectively, a square matrix is
returned. Otherwise a dense matrix is returned.
\nwenddocs{}\nwbegincode{573}\moddef{Method: Subset of a triangular matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod submatrix ((matrix upper-triangular-matrix)
                      (row integer) (column integer)
                      &key row-end column-end)
  "Return a matrix created from the submatrix of matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let* ((numrows (- row-end row))
           (numcols (- column-end column))
           (original (contents matrix))
           (contents (make-array (list numrows numcols)
                                 :element-type
                                 (matrix-element-type matrix))))
      (make-instance
       (cond ((and (= row column) (= numrows numcols))
              'upper-triangular-matrix)
             ((= numrows numcols)
              'square-matrix)
             (t 'dense-matrix))
       :contents
       (dotimes (i0 numrows contents)
         (dotimes (i1 numcols)
           (setf (aref contents i0 i1)
                 (aref original (+ row i0) (+ column i1)))))))))

(defmethod submatrix ((matrix lower-triangular-matrix)
                      (row integer) (column integer)
                      &key row-end column-end)
  "Return a matrix created from the submatrix of matrix."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let* ((numrows (- row-end row))
           (numcols (- column-end column))
           (original (contents matrix))
           (contents (make-array (list numrows numcols)
                                 :element-type
                                 (matrix-element-type matrix))))
      (make-instance
       (cond ((and (= row column) (= numrows numcols))
              'lower-triangular-matrix)
             ((= numrows numcols)
              'square-matrix)
             (t 'dense-matrix))
       :contents
       (dotimes (i0 numrows contents)
         (dotimes (i1 numcols)
           (setf (aref contents i0 i1)
                 (aref original (+ row i0) (+ column i1)))))))))

\nwendcode{}\nwbegindocs{574}\nwdocspar

The submatrix of a triangular matrix is settable for only 2
conditions. The first condition is the start and end row equals the
start and end column, respectively.
\nwenddocs{}\nwbegincode{575}\moddef{Function: Subset of a triangular matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %setf-upper-triangular-submatrix-on-diagonal (matrix data row numrows)
  (let ((mat (contents matrix))
        (dat (contents data)))
    (do ((di0 0   (1+ di0))
         (mi0 row (1+ mi0)))
        ((>= di0 numrows) data)         ; Return the data
      (do ((di1 di0         (1+ di1))
           (mi1 (+ row di0) (1+ mi1)))
          ((>= di1 numrows))
        (setf (aref mat mi0 mi1) (aref dat di0 di1))))))

(defun %setf-lower-triangular-submatrix-on-diagonal (matrix data row numrows)
  (let ((mat (contents matrix))
        (dat (contents data)))
    (do ((di1 0   (1+ di1))
         (mi1 row (1+ mi1)))
        ((>= di1 numrows) data)         ; Return the data
      (do ((di0 di1         (1+ di0))
           (mi0 (+ row di1) (1+ mi0)))
          ((>= di0 numrows))
        (setf (aref mat mi0 mi1) (aref dat di0 di1))))))

\nwendcode{}\nwbegindocs{576}The second condition is the range of the subset does not interset
the diagonal. For an upper triangular matrix, this is equivalent to
saying the start column is greater than the end row. For a lower
triangular matrix, it is equivalent to saying the end column is less
than the start row.
\nwenddocs{}\nwbegincode{577}\moddef{Function: Subset of a triangular matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %setf-upper-triangular-submatrix-above-diagonal (matrix data
                                                        row column
                                                        numrows numcols)
  (let ((mat (contents matrix))
        (dat (contents data)))
    (do ((di0 0   (1+ di0))
         (mi0 row (1+ mi0)))
        ((>= di0 numrows) data)         ; Return the data
      (do ((di1 0      (1+ di1))
           (mi1 column (1+ mi1)))
          ((>= di1 numcols))
        (setf (aref mat mi0 mi1) (aref dat di0 di1))))))

(defun %setf-lower-triangular-submatrix-below-diagonal (matrix data
                                                        row column
                                                        numrows numcols)
  (let ((mat (contents matrix))
        (dat (contents data)))
    (do ((di1 0      (1+ di1))
         (mi1 column (1+ mi1)))
        ((>= di1 numcols) data)         ; Return the data
      (do ((di0 0   (1+ di0))
           (mi0 row (1+ mi0)))
          ((>= di0 numrows))
        (setf (aref mat mi0 mi1) (aref dat di0 di1))))))

\nwendcode{}\nwbegindocs{578}When the data is triangular, both conditions must be considered.
\nwenddocs{}\nwbegincode{579}\moddef{Method: Subset of a triangular matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf submatrix) ((data upper-triangular-matrix)
                             (matrix upper-triangular-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set a submatrix of matrix with data."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data))))
      (cond
        ((and (= row column) (= numrows numcols))
         (%setf-upper-triangular-submatrix-on-diagonal matrix data
                                                       row numrows))
        ((<= (+ row numrows -1) column)
         (%setf-upper-triangular-submatrix-above-diagonal matrix data
                                                          row column
                                                          numrows numcols))
        (t
         (error "Range(~D:~D,~D:~D) results in a non upper triangular matrix."
                row row-end column column-end))))))

(defmethod (setf submatrix) ((data lower-triangular-matrix)
                             (matrix lower-triangular-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set a submatrix of matrix with data."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data))))
      (cond
        ((and (= row column) (= numrows numcols))
         (%setf-lower-triangular-submatrix-on-diagonal matrix data
                                                       row numrows))
        ((<= (+ column numcols -1) row)
         (%setf-lower-triangular-submatrix-below-diagonal matrix data
                                                          row column
                                                          numrows numcols))
        (t
         (error "Range(~D:~D,~D:~D) results in a non lower triangular matrix."
                row row-end column column-end))))))

\nwendcode{}\nwbegindocs{580}When the data is any other type of matrix, only the second condition
needs to be considered.
\nwenddocs{}\nwbegincode{581}\moddef{Method: Subset of a triangular matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod (setf submatrix) ((data dense-matrix)
                             (matrix upper-triangular-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set the submatrix of matrix with data."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data))))
      (if (<= (+ row numrows -1) column)
          (%setf-upper-triangular-submatrix-above-diagonal matrix data
                                                           row column
                                                           numrows numcols)
          (error "Range(~D:~D,~D:~D) results in a non upper triangular matrix."
                 row row-end column column-end)))))

(defmethod (setf submatrix) ((data dense-matrix)
                             (matrix lower-triangular-matrix)
                             (row integer) (column integer)
                             &key row-end column-end)
  "Set the submatrix of matrix with data."
  (destructuring-bind (row column row-end column-end)
      (matrix-validated-range matrix row column row-end column-end)
    (let ((numrows (min (- row-end row)
                        (matrix-row-dimension data)))
          (numcols (min (- column-end column)
                        (matrix-column-dimension data))))
      (if (<= (+ column numcols -1) row)
          (%setf-lower-triangular-submatrix-below-diagonal matrix data
                                                           row column
                                                           numrows numcols)
          (error "Range(~D:~D,~D:~D) results in a non lower triangular matrix."
                 row row-end column column-end)))))

\nwendcode{}\nwbegindocs{582}\nwdocspar

Destructively replacing the subset of a triangular matrix is subject
to the same 2 conditions as setting the subset.
\nwenddocs{}\nwbegincode{583}\moddef{Function: Destructively replace a subset of a triangular matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun %replace-upper-triangular-matrix-on-diagonal (matrix1 matrix2
                                                     row1 column1
                                                     row2 column2
                                                     numrows numcols)
  "Destructively replace a subset on the diagonal of matrix1 with
matrix2."
  (let ((contents1 (contents matrix1))
        (contents2 (contents matrix2)))
    (do ((   i0 0    (1+ i0))
         (m1-i0 row1 (1+ m1-i0))
         (m2-i0 row2 (1+ m2-i0)))
        ((>= i0 numrows) matrix1)       ; Return matrix1
      (do ((   i1 i0             (1+ i1))
           (m1-i1 (+ column1 i0) (1+ m1-i1))
           (m2-i1 (+ column2 i0) (1+ m2-i1)))
          ((>= i1 numcols))
        (setf (aref contents1 m1-i0 m1-i1) (aref contents2 m2-i0 m2-i1))))))

(defun %replace-lower-triangular-matrix-on-diagonal (matrix1 matrix2
                                                     row1 column1
                                                     row2 column2
                                                     numrows numcols)
  "Destructively replace a subset on the diagonal of matrix1 with
matrix2."
  (let ((contents1 (contents matrix1))
        (contents2 (contents matrix2)))
    (do ((   i1 0       (1+ i1))
         (m1-i1 column1 (1+ m1-i1))
         (m2-i1 column2 (1+ m2-i1)))
        ((>= i1 numcols) matrix1)       ; Return matrix1
      (do ((   i0 i1          (1+ i0))
           (m1-i0 (+ row1 i1) (1+ m1-i0))
           (m2-i0 (+ row2 i1) (1+ m2-i0)))
          ((>= i0 numrows))
        (setf (aref contents1 m1-i0 m1-i1) (aref contents2 m2-i0 m2-i1))))))

(defun %replace-upper-triangular-matrix-above-diagonal (matrix1 matrix2
                                                        row1 column1
                                                        row2 column2
                                                        numrows numcols)
  "Destructively replace a subset off the diagonal of matrix1 with
matrix2."
  (let ((contents1 (contents matrix1))
        (contents2 (contents matrix2)))
    (do ((   i0 0    (1+ i0))
         (m1-i0 row1 (1+ m1-i0))
         (m2-i0 row2 (1+ m2-i0)))
        ((>= i0 numrows) matrix1)       ; Return matrix1
      (do ((   i1 0       (1+ i1))
           (m1-i1 column1 (1+ m1-i1))
           (m2-i1 column2 (1+ m2-i1)))
          ((>= i1 numcols))
        (setf (aref contents1 m1-i0 m1-i1) (aref contents2 m2-i0 m2-i1))))))

(defun %replace-lower-triangular-matrix-below-diagonal (matrix1 matrix2
                                                        row1 column1
                                                        row2 column2
                                                        numrows numcols)
  "Destructively replace a subset off the diagonal of matrix1 with
matrix2."
  (let ((contents1 (contents matrix1))
        (contents2 (contents matrix2)))
    (do ((   i0 0    (1+ i0))
         (m1-i0 row1 (1+ m1-i0))
         (m2-i0 row2 (1+ m2-i0)))
        ((>= i0 numrows) matrix1)       ; Return matrix1
      (do ((   i1 0       (1+ i1))
           (m1-i1 column1 (1+ m1-i1))
           (m2-i1 column2 (1+ m2-i1)))
          ((>= i1 numcols))
        (setf (aref contents1 m1-i0 m1-i1) (aref contents2 m2-i0 m2-i1))))))

\nwendcode{}\nwbegindocs{584}Similarly, when both matrices are triangular, both conditions must
be considered.
\nwenddocs{}\nwbegincode{585}\moddef{Method: Destructively replace a subset of a triangular matrix}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod replace-matrix ((matrix1 upper-triangular-matrix)
                           (matrix2 upper-triangular-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of matrix1 with matrix2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2))))
        (cond
          ((and (= row1 column1) (= row2 column2) (= numrows numcols))
           (%replace-upper-triangular-matrix-on-diagonal matrix1 matrix2
                                                         row1 column1
                                                         row2 column2
                                                         numrows numcols))
          ((<= (+ row1 numrows -1) column1)
           (%replace-upper-triangular-matrix-above-diagonal matrix1 matrix2
                                                            row1 column1
                                                            row2 column2
                                                            numrows numcols))
          (t
           (error "Range(~D:~D,~D:~D) results in a non upper triangular matrix."
                  row1 (+ row1 numrows -1) column1 (+ column1 numcols -1))))))))

(defmethod replace-matrix ((matrix1 lower-triangular-matrix)
                           (matrix2 lower-triangular-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of matrix1 with matrix2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2))))
        (cond
          ((and (= row1 column1) (= row2 column2) (= numrows numcols))
           (%replace-lower-triangular-matrix-on-diagonal matrix1 matrix2
                                                         row1 column1
                                                         row2 column2
                                                         numrows numcols))
          ((<= (+ column1 numcols -1) row1)
           (%replace-lower-triangular-matrix-below-diagonal matrix1 matrix2
                                                            row1 column1
                                                            row2 column2
                                                            numrows numcols))
          (t
           (error "Range(~D:~D,~D:~D) results in a non lower triangular matrix."
                  row1 (+ row1 numrows -1) column1 (+ column1 numcols -1))))))))

\nwendcode{}\nwbegindocs{586}When only the matrix being destructively modified is triangular,
only the second condition must be considered.
\nwenddocs{}\nwbegincode{587}\moddef{Method: Destructively replace a subset of a triangular matrix}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defmethod replace-matrix ((matrix1 upper-triangular-matrix)
                           (matrix2 dense-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of matrix1 with matrix2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2))))
        (if (<= (+ row1 numrows -1) column1)
            (%replace-upper-triangular-matrix-above-diagonal matrix1 matrix2
                                                             row1 column1
                                                             row2 column2
                                                             numrows numcols)
            (error "Range(~D:~D,~D:~D) results in a non upper triangular matrix."
                   row1 (+ row1 numrows -1) column1 (+ column1 numcols -1)))))))

(defmethod replace-matrix ((matrix1 lower-triangular-matrix)
                           (matrix2 dense-matrix)
                           &key (row1 0) row1-end (column1 0) column1-end
                           (row2 0) row2-end (column2 0) column2-end)
  "Replace the elements of matrix1 with matrix2."
  (destructuring-bind (row1 column1 row1-end column1-end)
      (matrix-validated-range matrix1 row1 column1 row1-end column1-end)
    (destructuring-bind (row2 column2 row2-end column2-end)
        (matrix-validated-range matrix2 row2 column2 row2-end column2-end)
      (let ((numrows (min (- row1-end row1) (- row2-end row2)))
            (numcols (min (- column1-end column1) (- column2-end column2))))
        (if (<= (+ column1 numcols -1) row1)
            (%replace-lower-triangular-matrix-below-diagonal matrix1 matrix2
                                                             row1 column1
                                                             row2 column2
                                                             numrows numcols)
            (error "Range(~D:~D,~D:~D) results in a non lower triangular matrix."
                   row1 (+ row1 numrows -1) column1 (+ column1 numcols -1)))))))

\nwendcode{}\nwbegindocs{588}{\Tt{}submatrix\nwendquote} and {\Tt{}replace-matrix\nwendquote} were exported with the
definitions of the generic functions.

% Bibliography
\bibliography{bibliography}
\bibliographystyle{plain}

\appendix

\chapter{Auxiliary Functions and Macros}
\label{chap:auxiliary}

The auxiliary functions to support the linear algebra routines are
presented in this appendix. None of these routines are exported from
the linear algebra package.
\nwenddocs{}\nwbegincode{589}\moddef{auxiliary.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}In linear algebra package\RA{}
\LA{}Function: Square root of the sum of 2 arguments squared\RA{}
\LA{}Function: Square root of the sum of 3 arguments squared\RA{}
\LA{}Function: Binary operation with scaled arguments\RA{}
\LA{}Function: Common class of 2 objects\RA{}
\LA{}Function: Complex equality\RA{}
\LA{}Function: Numeric equality dispatch\RA{}
\nwendcode{}\nwbegindocs{590}The auxiliary functions only depend on the definition of the linear
algebra package.
\nwenddocs{}\nwbegincode{591}\moddef{Auxiliary dependencies}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(:file "auxiliary"
       :depends-on ("defpackage"))
\nwendcode{}\nwbegindocs{592}\nwdocspar

\section{Square Root of the Sum of 2 or 3 Squares}
\label{sec:lapy}

The function {\Tt{}sumsq\nwendquote}, page\ref{sec:sumsq}, is used to calculate the
square root of the sum of the squares of an arbitrary number of values
stored in a vector. In the BLAS library, there are 2 utility functions
that perform this calculation for 2 or 3 squares. The {\Tt{}lapy2\nwendquote}
function returns the square root of the sum of 2 squares.
\begin{equation}
  \label{eq:lapy2}
  \result \leftarrow \sqrt{|x|^2 + |y|^2}
\end{equation}
\nwenddocs{}\nwbegincode{593}\moddef{Function: Square root of the sum of 2 arguments squared}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun lapy2 (x y)
  "Return the square root of |x|^2 + |y|^2."
  (let* ((abs-x (abs x))
         (abs-y (abs y))
         (w (max abs-x abs-y)))
    (* w (sqrt (+ 1 (expt (/ (min abs-x abs-y) w) 2))))))

\nwendcode{}\nwbegindocs{594}Similarly, the {\Tt{}lapy3\nwendquote} function returns the square root of the sum
of 3 squares.
\begin{equation}
  \label{eq:lapy3}
  \result \leftarrow \sqrt{|x|^2 + |y|^2 + |z|^2}
\end{equation}
\nwenddocs{}\nwbegincode{595}\moddef{Function: Square root of the sum of 3 arguments squared}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun lapy3 (x y z)
  "Return the square root of |x|^2 + |y|^2 + |z|^2."
  (let* ((abs-x (abs x))
         (abs-y (abs y))
         (abs-z (abs z))
         (w (max abs-x abs-y abs-z)))
    (* w (sqrt (+ (expt (/ abs-x w) 2)
                  (expt (/ abs-y w) 2)
                  (expt (/ abs-z w) 2))))))

\nwendcode{}\nwbegindocs{596}{\Tt{}lapy2\nwendquote} and {\Tt{}lapy3\nwendquote} are not exported symbols. {\Tt{}lapy2\nwendquote} is used
in the {\Tt{}householder-reflection\nwendquote} function. {\Tt{}lapy3\nwendquote} is not used, but
it is anticipated that it will be useful for coordinate vector
implementations. At some point, these functions need to be given a
``lispy'' name and exported.

\section{Binary Operation with Scaled Arguments}
\label{sec:scaled-binary-op}

There are many situations where the arguments to a binary operation
such as an addition or subtraction are optionally scaled. Rather than
defining multiplication by 1 when the arguments are not scaled, this
function returns the appropriate binary operation.
\nwenddocs{}\nwbegincode{597}\moddef{Function: Binary operation with scaled arguments}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun scaled-binary-op (op scalar1 scalar2)
  "Return the correct scaled binary operation."
  (cond
    ((and (null scalar1) (null scalar2)) op)
    ((null scalar1)
     (lambda (n1 n2) (funcall op n1 (* scalar2 n2))))
    ((null scalar2)
     (lambda (n1 n2) (funcall op (* scalar1 n1) n2)))
    (t (lambda (n1 n2)
         (funcall op (* scalar1 n1) (* scalar2 n2))))))

\nwendcode{}\nwbegindocs{598}{\Tt{}scaled-binary-op\nwendquote} is not an exported symbol.

\section{Common Class of Two Objects}
\label{sec:common-class-of}

One of the motivations for defining the linear algebra objects using
the CLOS was to allow subclasses to be developed that rely on the
methods of the superclass. For binary operations such as addition,
subtraction and product, it is desirable that the result of the
operation be as specific as possible. The function,
{\Tt{}common-class-of\nwendquote}, performs 3 rudimentary tests to ascertain the
most specific class for the result. The first test checks if the
objects are instances of the same class. The next 2 tests check if one
of the objects is a subtype of the other. If none of the tests are
successful, a default class is returned if it was specified, otherwise
an error is raised.
\nwenddocs{}\nwbegincode{599}\moddef{Function: Common class of 2 objects}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(defun common-class-of (object1 object2 &optional
                        (default-class nil default-class-p))
  "Return the common class of the 2 objects or default-class."
  (let ((class1 (class-of object1))
        (class2 (class-of object2)))
    (cond
      ((eq class1 class2) class1)
      ((subtypep class1 class2) class2)
      ((subtypep class2 class1) class1)
      (t (if default-class-p
             (find-class default-class)
             (error "No common or default class."))))))

\nwendcode{}\nwbegindocs{600}{\Tt{}common-class-of\nwendquote} is not an exported symbol.

\section{Numeric Equality}
\label{sec:numeric-equality}

Two equality functions are required for the linear algebra library.
Both functions rely on the Floating Point package for comparing
floating point numbers. The first equality function,
{\Tt{}complex-equal\nwendquote}, verifies that the numbers being compared are
complex and then dispatches the comparison to {\Tt{}float-equal\nwendquote} for
complex numbers with floating point components and to {\Tt{}=\nwendquote} for
complex numbers with rational components.
\nwenddocs{}\nwbegincode{601}\moddef{Function: Complex equality}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; (COMPLEX-EQUAL number1 number2) => true or false
(defun complex-equal (complex1 complex2 &optional (epsilon *epsilon*))
  "Return true if both numbers are complex and equal."
  (cond
    ((or (typep complex1 '(complex float))
         (typep complex2 '(complex float)))
     (float-equal complex1 complex2 epsilon))
    ((or (typep complex1 '(complex integer))
         (typep complex2 '(complex integer)))
     (= complex1 complex2))
    (t (error "Arguments are not complex."))))

\nwendcode{}\nwbegindocs{602}The second equality function, {\Tt{}number-equal\nwendquote}, accepts any type of
numeric argument and dispatches the equality to {\Tt{}float-equal\nwendquote} for
floating point numbers and to {\Tt{}=\nwendquote} for rational numbers.
\nwenddocs{}\nwbegincode{603}\moddef{Function: Numeric equality dispatch}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;; (NUMBER-EQUAL number1 number2) => true or false
(defun number-equal (number1 number2 &optional (epsilon *epsilon*))
  "Return true if the numbers are equal using the appropriate
comparison."
  (cond
    ((or (floatp number1) (floatp number2))
     (float-equal number1 number2 epsilon))
    ((and (rationalp number1) (rationalp number2))
     (= number1 number2))
    ((or (typep number1 '(complex float))
         (typep number2 '(complex float)))
     (float-equal number1 number2 epsilon))
    ((and (typep number1 '(complex rational))
          (typep number2 '(complex rational)))
     (= number1 number2))
    (t (error "Non-numeric arguments."))))

\nwendcode{}\nwbegindocs{604}Neither of the equality functions are exported.

\chapter{System and Package Definition}
\label{chap:package}

Numerical linear algebra in Common Lisp is distributed under the BSD
copyright.
\nwenddocs{}\nwbegincode{605}\moddef{BSD Copyright}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#|

 Linear Algebra in Common Lisp

 Copyright (c) 2010, Thomas M. Hermann
 All rights reserved.

 Redistribution and  use  in  source  and  binary  forms, with or without
 modification, are permitted  provided  that the following conditions are
 met:

   o  Redistributions of  source  code  must  retain  the above copyright
      notice, this list of conditions and the following disclaimer.
   o  Redistributions in binary  form  must reproduce the above copyright
      notice, this list of  conditions  and  the  following disclaimer in
      the  documentation  and/or   other   materials  provided  with  the
      distribution.
   o  The names of the contributors may not be used to endorse or promote
      products derived from this software without  specific prior written
      permission.

 THIS SOFTWARE IS  PROVIDED  BY  THE  COPYRIGHT  HOLDERS AND CONTRIBUTORS
 "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES, INCLUDING,  BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR  CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED TO,
 PROCUREMENT OF  SUBSTITUTE  GOODS  OR  SERVICES;  LOSS  OF USE, DATA, OR
 PROFITS; OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER  IN  CONTRACT,  STRICT  LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR  OTHERWISE)  ARISING  IN  ANY  WAY  OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

|#

\nwendcode{}\nwbegindocs{606}\nwdocspar

\nwenddocs{}\nwbegincode{607}\moddef{defpackage.lisp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}BSD Copyright\RA{}
(common-lisp:defpackage :linear-algebra
  (:use :common-lisp :floating-point)
  (:export
   ;; Fundamental operations
   \LA{}Fundamental operation exports\RA{}
   ;; Vector exports
   \LA{}Vector exports\RA{}
   ;; Matrix interface
   \LA{}Matrix exports\RA{}
   ;; Identity matrix
   \LA{}Identity matrix exports\RA{}
   ;; Permutation matrix
   \LA{}Permutation matrix exports\RA{}
   ;; Data vector exports
   \LA{}Data vector exports\RA{}
   ;; Dense matrix
   \LA{}Dense matrix exports\RA{}
   ;; Square matrix
   \LA{}Square matrix exports\RA{}
   ;; Hermitian matrix
   \LA{}Hermitian matrix exports\RA{}
   ;; Symmetric matrix
   \LA{}Symmetric matrix exports\RA{}
   ;; Triangular matrix
   \LA{}Triangular matrix exports\RA{}))
\nwendcode{}\nwbegindocs{608}\nwdocspar

\nwenddocs{}\nwbegincode{609}\moddef{linear-algebra.asd}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
;;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp -*-
\LA{}BSD Copyright\RA{}

(common-lisp:defpackage #:linear-algebra-system
  (:use :common-lisp :asdf))

(common-lisp:in-package #:linear-algebra-system)

(defsystem :linear-algebra
  :description "Linear Algebra in Common Lisp."
  :version "Draft"
  :author "Thomas M. Hermann <tmh.public@gmail.com>"
  :license "BSD"
  :depends-on ("floating-point")
  :components
  ((:module
    linear-algebra
    :components
    ((:file "defpackage")
     \LA{}Auxiliary dependencies\RA{}
     \LA{}Fundamental operation dependencies\RA{}
     \LA{}Vector dependencies\RA{}
     \LA{}Matrix dependencies\RA{}
     \LA{}Identity matrix dependencies\RA{}
     \LA{}Permutation matrix dependencies\RA{}
     \LA{}Data vector dependencies\RA{}
     \LA{}Dense matrix dependencies\RA{}
     \LA{}Square matrix dependencies\RA{}
     \LA{}Hermitian matrix dependencies\RA{}
     \LA{}Symmetric matrix dependencies\RA{}
     \LA{}Triangular matrix dependencies\RA{}))))
\nwendcode{}\nwbegindocs{610}\nwdocspar

\end{document}
\nwenddocs{}
